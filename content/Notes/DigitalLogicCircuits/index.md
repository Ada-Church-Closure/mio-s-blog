+++
date = '2025-06-27T21:34:27+08:00'
draft = false
title = 'DigitalLogicCircuits'

+++

# 数字电路基础

我对于学校数字电路实验的评教，今天遇到了一些事情，真的非常生气，我不写出来实在是难受：

​	我校的以vivado为开发平台的数字电路实验是相当不合理的：

​	1.学生对于vivado没有相当的基础，身为一名计算机学院的学生，对于计算机组成原理的重要性认知很清楚，但是对于硬件开发没有合理的认知水平，理论铺设不到位，对于使用的软件更是一知半解。所以我们的实验是怎么开展的呢，“抄代码”，对着截了很多模糊不清的图片的PPT，抄，抄有着“详细注释”的宋体代码，我们试图在西一楼106机房“抄”出来对于数字电路的认知，这是难以置信的。

​	2.“你为什么不自己学？”，“自学”，难道我们不懂？一名大二计算机学院的学生，很少有人到现在还体会不到技术上自学的重要性，仅仅是为了搞清楚verilog的语法，你只需要随便上什么菜鸟教程之类的网站看一看就可以，我想说的是，你们给学生泼了一瓢冷水，当我在自己的linux系统上用iverilog编译生成运行测试第一个器件的时候，感受到的兴奋是难以言表的，但是，大多数学生只能在这里感受到重复性劳动的痛苦，以及不明不白的迷惑，因为他们debug的方式就是对这“权威”的PPT进行一行一行的寻找，想找到是否有一个变量名“抄”错了，或者把一个点打成了逗号却没有报错，为什么，因为他们不知道还能使用怎样的方式进行debug了，我还能用怎样的词语来形容这样的学习？

​	3.而当代码太多的时候，我相信很多老师对于debug也并没有任何头绪，对于一些更深层次的原理也并没有深刻理解，我在实验四中选择了第一个，我相信选择第一个的人是比较少的，因为大家都认为第二个分多，我对于分数的看法是无所谓的，我想，我只要把一个东西弄明白对我来说哪怕是完成任务也是一种收获，在实验四验收期间，我一直在观察，有一位老师基本没有解决任何问题，而是指挥来指挥去，当我向一位老师请教关于第一个学号计数器的问题时，他好像用很好奇的眼神看着我，好像没有人写这个实验一样，不停的请教您们不下5次，我相信不只是我这样，很多同学都是这样，有的人甚至走的时候都没有找到问题在哪里，我不停的对着PPT看，找问题所在，最后把我的counter实现交给了ChatGPT进行优化（实现没有问题，好像是因为边沿检测的问题，原来普通的counter的逻辑不符合要求，最后留下来的很多同学居然是实验1的，简直是难以置信，设计文件的考察更是让人无语，自己补充两个引脚即可，这样考察的意义在哪里？好像是某种脑筋急转弯让人费解。），因为不同老师的不同建议走了很多奇怪的弯路，不过我倒是对此没有什么怨言，因为debug就是这样，我也经历过很多，所以我也并不着急，我只是觉得您们对于自己设计的东西，设计的任务不够熟悉，好像也是在完成任务，我知道你们也是人，也会出错，但是应该起码对于下达的作业有着“**胸有成竹**”的一种状态才是比较合适的。

​	4.这不是老师们对于学生此方面基础不好的包容，这是一种设计和讲解上的问题，这些做的一塌糊涂的模糊PPT的堆砌，在让学生理解和实践的方面，甚至不如实践教学中心的电工实习！如果您要问我如何解决，**对不起，作为学生，我真的水平很低，我只会动动嘴皮子，我不是讲师也并非教授，我没有那么丰富的经验和知识，这也是我为什么来到大学**，但是本学期一个简单的0.5学分的实验，让我再一次反思。我对于硬件的开发并没有深厚的兴趣，或许在我大学毕业之后的一生中都不会再去进行把代码烧录到开发板这样的工作，但是我还是不吐不快，我现在只希望下个学期的三个1个学分的核心专业课程的实验不会让人感到失望，不会让学生们感到是在完成某项任务，想尽办法和“抄袭”和“查重”作对，总之，大量的学生花费了大量的时间在这里，得到的东西确实寥寥无几，但是讽刺的是，我认为大多数人也不会有怨言，因为我们需要学分，需要GPA来毕业，无法毕业是谁都难以接受的，这是否是单方面的霸凌呢？我不知道。我很明白，因为我之前在后面也观察到了，今年的开课是否是“实验性”的，你们对此也没有把控，但是我想你们应该会想听到这样的声音，因为不会再有学生在期末周浪费自己的备考时间给您们写这些没用的“小作文”，我的批评相当主观甚至可能偏激，略显傲慢，我明白老师们可能也为此付出了努力，但是，如果您还因为认为自己是一名教育工作者而想继续优化和承担责任的话，那么请您继续优化和思考（或许可以先从把PPT上的代码从宋体改成Consolas等宽字体开始，这并不复杂，在Tools里面选择一下就可以），如果您不这么认为，那么当我什么也没有说就好。最后我想告诉您，无论是谁看到，但是希望不是我的自我安慰：

> *"Education is not the filling of a pail, but the lighting of a fire." ---William Butler Yeats*
>
> （教育不是给桶里灌水，而是点燃一把火）

​	而接下来，对于数字电路的理论，我又要对着PPT复习，这也是没有办法的。我承认孩子们，这就是一场**PPT**大战，但是能写一点代码也是不错的。

​															---2025.6.15 21:13  写于西安交通大学仲英书院

> [!CAUTION]
>
> ​	有些人不配作为教育者，他们在尝试和学生**斗争**，尝试满足某种**“指标”**，他们连从事科学研究的资格都没有。这是我对于这些人最严厉的攻击和指责。

> **考试大致的情况**：
>
> 教材前4章（**习题**）及教师上课讲解过的内容为**本次考题涉及范围**，复习的重点内容概括如下：
> 	**第一章**：数制与编码、逻辑代数基础（定律、定理、规则）、逻辑函数的表示及化简方法、逻辑门电路（涉及填空、简答题）。
> 	**第二章**：组合逻辑电路的**分析与设计**、竞争与险象（**判别和消除方法**）、常用**MSI**器件（**译码器、编码器、多路选择器、三态缓冲器、加法器**）。
> 	**第三章**：时序电路**概念**、**双稳态元件**的原理（重点是**触发器**）、**同步时序电路的分析与设计方法**、**脉冲异步时序电路分析与设计方法**、常用**时序逻辑器件**（**计数器、寄存器**）。
> 	**第四章**：**SPLD、CPLD、FPGA**的基本原理（仅涉及**填空、选择、简答题**）、**VHDL**和**Verilog**（涉及**填空、简答和编程题**）。
>
> ​	**考试题型**：1）**填空题20分**，任选**10题**，多选按前10题给分。2）**选择题20分**，任选**5题**，多选按前5题给分，选择题为多选，**错选和少选1项扣1分**。3）简答题**15分**，任选**5题**，多选按前5题给分。4）分析计算题20分，涉及前3章内容，要求给出关键分析步骤，按步骤给分。5）设计题25分，组合和时序逻辑电路设计各1题，VHDL或Verilog编程题1题，要给出**关键设计或编程步骤**，按步骤给分。
>
> 集中答疑时间：下周四（6月26日），时间：9:00 11:30；14:30 17:30，地点：西一楼，B809（伍老师办公室）、A405（刘老师办公室）、A102（王老师办公室）

![1985BD9BF2A1FF330EB0793C42208793](/img/1985BD9BF2A1FF330EB0793C42208793.jpg)

1.精度问题，前面的部分可以把第一章作业过一遍。

> ​	补充，最后期末考了76,平时分给了97（因为我每次都去迁到了），就突击而言还算可以，均分好像都挺低的，很恶心的是考查了很多第4章的内容，甚至第四章一些奇怪的内容能有35%左右的占比，很恶心。
>



## 数制和编码

### 数制相互转换

***必考：不同进制之间的转换：**

注意需要的小数的位数：

比如（0.4321）10进制 转 16进制 那么至少这个16进制的数字小数点要多少位？



![image-20250613201417669](/img/image-20250613201417669.png)

### 数的表示

浮点表示方法，用阶码和尾数来进行表示的方法。

带符号数：**原码，补码，反码**。

**原码：最高位是符号位。**

x = ＋5     [x]原 = 00000101
y = －7     [y]原 = 10000111



**反码：正数和原码相同，负数是原码的非符号位全部取反。---》注意这个**

x = ＋5     [x]原 = 00000101     [x]反  = 00000101

y = －7     [y]原 = 10000111     [y]反  = 11111000

z = 0       [z]反 = 00000000     [z]反  = 11111111       

**把符号位看作一位数值位参与运算，一律按加法规则来处理，所得结果的符号位也就是正确结果的符号（不出现进位）。**

**当符号位产生进位时，将产生的进位加到数值位的最低位。**---》这个也要注意



**补码（complement number），又称“对2的补码”。**

 x = ＋5     [x]原 = 00000101     [x]补   = 00000101
 y = －7     [y]原 = 10000111     [y]补   = 11111001
 z = 0       [y]原 = 00000000     [z]补   = 00000000
 z=-128                          [z]补  = 10000000



这个我们已经比较熟悉了。负数是**原码的非符号位按位取反 + 1**。---》反码 + 1



![image-20250613203403692](/img/image-20250613203403692.png)





### 十进制数的编码（代码）表示及其运算 

![image-20250613204906716](/img/image-20250613204906716.png)





8421：8421的权重。

2421：2421的权重。**对9自补码**。

余3码：8421权重，然后减去3。

### 可靠性编码

#### **格雷码（Gray)**

特点：任意两个相邻数的代码（码字）只有一个二进制数位不同。
目的：减少代码生成时发生错误。

![image-20250613210931201](/img/image-20250613210931201.png)



原来的二进制码每两个之间做**xor**运算得到**Gray**码。



![image-20250613211054376](/img/image-20250613211054376.png)



这种典型格雷码还有一个特点：
    所有对应于十进制数2 m -1 (m为正整数）的格雷码，都仅在m位上有 1，
其他位都为0。
    例：
    m = 1 ,  2 m  -1 = 1,       1的典型格雷码是0001；
    m = 2 ,  2 m -1 = 3,       3的典型格雷码是0010；
    m = 3 ,  2 m -1 = 7,       7的典型格雷码是0100；
    m = 4 ,  2 m -1 = 15,      15的典型格雷码是1000。  

​	这些数与 0 之间只有一位的差别，回到 0仍能保持一位差别的特点，所以称作循环码，特别适用做二进制码计数器的编码。

#### 奇偶校验码（Parity Code）



![image-20250613211808489](/img/image-20250613211808489.png)

注意：**是P的取值使得其中的1的个数是奇数还是偶数**。---》重点。

那么生成的原理也就很简单了。

#### 海明校验码（Hamming codes）



![image-20250613212252832](/img/image-20250613212252832.png)

很巧妙，考试之前再过一遍比较好。

## 逻辑代数基础



不说废话，重要的几个定理：

### 定理

> 要注意书上的例子，吸收定理之类的东西用来化简。



![image-20250614212927823](/img/image-20250614212927823.png)





![image-20250614213028431](/img/image-20250614213028431.png)



对偶函数和反演函数：

![image-20250614213329286](/img/image-20250614213329286.png)



同或和异或运算：

![image-20250614214037738](/img/image-20250614214037738.png)



基本表达式：

![image-20250614214223290](/img/image-20250614214223290.png)



### 逻辑函数的基本表达形式

与或 或与

最小项和最大项：

**0替代反变量**

![image-20250615163648802](/img/image-20250615163648802.png)

**1替代反变量**



![image-20250615163846369](/img/image-20250615163846369.png)



关系：（这也是为什么表示的方法会不一样）

![image-20250615164312690](/img/image-20250615164312690.png)

#### *（重点）卡诺图：

要不要记忆？考试前看一看。



![image-20250615165208923](/img/image-20250615165208923.png)

![image-20250615165347311](/img/image-20250615165347311.png)

![image-20250615170252240](/img/image-20250615170252240.png)

**n 变量函数卡诺图有2n个小方格(或称为单元), 小方格对应最小项。一个逻辑函数可以唯一地图示于卡诺图上。**

![image-20250615170536712](/img/image-20250615170536712.png)

![image-20250615170702979](/img/image-20250615170702979.png)

简单的例题，我们去求或与项的一个表示：

（先求反函数的与或式）

![image-20250615171040378](/img/image-20250615171040378.png)

对偶方法：

先算出对偶式接着进行化简，同样使用反函数的方法也可以。

那么在卡诺图上也类似：

我们用这样的方法求最简的或与式。

![image-20250615172210301](/img/image-20250615172210301.png)

如果有无关项尽可能多包含，这样就可以减少变量的个数。

#### 减少非门的个数的方法

​	 1.  **替代尾因子法** 定义：**每个与项中原变量部分称为“头因子”，反变量部分称为“尾因子”。 特点：把头因子中的任何变量放入任一个尾因子中，该与项不变，即头因子是不变的，尾因子是可变的** 。 

![image-20250615173153635](/img/image-20250615173153635.png)



![image-20250615173243218](/img/image-20250615173243218.png)

​	2.**禁止逻辑法**：从卡诺图中干掉一部分，这样就能构成更多的大极大圈。

![image-20250615212811011](/img/image-20250615212811011.png)



直接用最小项之和的非进行 * 操作。

## 逻辑门电路

这一章感觉不是东西，考试前再看一下。

> 必须好好看一下，防止送了。

### 早期逻辑门

### 双极型晶体管逻辑 基本双极型晶体管逻辑

### MOS晶体管、传输门

### 集成电路集成电路制造技术、封装、规模类型以及使用特性

# 组合逻辑电路

## 描述

![image-20250615215044116](/img/image-20250615215044116.png)



常用逻辑门的符号：注意**xor**门的方框内的数字是1。

![image-20250615215356649](/img/image-20250615215356649.png)

表明有效的形式：

![image-20250615220407027](/img/image-20250615220407027.png)

延迟时间等等的基本概念，我们之后还会再次提到。

## 分析和设计

### 1、组合逻辑电路的分析

​	电路输出仅取决于当时（前）的输入，而与过去的输入情况无关。

​	**逻辑图，真值表。**

### 2、组合逻辑电路的设计

设计的一般步骤：

> 做几个题试一试就行。
>
> 下面这个顺序有可能会考察，第一部不是先列出真值表。
>
> 分析要求---真值表（卡诺图化简）---最简表达式---变换（使用不同的门电路）---作出电路逻辑图

![image-20250617205047984](/img/image-20250617205047984.png)

可能会有逻辑电路变换的要求，这样的性能更好。基本都是在进行二次求反。

![image-20250617210843236](/img/image-20250617210843236.png)

![image-20250617210917219](/img/image-20250617210917219.png)

这样的设计目前感觉还是比较基础的：

![image-20250617212249328](/img/image-20250617212249328.png)

简单的HalfAdder的描述：

![image-20250617212942435](/img/image-20250617212942435.png)

## 竞争和险象

> 注意很多比较细节的考察问题。

### 电路中普遍存在竞争现象

**静态险象**：功能险象、逻辑险象

动态险象

​	**在实际电路中，信号变化不是即时的，存在边沿转换时间；信号在电路中传送必定有导线上的传播时延，信号通过门电路也必定有时间延迟。**

​	比如这样的一个**尖峰脉冲**的延迟：

​	![image-20250617224759748](/img/image-20250617224759748.png)

​	上述这些时延都可能使电路信号的中间结果及最终输出产生错误的信号。为简化讨论，下面假设信号变化的边沿转换时间为“0”，信号在导线上的传输时间为“0”， 仅考虑逻辑门的时延时间td(Delays) 。

> 就是说关于**delay**，我们只考虑在逻辑门上面的时延。

1.**竞争现象**

​	**竞争定义**：某一个信号或同时变化的多个信号，经过不同路径到达某一点时有**时差**（**传输及器件延时等造成的**），这 种现象称为**竞争**。

​	**竞争分类**：对于**有错误输出的竞争称之为临界竞争**，对于**未产生错误输出的竞争称之为非临界竞争**。



​	**2.Hazard---险象** 

​	险象定义：由于**临界竞争**的存在，在**输出端得到稳定输出之前**，输出中有一段的**错误输出**（干扰），这种现象称之为险象。险象一定是竞争的结果。

​	险象分类：通常将险象分为**静态险象**和**动态险象**两种类型。



​	**静态险象**：

​	当**输入信号变化**时，按逻辑表达式，输出不应有变化的情况下，而实际上会在输出端产生一个与逻辑状态“1”或“0”对应的**高低窄（矮）脉冲**的情况，则称之为**静态险象**。

​	就比如说下图就是一个静态的险象：

​	![image-20250617230043234](/img/image-20250617230043234.png)

​	它可进一步分为：**功能险象，逻辑险象**。

​	1.**功能险象**：

​	产生的必要条件：

​		1.**K个输入信号同时产生变化（因为多个信号变化的时候应该是在实现某种功能）**。2.这K个信号组成的序列中，必须既有0又有1。

![image-20250618235610515](/img/image-20250618235610515.png)

​	2.**逻辑险象**：

​	必要条件：**只有1个输入信号发生变化**。

> 其实都是一个例子。

![image-20250618235852694](/img/image-20250618235852694.png)

**静态险象的产生：由于输入信号经过不同的路径又汇合到同一个门上的竞争所引起的。**

原来一直是1,但是中间出现了0,比如上面的例子，就是**静态“1”险象**。

![image-20250619000655618](/img/image-20250619000655618.png)

**动态险象**

> 这里考察了例子，以及动态险象的概念。

​	多级组合逻辑电路，若输入信号的变化通过多条路径向输出端汇合时，输出信号稳定前会发生**三次变化**，其间经过暂时状态0、1或者1、0，这种险象称之为**动态险象**。输入信号变化的**第一次会合只可能产生静态险象**，只有在产生了静态险象，输入信号变化的再一次会合，才有可能产生动态险象。动态险象是由静态险象引起的，它也是竞争的结果。同样，在两级“与或”和“或与”电路中都不会发生。

> 也就是多个静态险象的**2次以上的会合**才会导致静态的险象---》二级电路肯定**没有动态险象**。
>
> 动态险象的变化**肯定不会只有1次**。

举个简单的例子：

**也要注意下面的这个动态的险象**

![image-20250619001114700](/img/image-20250619001114700.png)

### 险象的判别

#### 卡诺图法

用卡诺图可以判别出两级“与或电路”和两级“或与电路”是否存在静态险象。

**（1）静态 1 险象判别**

​	在两级“**与或**”电路或两级“**与非-与非**”电路中只可能出现静态 1 险象。---》本质是很多与项的相加，那么**就只能是1中间出现了0这样的情况**。

​	在**卡诺图**中，**与或式中的每个与项对应于一个卡诺圈**，如果**两个卡诺圈存在着部分“相切”**，而这个“**相切**”的部分又**没有被另外的卡诺圈所包含**，则该电路**必然存在静态 1 险象**。

举个🌰：

![image-20250620214859866](/img/image-20250620214859866.png)

与项相切的位置就会出现静态“1”险象。



**静态 0 险象判别**	

​	在两级“**或与**”电路或两级“**或非—或非**”电路中只可能出现静态 0 险象。---》**与项之间更容易出现0，就会出现静态0的险象**。

​	在卡诺图中，按照圈**0单元的卡诺圈是否存在着部分相切**，而这个**相切的部分又没有被另外的卡诺圈所包含**，则该电路必然存在静态 0 险象。

例子：那么要注意这里先取反函数，接着在画0，最后把相切的位置都要覆盖掉就没有问题了。

![image-20250620220437510](/img/image-20250620220437510.png)

#### 逻辑表达式法

**当某一变量同时以原变量和反变量的形式出现在逻辑表达式中，则该变量就具备了竞争的条件。**

比如几个典型的例子：

![image-20250620220809101](/img/image-20250620220809101.png)

你去主动选择，促使这个式子出现静态0险象。

![image-20250621205339548](/img/image-20250621205339548.png)

### 险象的消除

**增加多余项法和乘以多余因子法**

和上面消除的例子是类似的：

![image-20250621210456111](/img/image-20250621210456111.png)

**连接低通环节与增加选通脉冲**

减弱输出端的波动：

![image-20250621210716208](/img/image-20250621210716208.png)

![image-20250621210907855](/img/image-20250621210907855.png)

上面这个应该不会考察。

## 常用的MSI组合逻辑器件

### 译码器和编码器

**译码器和编码器的一般结构、二进制译码器、MSI器件及其级联与应用**

有时候要注意**使能端**的作用。

![image-20250621213046928](/img/image-20250621213046928.png)

编码器，是把**代码编的更少**，译码器，是把代码翻译出来，所以**端口会变多**。

**二进制译码器**

译码器输出最小项：

![image-20250621213327625](/img/image-20250621213327625.png)

输入一个**二进制**的数字，输出是哪一个bit的值是1。

**74LS139**

我们直接控制**输出端为0**：

注意是一个**双译码器**：

![image-20250621215315640](/img/image-20250621215315640.png)

**74LS138**

注意**这里都是控制输出端为0**的位置。注意是CAB定下来某个位置为0。

![image-20250621215621604](/img/image-20250621215621604.png)

电路图大概看一下：
![image-20250621215732453](/img/image-20250621215732453.png)

这是使用的要点：

注意**LSB**和**MSB**的含义，高有效位在下面，低有效位在上面。

![image-20250621220030345](/img/image-20250621220030345.png)

**BCD译码器74LS49**

这就是七段显示管的基本原理：







![image-20250621220228529](/img/image-20250621220228529.png)

有对应的真值表来显示某种数字：

![image-20250621220347269](/img/image-20250621220347269.png)

我们可以实现**最小项的输出（理解这里）**：

当**xyz**对应了**函数中的某个输出**的时候，我们才会输出。

> 注意是对应的位连在一起，然后使用**与非门**。（**本来的输出是非门**）

![image-20250621220857322](/img/image-20250621220857322.png)

对于一个**全加器**，是**三个输入和两个输出（输出由最小项之和来组成）**，那么这也是可以使用译码器来编程的：

![image-20250621231656964](/img/image-20250621231656964.png)

**编码器**

编码器和译码器的**逻辑就是完全相反**的。

注意**只有一个输入端是有效**的。



![image-20250622205003888](/img/image-20250622205003888.png)

我们来考察一个**8-3编码器**：

![image-20250622205223465](/img/image-20250622205223465.png)

I1 = I2 = 1的时候应该就是 0 0 1,重复？

我们关注一下这个底层逻辑：谁让这些Y成为1？

> 下标二进制对应的bit是1的I，和起来做或运算即可。

![image-20250622205432942](/img/image-20250622205432942.png)

**优先权编码器 Priority Encoders**

​	**如果同时**出现了多个**bit**是1的情况，**必定是有重复的**，因为两者的和一定在3个bit的区间之内，这是没有问题的。

我们**设置最高的为最优先**的部分。

![image-20250622210911812](/img/image-20250622210911812.png)

处理的逻辑，考察？

![image-20250622212510853](/img/image-20250622212510853.png)

**MSI优先权编码器  74LS148**

注意这里的输入和输出都是**低位有效**！---》**0才是代表有效位表达**。

![image-20250622213245716](/img/image-20250622213245716.png)

当高bit有效的时候，低bit就直接不会在进行考虑了。

### 三态门

> 可能会考察。---》概念：又被称为**三态门，可以使得多个源数据分时共享一根数据线。并且注意有三种输出的状态。**

三态门、多路收发器和双向收发器

**三态缓冲器**

比如右边的这个器件，左边连接一个译码器，就能**对于源数据端进行选通**的操作。

![image-20250622213606080](/img/image-20250622213606080.png)

**逻辑符号的表达**也很简单：

![image-20250622213702599](/img/image-20250622213702599.png)

用这个来构建三态缓冲器：

也就是等A1-A7都准备好了，当G1和G2都有效的时候，才把这些进行输出。---》起到了**缓冲**的作用。

![image-20250622230326305](/img/image-20250622230326305.png)

接下来是一个双向的缓冲器，观察一下图即可：

当DIR = 1的时候（图画错了，这个“/”在G的前面），A-B的EN端有效，所以从**A传送数据到B端**。

![image-20250622230804835](/img/image-20250622230804835.png)

### 数据分配器和多路选择器

> 考点中强调的是**多路选择器**。

数据分配器原理和MSI数据多路选择器

**数据分配器**

简单来说就是根据输入的bit，选定一个输出的通道。

![image-20250622231550355](/img/image-20250622231550355.png)

从这个角度来看，类似于**译码器**：

G作为EN端，直接决定了是否有有效的输出。

> 注意这里考察了。

![image-20250622232059176](/img/image-20250622232059176.png)

**多路选择器**

MUX：那么这个器件在**使用的逻辑上和译码器就是相反的**，从n路，每一路是Bbit的数据源中选择一路来进行输出。

n输入b位多路选择器。---》那么显然输出是Bbit。

![image-20250622232339931](/img/image-20250622232339931.png)

所以输出是怎么决定的？

比如有8组数据，s = 3bit，那么不同的组合就对应不同的组从而输出。0～n-1组中选取进行输出。

![image-20250622232956031](/img/image-20250622232956031.png)

相当于是**译码器选通了某一组数据**。

注意：下面这张图片只是说明了某一组中的某一个bit是怎么选取出来的。

![image-20250622234354970](/img/image-20250622234354970.png)





**MSI多路选择器及其扩展和应用**

就是**简单的选通**，非常好明白，注意CBA从高bit到低bit。

![image-20250624091318095](/img/image-20250624091318095.png)

总之扩展就会有很多n输入，bbit的选择器。比如：

直接根据门电路进行分析即可。

![image-20250624092313045](/img/image-20250624092313045.png)

怎么扩展？

这样的方式，高2bit通过一个2-4译码器，连接到EN来进行选择哪个器件，而低3bit选择端口输出。

![image-20250624093504339](/img/image-20250624093504339.png)

![image-20250624093635173](/img/image-20250624093635173.png)

​	具有**三态输出的多路选择器**，当其使能输入无效时，将强制输出端处于高阻抗。有三态输出端的**多路选择器的输出端可以直接连接在一起**，使得用这种器件可以方便地组成更大的多路选择器 MUX，常用的这种器件有74LS251，74LS253和74LS257等。

​	比如74LS251举例子：

输出端在EN没有打通的时候处于高阻态的状态，可以直接连接在一起。

![image-20250624094910447](/img/image-20250624094910447.png)

**采用多级MUX的树形结构**

将**多路选择器MUX分级连接**，低一级(前一级) MUX的输出作为其**高一级(后一级) MUX的数据输入**。

用选择输入信号的**低位控制低一级MUX**，**高位控制高一级MUX各级的使能输入**用同一个信号进行控制。

注意这个树形的逻辑，比如111111,前三个111,使得每个器件的D7都通，最后111选择最后一个器件，这和mod是类似的。

![image-20250624095707841](/img/image-20250624095707841.png)

**用多路选择器实现任意组合逻辑函数**

> 怪不得考察MUX，太多了。

这里的逻辑就是当我们**xyz**有对应1输出的时候，这里的选通为1。

![image-20250624100006326](/img/image-20250624100006326.png)

下面这个就是稍微有点技巧性的处理：

考前可以再看一下。可能会考察关于4选1的系列问题。

> 这里会考察，比如8选1实现一个4变量的函数。

![image-20250624100402011](/img/image-20250624100402011.png)

这里要根据卡诺图来看每个位置对应的输出是什么？

![image-20250624102614222](/img/image-20250624102614222.png)

比如D4 = w/x/y，那么图上对应右上角的01,要把这个1包括进去，那么就要和z作&运算，所以D4 = z。

分两个情况讨论：把xy的所有情况在卡诺图上遍历一遍即可。

![image-20250624103000418](/img/image-20250624103000418.png)

### 加法器和比较器

> 重点应该是adder。

**加法器**

注意**半加器和全加器的基本逻辑**：

![image-20250624105533294](/img/image-20250624105533294.png)

n位**串行加法器**：---》**行波进位**

![image-20250624110324334](/img/image-20250624110324334.png)

**超前的进位**：

特点：所有进位都是同时产生的，故电路延时时间与位数多少无关。在位数较多时其运算速度比行波加法器的要快得多。

![image-20250624111111204](/img/image-20250624111111204.png)

由两个半加器构成一个全加器：

两个半加的CO异或生成最终的CO。

![image-20250624110724380](/img/image-20250624110724380.png)

我们来看一个加法器模块：

![image-20250624111306564](/img/image-20250624111306564.png)

**BCD加法，那么当大于10的时候，我们就要进位并且进行修改：**

![image-20250624111438838](/img/image-20250624111438838.png)

![image-20250624111721238](/img/image-20250624111721238.png)

# 时序逻辑电路

​	重点：时序电路**概念**、**双稳态元件**的原理（重点是**触发器**）、**同步时序电路的分析与设计方法**、**脉冲异步时序电路分析与设计方法**、常用**时序逻辑器件**（**计数器、寄存器**）。

​	就是分析设计方法，**触发器，计数器和寄存器**的原理。

## 基础

### 时序电路概述

**逻辑电路的特性，时序电路状态**

特性:**接收输入信号**且产生与输入信号有**确定关系的**正确且**稳定**的输出信号。

状态:  用来反映电路以往输入的情况，称为电路状态。在实际电路中，以二进制的形式表示，其中的每一位都称为一个状态变量。时序电路的状态是状态变量的集合,它在任何时刻的值都包含所有的对确定电路将来行为所必需的过去信息。---》说的什么东西？看书。



**时序电路的一般结构**

一般形式：

分为一部分组合电路和存储电路，存储电路和组合电路会进行作用和反作用。

![image-20250624175332569](/img/image-20250624175332569.png)



**时序电路的分类**

① 按照**引起状态发生变化的原（诱）因**可分为：

**同步时序电路**：其状态的改变受**同一个时钟脉冲**的控制，且与时钟脉冲同步。即电路在统一时钟**CP/CLK**控制下，同步改变状态。在两个时钟脉冲中间，输入信号的变化不会改变电路状态。---》由系统的CLK同步控制电路。

**异步时序电路**：**无统一的时钟脉冲使整个系统的工作同步**，输入直接引起状态改变。---》直接由外部控制输入，也就是可以自己控制速度的感觉。

② 按输入**信号x的特性**可分为：

**同步时序电路中**，输入信号x相对时钟脉冲CP的变化速度而言，如果**输入信号x在两个时钟脉冲之间信号完成0 →1→0**(或1 →0 →1)两次变化则称为**脉冲输入同步时序电路**，**否则称为电平输入同步时序电路**。

**异步时序电路中**，输入信号x按照电路研究的目的区分：如果研究的是输入信号x完成**0 →1→0(或1 →0 →1)两次变化**对电路的影响，则称为**脉冲输入异步时序电路**，否则称为**电平输入异步时序电路**。

即：**脉冲输入**：在**两个时钟脉冲之间信号完成0 →1→0(或1 →0 →1)两次变化后**对电路的影响；**电平输入**：**信号完成一次0 →1(或1 →0) 变化**对电路的影响。

在**两个时钟信号之间**（如两个上升沿之间），我们看输入信号 `x` 的变化：

- 如果 `x` 在这段时间内是**短暂跳变**的（即从 0→1 然后马上又变回 0），这种变化我们叫它“脉冲” ⇒ **脉冲输入**
- 如果 `x` 只改变一次（如从 0 变成 1 然后就一直保持），这叫“**电平输入**”

📌 **总结一句话**：在“一个时钟周期内”，

- **快速跳变两次 ⇒ 脉冲输入**
- **只变一次或不变 ⇒ 电平输入**

如图所示：

![image-20250624180448977](/img/image-20250624180448977.png)

③ 按输出信号的特性可分为：**Mealy**型时序电路和**Moore**型时序电路。

| 项目             | **Mealy 型电路**             | **Moore 型电路**           |
| ---------------- | ---------------------------- | -------------------------- |
| **输出依赖**     | 当前状态 + **当前输入**      | **仅当前状态**             |
| **输出变化时机** | **输入变化时立即改变**       | 仅在**状态变化**时改变     |
| **输出位置**     | 接在**状态转移边（箭头）**上 | 接在状态结点（**圆圈**）内 |
| **状态数**       | 少，通常更紧凑               | 多，通常冗余些             |
| **延迟反应**     | 无（更快）                   | 有（一个周期）             |



**Mealy**型电路要考虑当前的输入，并且输入变化的时候立刻发生改变。看表即可。

![image-20250624212109553](/img/image-20250624212109553.png)

状态在边上进行改变：



```
状态A —— x=1 / y=0 ——> 状态B
           ↑
         输入决定输出
```

**Moore**型电路，状态在节点上面。

![image-20250624212117086](/img/image-20250624212117086.png)


```
[状态A] ——x=1——> [状态B]
  y=0              y=1
```

**时序电路的描述方法**

![image-20250624212749470](/img/image-20250624212749470.png)

可以看出来区别，**Mealy**的输入可以决定不同的输出，但是**Moore**型的输入就只能决定次态。

![image-20250624213314580](/img/image-20250624213314580.png)

从状态图也能看出来区别：

![image-20250624213808246](/img/image-20250624213808246.png)

### 时序电路的双稳态元件

**双稳态元件**是构成**存储电路**的基本模块，通常指**锁存器(Latch)**或**触发器(Flip-flop)** 。

双稳态元件的**特点**是：    

⑴  有**两个稳定状态**，分别表示存储数码（数字、逻辑状态） 0 或 1。  ---》为什么叫双稳态的元件。

⑵  在触发（激励）信号作用下，它可从一个**稳态翻转到另一个稳态**。

每个双稳态元件可保存**一位二进制**数，对应一个状态变量。每个双稳态元件有**两个互反（补）的输出端 Q 和 /Q**，               分别被称为：1 态 (Q = 1，/Q = 0)；0 态 (Q = 0，/Q = 1)。

**触发器或锁存器**翻转前的状态称为现态 Qn (Q)，翻转后的状态称为次态 Qn+1。

**锁存器**是利用**电平信号**控制数据的输入；        

**触发器**是利用**脉冲信号或信号的边沿**控制数据的输入。  ---》基本都是要用CLK来控制的。

**锁存器**包括：**不带使能控制的锁存器**(输入电平直接影响输出)；

带使能控制的锁存器(仅当**使能输入**有效时，其输入才直接影响输出)。

触发器包括：

**主从结构的脉冲**触发器；

**维持阻塞结构的边沿**触发器。

#### S-R 锁存器（Set-Reset Latche）

![image-20250624223805256](/img/image-20250624223805256.png)

工作原理：注意利用的是或非门。

通过R和S来进行设置。得到了**简化的次态真值表**，我们之后画卡诺图，最后得到次态方程即可。

![image-20250624224227960](/img/image-20250624224227960.png)

![image-20250624224351199](/img/image-20250624224351199.png)

#### /S - /R 锁存器(/S - /R Latche)

只是变成了**低有效的使能**，并且是**与非门**。

![image-20250624225042180](/img/image-20250624225042180.png)

![image-20250624225643351](/img/image-20250624225643351.png)

#### 带使能端的S-R 锁存器 （S-R latche with enable）

带一个看是否有效的EN端。

工作过程也是类似的，只是当C有效的时候才能正常工作。

![image-20250624225834364](/img/image-20250624225834364.png)

#### D锁存器（ D Latche）

​	 S-R 锁存器由于能够**独立地控制置位端及复位**（清除、清零）端，因此，它可应用在根据某些条件“**置位**”而在另外一些条件下“复位”的场所，但这需要置位、复位二根输入信号线。   

​	在实际工作中经常需要简单地**锁存一位二进制数**，这时应用D锁存器保存数据就更方便些。

![image-20250625131108753](/img/image-20250625131108753.png)

其实还是**S-R**锁存器，但是**简化了输入的控制**，很方便。而且还有一个**EN**。

注意要在EN**有效的时候才能进行工作**。

![image-20250625131326015](/img/image-20250625131326015.png)

![image-20250625131400256](/img/image-20250625131400256.png)

> 所以锁存器工作原理还是比较简单的。

#### 边沿触发的D触发器

​	D锁存器要求在控制(时钟)输入C （ CLK ）有效期间内，输入数据D 稳定不变。

​	这就给实际使用带来不便。因而提出了**边沿触发器**需求。边沿触发器是指，只在控制信号的**有效边沿(**前沿、后沿或称为**上升沿、下降沿**)时接收数据。

![image-20250625131638810](/img/image-20250625131638810.png)

这是什么东西？

![image-20250625132757997](/img/image-20250625132757997.png)

工作过程：

![image-20250625133041165](/img/image-20250625133041165.png)

也就是说，**CLK**是**SR**的门控信号，只有当**CLK**为高电平的时候，D的输入才会有效。

我们来分析一下上面这个电路。（考试前可以看看）

开始，当CLK为0的时候，a，b，c三条线都是1。

如果D从0变成1,那么6的输出成为0,5的输出成为1。

那么当CLK上升为1的时候，3的输出为0,4的输出为1，那么此时Q为1。也就是CLK使得Q和D同步了。

并且此时a，b两条线都变成了0，因为是与非门，相当于a封锁了4的输入，b封锁了5的输入。

那么如果这个时候，D从1变成0,虽然CLK还是1,但是这个6输出的1没有办法传到SR（被a阻塞了），Q还是保持为1。

所以**a---》置0阻塞线**（D从1变成0的时候会被阻塞） **b---》置1阻塞线 c---》置0维持线**（分析方法类似，阻塞了门6的输入）

总结一下：

![image-20250625135632843](/img/image-20250625135632843.png)

![image-20250625135800527](/img/image-20250625135800527.png)

注意**有效沿到达之前和到达之后**都应该保持一段时间：

![image-20250625141750627](/img/image-20250625141750627.png)

用verilog设计D触发器：

![image-20250625154510972](/img/image-20250625154510972.png)

#### 主从S-R 触发器（ Master/slave S-R Flip-flop）

主从触发器由**主触发器和从触发器**两部分构成。 ---》由两个SR构成   

主从触发器是在**脉冲下降沿**改变输出：    

即 ① 在触发脉冲**CLK**作用时间(**CLK为高电平期间**)，**S、R状态的变化将记入主触发器**；         

② 在**CLK下降沿时间**，从**触发器接收此时刻的主触发器状态**。

（在高电平期间记录变化，在下降沿接收状态）

这个实现也很清晰：在高电平期间，主SR有效，记录下来，接着在下降之后，后面的从SR有效，进行输出。

![image-20250625142420879](/img/image-20250625142420879.png)

那么工作的情况也是类似的：

![image-20250625142707247](/img/image-20250625142707247.png)

![image-20250625142948377](/img/image-20250625142948377.png)

#### 主从J-K 触发器（Master/slave J-K Flip-flop）

​	在**主从 S-R 触发器**的使用过程中不允许S、R信号同时有效，这给应用带来不便。J-K 触发器利用输出Q及/Q不会同时为1或0这一特性，将输入J、K先分别同/Q及Q “相与” 后再输入到主触发器的S及R输入端，从而保证主触发器的S及R端不会同时有效，见图。

就只是在主从SR的基础上面加了JK的处理，和Q和/Q做了&运算。

![image-20250625143254937](/img/image-20250625143254937.png)

当JK都是1的时候就会反转：

![image-20250625143433770](/img/image-20250625143433770.png)

根据上面的次态真值表画卡诺图：

![image-20250625144019789](/img/image-20250625144019789.png)

![image-20250625144138878](/img/image-20250625144138878.png)

​	为使触发器稳定工作，要求触发脉冲（clk）的最小宽度大于主触发器的状态转换稳定时间，即大于2个门的传输时间；时间间隔要大于4个门的传输时间。---》**因为SR中有两个门**。

#### 边沿触发J－K 触发器（Edge-triggered JK Flip-flop）

​	**边沿触发JK触发器**类似于D触发器也要求有**建立时间和保持时间**，但其建立时间较脉冲触发（主从结构）的JK 触发器为短，因此应用更为广泛。    

​	**主从结构的JK触发器**要求在时钟脉冲CLK的下降沿到来之前，输入端**J、K必须稳定较长时间**，以便输入（激励）的变化能传送到主触发器的输出QM及/QM。   



 	JK触发器常用于同步时序电路中，有时JK触发器的次态逻辑要比D触发器简单，不过大部分时序电路采用的是D触发器。这是由于**D触发器只需一个数据输入端，使得设计出的电路更加简单**。因此，在大多数可编程逻辑器件(PLD)中包含的只有 D触发器。

比如可能会考察怎么**用D触发器构成JK触发器**。---》直接由逻辑表达式画图即可。

![image-20250625152846450](/img/image-20250625152846450.png)

![image-20250625153431798](/img/image-20250625153431798.png)

![image-20250625153458523](/img/image-20250625153458523.png)

#### T触发器 T Flip-flop

![image-20250625153550190](/img/image-20250625153550190.png)

![image-20250625153647679](/img/image-20250625153647679.png)

**怎么实现？**

![image-20250625153834479](/img/image-20250625153834479.png)

用D实现的时候，简单的**将Q和T异或运算**然后输入即可。

#### 无使能控制的 T 触发器

这个实现也很简单：

![image-20250625154052203](/img/image-20250625154052203.png)

**锁存器是利用电平控制数据的输入**；    

触发器是利用**脉冲或边沿控制数据**的输入。   

锁存器包括：    

不带使能控制的锁存器(输入电平直接影响输出)；    

带使能控制的锁存器(仅当使能输入有效时，其输入才直接影响输出)。   

触发器包括：    

主从结构的脉冲触发器；    ---》主从SR 主从JK

维持阻塞结构的边沿触发器。 ---》D触发器 边沿JK触发器

## 同步时序电路的分析设计

### 同步时序电路的分析 

#### 同步时序电路分析的一般步骤 

> 过程比较复杂，我们根据具体的例子来看下。

**（1）列出激励函数及输出函数表达式**：           

a、**激励函数** = G( 输入，现态 )             

b、**Mealy**型输出函数  = F( **输入，现态** )	OR	**Moore**型输出函数 = F( **现态** )  

**（2）根据触发器的次态方程得到各个状态变量的次态方程**：               

​	次态变量 = Q( 输入，现态 )

（3）**根据状态变量的次态方程填写二进制状态表。**

（4）根据**输出函数表达式填写输出值，得到二进制状态输出表**。

（5）每一个**二进制状态分配一个字母状态名**，从而得到**字母状态输出表**。

（6）根据**状态输出表**，画出**状态图**。

（7）**电路特性描述，确定电路的逻辑功能**（很容易漏了这个分析步骤！）。---》这个电路**实际上是什么意思**？

#### 同步时序电路分析举例

举例子分析：

![image-20250625163501231](/img/image-20250625163501231.png)

**1.激励函数针对于状态存储器，确定激励函数和输出函数。**

**2.针对存储器，写出状态变量的次态方程。**

![image-20250625164246292](/img/image-20250625164246292.png)

![image-20250625170544204](/img/image-20250625170544204.png)

作二进制状态输出表。

![image-20250625170651757](/img/image-20250625170651757.png)

再举一个例子：

![image-20250625170835600](/img/image-20250625170835600.png)



分析过程手写：（**可能会出现这样的一道题目**）

![7d8def03001ec93b61cae416eeec7615](/img/7d8def03001ec93b61cae416eeec7615.jpg)





































### 同步时序电路的设计

#### 同步时序电路设计步骤

> 设计和分析的过程是相反的。

![image-20250625173052178](/img/image-20250625173052178.png)

#### 建立原始状态图和原始状态表——构图法

基本方法：

![image-20250625173452455](/img/image-20250625173452455.png)

简单例子，直接根据要求画图：

![image-20250625173911806](/img/image-20250625173911806.png)

![image-20250625174123467](/img/image-20250625174123467.png)

#### 状态化简：完全给定与不完全给定同步时序电路状态表的化简

##### 完全给定同步时序电路状态表的化简

等效的相关概念状态等效定义---》都是很字面的意思。

​	设：S1 和 S2 是完全给定时序电路 M1和  M2 ( M1和 M2可以是同一个电路)的两个状态，作为初态同时加入任意输入序列，所产生的输出序列完全一致，则状态 **S1 和 S2 是等效**(或等价)的，称 **S1和 S2 是等效对**，记为 (S1，S2)。**在同一电路中等效状态可以合并为一个状态**。

**怎么判断是否等效**

条件1： 它们的**输出完全相同**（identical outputs ）。

条件2：它们的次态满足下列条件之一：               

① **次态相同**               

② **次态交错**               

③ **次态维持**                               

④ **后续状态等效**               

⑤ **次态循环**

注意次态交错，就是相同的输入的时候，他们的**次态都是对方**。

![image-20250625174650122](/img/image-20250625174650122.png)

次态维持就是相同的输入，他们的**次态都是自己**：

![image-20250625174757628](/img/image-20250625174757628.png)

**后续等效**就是类似于一种递归的判断等效类的方法：

![image-20250625174857895](/img/image-20250625174857895.png)

这个比较抽象，就是一种循环的递归：

![image-20250625175059973](/img/image-20250625175059973.png)

那么当我们拿到一张表怎么办？

**利用隐含表进行状态化简**

![image-20250625175238345](/img/image-20250625175238345.png)

用隐含表手动操作一下这样的化简过程。

##### 接下来是不完全给定的部分：

> 注意：只有在不完全的时候我们会考虑相容类的问题。

![image-20250625181535767](/img/image-20250625181535767.png)

和前面有差异：---》相对来说比较复杂。

![image-20250625181626716](/img/image-20250625181626716.png)

![image-20250625181909496](/img/image-20250625181909496.png)

比如化简这样一个状态表：（没有给定的部分直接当作是相同的）

![image-20250625181730037](/img/image-20250625181730037.png)

分析如下：

覆盖闭合表就是找不冲突的一个过程，并且尝试覆盖所有的变量。

并且其中x = 0,以及x = 1的输出都必须在一个已经选定的相容类之中。

![5b2351ec2fc43c6cba149a5c0dca7ee2](/img/5b2351ec2fc43c6cba149a5c0dca7ee2.jpg)

#### 状态分配：相邻状态分配法

状态分配就是给最小化状态表中的每个字母状态指定（指派）一个二进制代码来表示，又称为状态编码。

我们刚才已经化简得到了状态表，现在我们要进行分配一些二进制数字。

![image-20250625202903988](/img/image-20250625202903988.png)

比如说我们来进行一种分配：

![image-20250625203058293](/img/image-20250625203058293.png)

有K个触发器，n种状态，我们怎么计算？

总共可能的总数：

![image-20250625203315721](/img/image-20250625203315721.png)

真实的数量：

![image-20250625204309057](/img/image-20250625204309057.png)

继续上面的分配，我们一共有两种方案：

**第一种方案：**

![image-20250625205236225](/img/image-20250625205236225.png)

**第二种方案：**

![image-20250625205403959](/img/image-20250625205403959.png)

明显可以看出来第二种更麻烦，那我们怎么处理？显然1都在一起的话是最好的，这样可以形成更大的卡诺圈。

**相邻状态分配法 State Assignment Rules**

​	思路：尽可能使**次态和输出函数**在卡诺图上**“1”、“0”**单元的**分布为相邻**，以便**形成较大的卡诺圈**，从而得到最简的**次态方程**（实际上是激励方程，D器件两者能统一）和输出函数表达式。

规则  I：在**相同输入条件**下，**次态相同**，**安排现态的编码相邻**。

规则 II：在**相邻输入条件**下，**同一现态**，**安排次态的编码相邻**。

规则III：**输出完全相同**，安排**现态的编码相邻**。（有利于优化输出函数）

考试之前再看一下这里。

**规则I：在相同输入条件下，次态相同，安排现态的编码相邻。**

在**同一个列**中，看有多少次**次态是相同**的，显然右边的图中，一共出现了4次是相同的情况。

让**现态**相邻。

![image-20250625210251928](/img/image-20250625210251928.png)



**规则II：在相邻的输入条件下，同一现态，安排次态的编码相邻。 ---》这里的相邻和卡诺图是类似的。**

让**次态**相邻。

![image-20250625210614959](/img/image-20250625210614959.png)

**规则III：输出完全相同，安排现态的编码相邻。**

比如这里的BC相邻的话，由于满足了一次，那么改善效果就是2 * 1 * 1 = 4

那么要注意这里p是组合数量，但是q是位数，q = 1。

**现态**相邻。

![image-20250625211217847](/img/image-20250625211217847.png)

**那么我们到底怎么分配？我曹！**

![image-20250625211648668](/img/image-20250625211648668.png)

做题：

**完成这个状态表的分配：**

K = 2 p = 2 q = 1

![image-20250625233544277](/img/image-20250625233544277.png)

![de2320dc9baa01a814d7f108f64a56db](/img/de2320dc9baa01a814d7f108f64a56db.jpg)

再把规则搞清楚一次：

**三个规则怎么计算？（这里，规则1不考虑输入为“11”的组合）**

![image-20250625234449812](/img/image-20250625234449812.png)

#### 激励函数和输出函数的确定

> 这个时候我们很不容易的把二进制状态分配出来了，我们怎么确认函数？
>
> 根据所选择的激励表直接画就可以了。

**（1）触发器类型的选择**   

触发器类型的不同将决定电路中**激励函数的繁简**。

因此，选择触发器类型的重要条件就是能使激励函数最简。   

在大多数情况下，**最常选用的是D触发器**，**其次是选用JK触发器和T触发器**。    

在非计数型的时序电路中，有时可选用SR触发器。在小规模 PLD器件中只包含D触发器。

大规模PLD中有些型号有其他触发器的。

**激励函数和输出函数的确定**

根据这个二进制状态表。

**D1 = Y1 D0 = Y0对于D触发器，直接和次态是一样的。**

![image-20250625235238821](/img/image-20250625235238821.png)

用JK实现，稍微就要看看表了：

记住JK的激励表。。。

![image-20250626000716785](/img/image-20250626000716785.png)

用T触发器，也是类似的做法。

![image-20250626083719155](/img/image-20250626083719155.png)

#### 电路分析与说明、设计举例

举一个简单的例子：

![image-20250626084051807](/img/image-20250626084051807.png)

![image-20250626084126834](/img/image-20250626084126834.png)

![image-20250626084220117](/img/image-20250626084220117.png)

**注意最终的电路图中触发器的CLK端连接CLK！！！**

![image-20250626085247382](/img/image-20250626085247382.png)

> 这块可以做上几个题目，考试应该不会考察过于复杂的情况。

## 脉冲异步时序电路的分析设计

这里注意**概念**问题：

时序电路的**分类**：**按其引起状态发生变化的原因不同**而分类。



同步时序电路受**统一的时钟脉冲信号（CLK）**控制，**工作特点**为：

（1）时钟脉冲信号**同时到达各记忆器件**，促使电路状态发生**预期改变**。---》各个触发器连接相同的CLK。

（2）只有**前一个脉冲信号引起的电路响应完全结束后，第二个脉冲信号方能到来**。（周期T=最大路径延迟时间+组合险象的消失时间。）---》两个CLK之间结束变化。

（3）**外部输入信号的变化应满足触发器正常工作所需的建立和保持时间**。这些特点简化了电路分析与设计工作。但电路的工作速度的**提高受到了限制**，且对**时钟脉冲信号到达各记忆器件的时间及外部信号的变化有较严格的要求**。



**异步时序电路的特点**：

（1）没有**统一的同步时钟脉冲**，电路状态的改变是由**外部输入信号的变化直接引起**的。---》**可以不用CLK**。

（2）按输入信号的特征分为：**脉冲型与电平型**。    

1.脉冲型：**输入是脉冲信号**，即输入信号的电平变化是**“高->低->高”或“低->高->低”**，且在输**入脉冲的一个周期内使电路状态只改变一次。所以分析与设计方法与同步时序类似。**    

差别：异步脉冲电路的特殊规定引起的（对**输入进行了限定**！）。    ---》**一个脉冲改变一次，但是对于输入的值会限定**。

2.电平型：**输入是电平信号**，即输入信号的电平变化是**“高->低”或“低->高”**，且在电平变化后的一段时间里，电路可能发生多次状态改变，最后才趋于稳定。因此，**输入与输出间存在延迟与竞争现象**，设计比较复杂。---》**只有一次电平**的变化，但是**可能会产生多次改变**。

也分为Mealy和Moore。



A.脉冲异步时序电路与同步时序电路的**相同点**是：   

（1） 存储元件都是**触发器/锁存器**。   ---》使用器件相同

（2） 状态的改变**都依赖于外部输入（脉冲）信号和电路当前状态**。 ---》都依赖与外部和当前状态

B.脉冲异步时序电路与同步时序电路的**差异**是：    

⑴ 脉冲异步时序电路**无外加的统一的时钟脉冲**。   ---》不用CLK

⑵ 输入变量为**脉冲信号**，由**输入脉冲直接引起电路的状态改变**。   

⑶ 由**次态逻辑电路产生各触发器控制输入**（**激励**）信号(Y1, Y2 , …,Yr) ,而且还产生时间有先后的各触发器的时钟控制信号(CLK1, CLK2, …,CLKr) 。？？？

C.脉冲异步时序电路输入信号的限制：

为了使电路可靠工作，电路状态变化可预知，对脉冲异步时序电路的输入信号作如下规定：   

⑴ 不允许**两根或两根以上输入线上同时有输入脉冲信号**。   

⑵ 在上一个输入脉冲信号引起的电路状态变化**未稳定以前，不允许加入新的输入脉冲信号**。

D.**脉冲异步时序电路**分析方法:

​	可将同步时序电路的分析与设计过程及工具稍作修改直接应用于脉冲异步电路。每个外部输入脉冲信号加入时，电路中所有的触发器均发生从现态到次态的转换。如果其中触发器的时钟端无时钟脉冲，则认为该触发器的次态等于现态。



分析方法修改：

脉冲异步时序电路的分析步骤基本上与同步电路一样，仅作以下修改：     

⑴  输入变量**取值为1表示有脉冲信号**，**取值为 0 表示无脉冲信号**。触发器的时钟输入端也按上述规定。     

⑵ 控制函数包括触发器的控制（激励）输入(Y1,Y2 , …,Yn)及触发器的时钟输入  (CLK1, CLK1, …,CLKr) 。     

⑶ 两个或两个以上的输入变量**不能同时为1**；输入变量全为0时，电路状态不变。---》这里要注意！

![image-20250626100432111](/img/image-20250626100432111.png)

举一个考试中考过的例子：

**用D触发器设计一个“x1–x1–x2”序列检测器（米勒型）。**

![34d6e006d55d62ccb06b4a0c5e15fc6b](/img/34d6e006d55d62ccb06b4a0c5e15fc6b.jpg)

关于CLK和D的关系一定要搞清楚，比较复杂：

> 这里也是考试的重点。

1.扩展的情况，CLK为d---》D也为d。

2.x1x2不同时为1---》CLK为d---》D也是d。

3.针对于比如y1,现态和次态之间没有变化（认为⌚没有作用），那么CLK = 0---》D = d。

4.如果发生了变化（认为⌚驱动了D触发器），那么CLK = 1---》D的值就是次态的值（和激励表是一样的）。

## 常用的时序逻辑器件

> 重点应该主要是计数器和寄存器。

### 计数器

主要类型：

无（不）规则计数器

有规则计数器：1.升计数器2.降计数器3.升降计数器

可载入（可置初值）计数器

| 计数器类型            | n 个触发器的计数模 |
| --------------------- | ------------------ |
| 普通二进制计数器      | 2^n                |
| 环形计数器（Ring）    | n                  |
| 扭环计数器（Johnson） | 2n                 |

**不规则Counter**

> 就是提前规定好数字了？

![image-20250626085827622](/img/image-20250626085827622.png)

```vhdl
architecture C1357_arch of C1357 is
begin
process (CLK,RESET,Q)
begin
    if  RESET = '1'  then 
       Q <= "001";
    elsif CLK'event and CLK = '1' then
       case Q is
          when "001"    =>    Q <= "011";
          when "011"    =>    Q <= "101";
          when "101"    =>    Q <= "111";
          when "111"    =>    Q <= "001";
          when others   =>    Q <= "001";
       end case;
    end if;
end process;
end C1357_arch; 
```

#### 设计例子

**步进码**---》4bit能表示八个数字。

0 0000

1 0001

2 0011

3 0111

4 1111

5 1110

6 1100

7 1000

![image-20250626090323548](/img/image-20250626090323548.png)

![image-20250626090944880](/img/image-20250626090944880.png)

![image-20250626091214350](/img/image-20250626091214350.png)

![image-20250626091328910](/img/image-20250626091328910.png)

![image-20250626091530692](/img/image-20250626091530692.png)

**规则计数器**

​	**有规则计数器**：指计数器的计数值以连续的方式计数，如1-2-3-4-5…或9-8-7-6-5-4….这种计数器的计数方式一般可以分成升计数器和降计数器。

例1：设计一个升计数器，其计数范围依顺序为：0-255。

```vhdl
--***************************
--*     8 Bit UP Counter    *
--*   Filename : counter8   *
--***************************  
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
entity counter8 is
    port (
          CLK:   in STD_LOGIC;
          Q:     inout STD_LOGIC_VECTOR (0 to 7);
          RESET: in STD_LOGIC
         );
end counter8;
architecture counter8_arch of counter8 is
begin
process (CLK,RESET,Q)
begin
     if RESET = '1' then
        Q <= "00000000";
     elsif CLK'event and CLK = '1' then
        Q <= Q + 1;
     end if;
end process;
end counter8_arch;
```

#### 3.4的计数器

> 还剩下整整24个小时，此时，任务主要分为三个：
> 1.计数器和寄存器的内容理解。
>
> 2.语言VHDL和Verilog。
>
> 3.大量刷题。
>
> **“不要浪费时间，但是可以休息。”**

![image-20250626165707255](/img/image-20250626165707255.png)

##### 计数器的分类及原理 

考试填空重点：

1.按照**功能**分类：**加法**计数器，**减法**计数器，**可逆**计数器（74LS169,根据UP/DN可以选择加法还是减法）

2.**进位方式**：1.**串行计数**器---》异步2.**并行计数**器---》同步

3.进位的基数：2进制 10进制 n 个触发器可以构成模 m 的计数器，其中：m ≤ $$2^n$$



###### 二进制串行计数器：

直接取反。

![image-20250626171820055](/img/image-20250626171820055.png)

![image-20250626172001148](/img/image-20250626172001148.png)

这个就比较直观了，因为只有在上升沿才发生变化。

怎么用D触发器来实现的？T触发器实现？

![image-20250626172711770](/img/image-20250626172711770.png)

**上升沿就是加法计数器，下降沿就是减法计数器（分情况）：**

注意规律：---》只要记住+1计数器并且是前沿触发的情况就可 **CLKi = /Qi-1**

![image-20250626173232900](/img/image-20250626173232900.png)

![image-20250626172843018](/img/image-20250626172843018.png)

###### 二进制同步计数器 

![image-20250626173634581](/img/image-20250626173634581.png)

这个传递关系是好理解的：

![image-20250626173802433](/img/image-20250626173802433.png)

那么减法也是类似的：

![image-20250626174012335](/img/image-20250626174012335.png)

那么用JK来实现：

![image-20250626174128638](/img/image-20250626174128638.png)



前面的所有项&起来，一起加到JK端，是否让输出反转，只有所有的值都是1的时候才会进行反转的操作。

###### 用跳越的方法实现任意模数的计数器

一般来说会有$$2^n$$但是我只想要m个：

![image-20250626174422878](/img/image-20250626174422878.png)

![image-20250626174520854](/img/image-20250626174520854.png)

处理方法：

![image-20250626174700498](/img/image-20250626174700498.png)

**强置位计数器 (Resetting)**

​	设计电路时，先设计一个二进制计数器，然后再加入强置位电路。

​	假设起跳状态为Sa，则有： 在没有出现 Sa+1 时，不影响二进制计数器的状态转换规律，强置位的逻辑电平为无效。 在出现 Sa+1时，强置位电平有效，从而对预定的某些位触发器实行预定的“强制置位”或“强制复位”。---》一拍两跳。

![image-20250626174947198](/img/image-20250626174947198.png)

分析这个例子：

其实比较简单，当输出为111的时候，Q1端PR设置为1,Q2端CLR，Q3端CLR，就可以直接从001开始。

![image-20250626175405792](/img/image-20250626175405792.png)

提前准备好就跳跃：

![image-20250626175742242](/img/image-20250626175742242.png)

![image-20250626180025686](/img/image-20250626180025686.png)

![image-20250626183259031](/img/image-20250626183259031.png)

电路图：

![image-20250626183654977](/img/image-20250626183654977.png)







##### MSI计数器及其应用

**74LS163**

![](/img/image-20250626192101149.png)

**同步计数器，并且有清零端。**

![image-20250626192250889](/img/image-20250626192250889.png)

比如怎么mod11：

> 这里会简单的考察怎么设计。

当输出为1010的时候，就给两个1与非门，然后加载回/LD和/CLR，这样就是mod11。

![image-20250626192433455](/img/image-20250626192433455.png)

这里比如我们置位设置成0101，那么当RCO进位的时候，会直接load DCBA这里的二进制数字，从而mod。

![image-20250626192626734](/img/image-20250626192626734.png)

> 注意这个余3码计数器的实现：

开始是0011,就是3,当为1100（12）的时候，开始循环。

3-12 因为余三码是减去3。

![image-20250626193244868](/img/image-20250626193244868.png)

其余类型的MSI：

![image-20250626193734240](/img/image-20250626193734240.png)

注意UP和/DN

不想看节拍分配器了。

### 寄存器

####  寄存器的分类 

**用于暂时存放二进制代码的逻辑器件称为寄存器。**

reg按照功能可以分为 **串行寄存器 并行寄存器 串并行寄存器**

**串行及串并行寄存器具有移位功能**，通常称为**移位寄存器 Shift Registers**。---》带**串行就可以移位**。

用处分类：

1.**通用**寄存器---》rax 2.**指令**寄存器---》rip 3.**地址**寄存器---》rbp（某些基址变址寄存器） 4**I/O**寄存器？



并行寄存器：总之就是暂时存放数据。

![image-20250626194821229](/img/image-20250626194821229.png)

**74LS374**

**和通用总线相连的都是三态器件。**



![image-20250626195113648](/img/image-20250626195113648.png)

在⌚信号的CLK有效沿：

![image-20250626195318141](/img/image-20250626195318141.png)



**移位寄存器 Shift Registers**

一共有四种结构：

![image-20250626195404697](/img/image-20250626195404697.png)

![image-20250626195509898](/img/image-20250626195509898.png)

![image-20250626195533757](/img/image-20250626195533757.png)

![image-20250626195642075](/img/image-20250626195642075.png)



#### MSI寄存器及其应用

**74LS194**

![image-20250626195841699](/img/image-20250626195841699.png)

### 脉冲发生器

> 没时间看了，给了。

# 可编程逻辑器件

## 概述

​	**第四章**：**SPLD、CPLD、FPGA**的基本原理（仅涉及**填空、选择、简答题**）、**VHDL**和**Verilog**（涉及**填空、简答和编程题**）。---》考察重点，时间来不及，我们大概过一下。

​	PLD：Programmable  Logic  Device 可编程逻辑器件。

​	PLD 是由半导体工厂制好，不需要为（应用）定制任何掩模，用户可以利用软件开发工具（EDA： Electronics Design Automation ）和编程器设备（也可能只是一根电缆），对芯片功能进行编程（实现具体应用）的大规模集成电路器件。

​	![image-20250626210834539](/img/image-20250626210834539.png)

分类方法：

![image-20250626211014468](/img/image-20250626211014468.png)

![image-20250626211103657](/img/image-20250626211103657.png)

记住上面的。**PLA 都可以编程，GAL和PAL输入&阵列可以编程。 ROM输出或阵列可以编程**。

**有哪些PLD：PPLD，EPPLD，EEPPLD**

![image-20250626211505043](/img/image-20250626211505043.png)



![image-20250626211559304](/img/image-20250626211559304.png)

![image-20250626211733913](/img/image-20250626211733913.png)

### 简单可编程逻辑SPLDSimple PLD



#### ROM    Read  Only  Memory

![image-20250626212234567](/img/image-20250626212234567.png)





#### PLA   Programmable  Logic Array   

![image-20250626212759861](/img/image-20250626212759861.png)





#### PAL    Programmable  Array  Logic 

![image-20250626212725867](/img/image-20250626212725867.png)



#### GAL    Generic  Logic  Array 

![image-20250626212845440](/img/image-20250626212845440.png)

> 考察。

添加了OLMC。

![image-20250626212947768](/img/image-20250626212947768.png)

#### PLC    Programmable  Logic Controller

























## Verilog

我们会随着上面的过程在这里逐渐学习Verilog的语法：

​	always @(*) begin ... end 是 **Verilog 硬件描述语言（HDL）** 中的一种语法，用于描述**组合逻辑**，是数字电路设计中非常常见的结构。

注意，块中用到的信号发生了变化，就要进行重新计算。

`always`：表示一个“过程块”，用来描述硬件行为。

`@(*)`：表示**敏感列表**，即**只要块中用到的任意信号发生变化，就重新计算执行**

`begin ... end`：表示组合逻辑块的代码段。

| 结构                    | 类型     | 是否需要时钟 | 用途                      |
| ----------------------- | -------- | ------------ | ------------------------- |
| `always @(*)`           | 组合逻辑 | 否           | 解码器、多路选择器、ALU等 |
| `always @(posedge clk)` | 时序逻辑 | 是           | 寄存器、计数器、状态机等  |



所以clk就是控制⌚的问题。

**wire和reg的区别**



| 类型                         | wire                             | reg                             |
| ---------------------------- | -------------------------------- | ------------------------------- |
| 中文名称                     | 线网类型（导线）                 | 寄存器变量                      |
| 是否具有存储功能             | ❌ 没有，值**不能保持**           | ✅ 有，**保存上一个赋值结果**    |
| 是否可以在 `always` 块中赋值 | ❌ 不可以（只能由 `assign` 赋值） | ✅ 可以（`always` 或初始块赋值） |
| 是否需要时钟                 | ❌ 不需要（组合逻辑）             | ✅ 一般用于时序逻辑（需要 clk）  |
| 默认值                       | 无                               | 初始为未知（X）                 |
| 驱动方式                     | `assign` 或其他模块输出          | `always` 或 `initial` 块中赋值  |



```
wire a;
always @(*) begin
    a = b & c;  // ❌ 错误：wire 不能在 always 中赋值
end

reg a;
assign a = b;  // ❌ 错误：reg 不能用 assign 连续赋值
```

注意上面两点的核心区别。

assign只能给wire类型赋值。

下面也可以看的很清楚区别。

![image-20250626232729482](/img/image-20250626232729482.png)

![image-20250626232214481](/img/image-20250626232214481.png)

![image-20250626233204985](/img/image-20250626233204985.png)

> 怎么写一个4bit加法器，考试考察：

```verilog
module _4Adder(a, b, cin, sum, cout);
    //端口类型定义
    input[3:0] a, b;
    input cin;
    output[3:0] sum;
    output cout;
    //数据流描述逻辑电路功能
    assign {cout,sum} = a+b+cin;
endmodule
```

![image-20250626234051607](/img/image-20250626234051607.png)









## 关于考试的信息

1.

![image-20250626155416531](/img/image-20250626155416531.png)

![image-20250626155731509](/img/image-20250626155731509.png)

2.先判断最后的符号，然后用绝对值相减。![image-20250626202612717](/img/image-20250626202612717.png)

3.纯小数，和确定机器字长的大小：

![image-20250626203029377](/img/image-20250626203029377.png)

4.注意haming校验的问题：

![image-20250626205945472](/img/image-20250626205945472.png)

5.

卡诺图中为 0 的部分表示：

> **逻辑函数在对应输入组合下的输出为 0**。

------

📌 简要说：

- **用于最小化反函数（如 SOP 的反、POS 表达式）**
- 在进行**与非实现**或**反函数化简**时，要关注为 0 的区域

------

💡补充一句（应对考试）：

> 如果你要求最小**与-或表达式（SOP）**，就圈 **为 1** 的部分；
> 如果你要求最小**或-与表达式（POS）**，就圈 **为 0** 的部分。

5.课后2.3---》考试原题。

6.易错，看起来好像是有反馈，但是并非时序电路：

![image-20250627103621803](/img/image-20250627103621803.png)

7.![image-20250627104104514](/img/image-20250627104104514.png)

考试原题。

> ​	考完，简单总结一下，10分的题没时间写了，纯空（主要是一直想上厕所有debuff），接着就是设计题还比较简单，但是考察了5变量卡诺图，并且基础概念很多，这也是我认为这个考试比较逆天的地方，有40-50分的题目都在考察概念性问题，并且第4章的占比很多，如果你追求高分，要仔细背，不过我是无所谓了。

































