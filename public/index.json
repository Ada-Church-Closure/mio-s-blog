
[{"content":"","date":"12 March 2025","externalUrl":null,"permalink":"/","section":"Mio's Tea Time","summary":"","title":"Mio's Tea Time","type":"page"},{"content":" Computer Organization # [!NOTE]\n在本篇之前，我已经实现了一个非常简单的CPU（感觉都是属于数字电路的内容，当然也是计组的一部分），课程笔记以及资源都来自于B站：Cs Primer。\n所以在这里只是简单记录一些感觉有必要的理论知识，还会不断补充。\nCache（存储器层次结构） # 1.DRAM SRAM SSD 机械硬盘读写以及存储，取内存和实际CPU之间的差异性。\n2.程序的局部性（Locality）:程序倾向于引用邻近于最近引用过的数据项或者是已经引用过的数据项本身（for遍历数组）\na.空间局部性 b.时间局部性\n引入：\n高速缓存存储器 # 1.结构 # SBE为总的大小。\n寻址原理：hash\n2.直接映射高速缓存（direct-mapped cache） # 就是每组只有一个行\n过程\na.组选择\n为什么把中间的位作为组索引而不是更高的位？\n如果高位做索引，那么很容易把一堆连续的块映射到一组高速缓存块里面，这样不符合空间局部性。\n中间的随机性相对更大一些。\nb.找到了组，进行行匹配\nc.根据块偏移位来寻找第一个字节的位置\nd.如果没有命中，从下一级内存中取相应的内存块并且直接做替换的操作\ne.实际过程：开始缓存为空，冷不命中，从L2中加载数据到L1,然后返回，接着假如标志位不相同，发生冲突不命中，进行替换操作。\nd.冲突不命中常见：thrash,高速缓存反复的加载和驱逐相同的一些组。\n3.组相联高速缓存(set associative cache) # 就是每个组包含多于一个的行\n和每个行进行一次匹配\nLFU和LRU策略\n4.全相联高速缓存（fully asscociative cache） # 就是只有一个组，里面有很多行\n没有组的选择，只有标记位和块偏移。\n单周期多周期处理器 # 一个时钟周期内完成一条指令\n多周期就是一条指令多个时钟周期\n流水线技术 # 五阶段流水线 # 把每个指令都填充成五个阶段，防止冲突\n流水线冒险 # 结构冒险：硬件资源产生冲突 # 数据冒险：逻辑上的数据依赖性产生冲突 # 控制冒险：跳转到别的指令，导致流水线之前准备的指令无效 # 解决：分支预测（动态）\n在X86系统上编写和运行程序 # 一个C程序处理流程 # 预处理-编译-汇编-链接-程序加载执行\n假设我们有文件main.c hello.c\ngcc main.c hello.c\t//这一条指令包含了上述的四个步骤 gcc -E hello.c -o hello.i //这表示对于文件进行预处理 -o是指定名称（擦除并且进行复制粘贴的流程） gcc -S hello.i -o hello.s\t//把预处理之后的文件处理成汇编代码 gcc -c hello.s -o hello.o\t//汇编成一个二进制文件，但是不进行链接的操作 工具：readelf（查看段的偏移） objdump（反汇编） hexdump（查看二进制文件的机器码）\ngcc main.o hello.o\t//直接将两个文件进行链接，如下是链接的过程 接着是程序加载执行的流程\n常见X86汇编指令 # 可以参照CSAPP熟悉基本语法，达到能读的要求即可\n[!TIP]\njmp类条件跳转指令之前可以跟其他许多指令\n比如 subl a,b 也可以看a和b之间满足的条件\n64位使用的寄存器 # 数据传送指令 # move：不能从内存直接到内存传送 # [!NOTE]\n我看过好几遍书，但是我感觉自己最难理解的地方就是函数的调用以及递归这里的东西，建议大家从push这里开始细细理解。\npush指令： # 1.把栈指针减去8,得到栈顶位置，此时栈顶还没有元素。2.把目的操作数放到栈顶。（push只要一个byte，栈上只是放了一堆data，和寄存器，和内存都没有关系）\n那么pop指令同理：1.把栈顶的值读入一个目标寄存器。2.把栈指针加8。\n条件控制 # if for while等语句都是条件跳转来实现的\nswitch语句当case范围较大时也是条件跳转，当范围较小是利用跳转表，一个连续数组的值域包含了所有的case情况(并且case的数量较多)\n*Process（过程） # 控制 + 传递 + 内存管理\n运行时栈（提前准备） # P去调用Q，首先存放返回地址，表明Q返回时从P的哪个位置开始执行，这个地址也是P栈帧的一部分。\n接着为Q分配一个栈帧，大多数的栈帧都是定长的，通过寄存器传递参数，如果大于6个，P在调用Q之前提前在自己的栈帧里存储好这些参数。\n转移控制（怎么交接控制权利） # call:把rip的值设置成callee的首地址，这样就把执行权利转换，接着把call指令下一条指令的地址压入栈中。\nret：把压入栈的地址弹出来，并且把rip的值设置成这个地址，这样就交还了控制权利。\n数据传送（怎么给Callee传递一些参数） # 在参数小于6个的情况下，我们直接用寄存器来传递，用rax来获得调用方法的返回值即可。\n在上图的Current frame中有一个Argument build area，这就是一个参数构造区，如果它也要调用一个参数多于6个的方法，那么就要提前在自己的栈帧里准备好，再执行call指令（注意：第七个参数会在栈的顶部）。\n栈上的局部存储（Callee中的局部变量是怎么实现的） # 比如局部变量太多，要取局部变量的一个地址，或者局部变量是数组及结构体等。\n还是上图，参数构造区之上就是我们减少栈指针分配给局部变量的空间。\n下例出自CSAPP\nlong swap_add (long *XP , long * yp) { long x = *xp ; long y = * yp ; *xp = y ; *yp = x ; return x + y ; } long caller () { //要处理以下两个局部变量，我就要为他们产生地址。 long argl = 534 ; long arg2 = 1057 ; long sum = swap_add (\u0026amp;argl , \u0026amp;arg2) ; long diff = argl - arg2 ; return sum * diff; } 以下是汇编代码\nlong caller() caller: subq $16 , %rsp movq $534 , (%rsp) movq $1057 , 8(%rsp) leaq 8(%rsp) , %rsi movq %rsp , %rdi call swap_add\t;这里的细节：方法虽然已经返回（返回之后之前压入的返回地址就会被弹出），但是栈帧还在，所以分配的局部变量还在 movq (%rsp) , %rdx subq 8(%rsp) ,%rdx imulq %rdx , %rax addq $16 , %rsp\t;此时栈帧不存在，会被后来的data覆盖掉 ret 栈帧分配到底拿来干嘛了？\n看下图：\n分配栈帧，先用来存放本方法要用的局部变量，接着是多于6个的参数从右至左依次压入栈中，然后call，注意，不要混淆局部变量和传递的参数，在被调用的方法中是不会用前一个方法栈帧中的局部变量的。\n寄存器中的局部存储空间 # 🔹 这些寄存器主要用于什么？ # 1. 存储局部变量 # （这也是一种存储局部变量的方法，比如在for循环中的index）\n如果一个函数有局部变量，但寄存器分配不足，编译器可能会把一些变量保存在被调用者保存寄存器里，避免频繁访问栈（比栈上的变量访问快）。\n2. 维持长期变量（Long-lived variables） # 如果某个变量在整个函数生命周期内都会被使用，而非临时数据，就可能放在 %rbx、%r12-%r15 这些寄存器里。\n3. 维护栈帧指针（%rbp） # 虽然现代编译器可能会省略栈帧指针（Frame Pointer Omission, FPO），但在调试模式下，%rbp 仍然用于保持当前函数的栈基址，帮助回溯调用栈。\n4. 传递跨函数调用的值 # 在一些情况下，如果一个值需要在多个函数调用之间保持不变，就可能存入被调用者保存寄存器，比如：\n递归函数中，某些参数可能需要跨多次递归调用保持不变。 在协程或上下文切换的代码里，某些寄存器可能存储特定的任务状态。 递归过程 # 到这里，理解递归过程就是简单的了，调用自己和调用任何一个过程都是类似的，每个函数都有自己的私有的栈帧。\n我们难理解的情况是栈帧里东西太复杂的情况。\n数组的分配和访问 # 1.指针访问，如果是地址，就用leaq加载有效地址，如果是取值就用mov指令即可。\n2.多维数组\n3.定长变长数组以及结构体\n关于缓冲区溢出问题 # C语言基础 # 关于位运算的技巧\n宏定义函数多行用\\分开，用do {\u0026hellip;\u0026hellip;} while(0)吃掉;（细节问题）\n内联函数：类似宏定义，调用的函数不跳转，直接展开，节约资源（根据编译器的情况而定)\nstatic inline int(...){......}\t//一般这样定义在头文件里使用 关于C语言不再赘述\n浮点数详解 # 浮点数存储形式 # （小数点浮动）进制转换（数字电路内容）\n[!NOTE]\nIEEE754典中典\n这里的尾数其实指的就是小数点之后的二进制表示：\n比如2.5 = 10.1b\n即 $$ 2.5 = 1.01*2^1 $$\n[!NOTE]\n这是一个规格化的浮点数，所谓规格化，我们默认一个浮点数是大于1的，即有一个隐含的前导1,我们只在尾数的23位中存储小数点的部分即可，但是如果指数部分为0,但是尾数不为0,这就是一个非规格化的浮点数，计算的规则已经发生了改变，此时的指数为1-bias，为了产生平滑的过渡。\n非规格化浮点数及舍入的问题 # 舍入：就近舍入，相同0优先\n指数部分越大，密度变小，精度就会变低\n浮点数的运算 # 先把指数设置相同，再相加这会导致大数吃掉小数的情况产生\n采用如下的累加算法\n比较问题：0.1 + 0.2 != 0.3（无限不循环小数相加导致的）\n[!NOTE]\n还有一个值得注意的点是转换类型时候的最近偶数舍入（银行家舍入），这有利于减少累积舍入的误差。\n课后作业 # 此时我们去做CSAPP的3个lab，并且把CSAPP2,3章的课后习题都解决一遍（我懒的写第二章了，我只写一下第三章的内容）\n1.datalab\n2.bomblab（gdb的使用，很有难度,我觉得可以先多看看书，做一下练习和课后习题，理解之后再去上手）\ngdb常用指令（来自https://arthals.ink/blog/bomb-lab作为参考的blog）\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 3.attacklab（模拟攻击）\n[!NOTE]\n上述工作会花费很长时间，但是欲速则不达，如果难以下手，你可以参考CSDIY上的一些推荐博客。\n链接简单解读 # Static Linking # 可以理解是怎么把你写的多文件程序整合在一起运行。\n可重定位目标文件的分析(Relocatable File) # 单个文件汇编之后，后缀为.o的文件就是一个可重定位目标文件。\n（用以下的两个程序）\nreadelf -a main.o\t//分析elf文件内容 hexdump -C main.o\t//直接查看文件的二进制信息 符号表信息 # 弱符号和强符号 # 可执行文件 # 查看可执行文件的Program Header（可执行文件是怎么被加载执行的？）\nProgram Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x001020 0x00800020 0x00800020 0x00198 0x00198 R E 0x1000 LOAD 0x002000 0x00801000 0x00801000 0x00038 0x00050 RW 0x1000 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 Section to Segment mapping: Segment Sections... 00 .text .rodata 01 .data .bss 02 静态链接的过程 # /* Simple linker script for os user-level programs. See the GNU ld \u0026#39;info\u0026#39; manual (\u0026#34;info ld\u0026#34;) to learn the syntax. */ //一个简单的linker脚本 OUTPUT_FORMAT(\u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;, \u0026#34;elf32-i386\u0026#34;)\t//输出格式 OUTPUT_ARCH(i386)\t//架构类型 ENTRY(main)\t//程序的入口点（main函数） SECTIONS { /* Load programs at this address: \u0026#34;.\u0026#34; means the current address */ //在这个地址对程序进行加载 . = 0x800020; //以下都是把每个目标文件中的相同的段合并到新的段 .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } PROVIDE(etext = .); /* Define the \u0026#39;etext\u0026#39; symbol to this value */ .rodata : { *(.rodata .rodata.* .gnu.linkonce.r.*) } /* Adjust the address for the data segment to the next page */ //转页进行存储，以上的页就可以设置成ro的一个页 . = ALIGN(0x1000); .data : { *(.data) } //记录下来，把.bss段设置成0 PROVIDE(edata = .); .bss : { *(.bss) } PROVIDE(end = .); /DISCARD/ : { *(.eh_frame .note.GNU-stack .comment) } } 重定位信息 # ","date":"10 March 2025","externalUrl":null,"permalink":"/tech/computerorgnization/","section":"Tech","summary":"","title":"ComputerOrgnization","type":"tech"},{"content":" CSAPP:BombLab # [!NOTE]\n本文主要参考博客：arthals.ink，如果你要学习方法，你只要看TA写的就可以了，我只看了前两层， 只是做个记录，我认为对于我来说很好的解决问题方式就是写注释(所以我这里有逐行的注释)。\ngdb指令：\np $rax # 打印寄存器 rax 的值 p $rsp # 打印栈指针的值 p/x $rsp # 打印栈指针的值，以十六进制显示 p/d $rsp # 打印栈指针的值，以十进制显示 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 info registers # 打印所有寄存器的值 info breakpoints # 打印所有断点的信息 delete breakpoints 1 # 删除第一个断点，可以简写为 d 1 phase1: # 比较简单，就是对比一下字符串，熟悉一下。\n00000000000015ab \u0026lt;phase_1\u0026gt;: 15ab:\tf3 0f 1e fa endbr64 15af:\t48 83 ec 08 sub $0x8,%rsp 15b3:\t48 8d 35 f2 1a 00 00 lea 0x1af2(%rip),%rsi # 这很简单，你只要查看rsi里面存放了什么东西就可以 15ba:\te8 f3 05 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; 15bf:\t85 c0 test %eax,%eax 15c1:\t75 05 jne 15c8 \u0026lt;phase_1+0x1d\u0026gt; 15c3:\t48 83 c4 08 add $0x8,%rsp 15c7:\tc3 ret 15c8:\te8 f9 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 15cd:\teb f4 jmp 15c3 \u0026lt;phase_1+0x18\u0026gt; phase2: # 先看phase_2的代码，这是典型的循环\n00000000000015cf \u0026lt;phase_2\u0026gt;: 15cf:\tf3 0f 1e fa endbr64 # 用来防止ROP攻击 15d3:\t55 push %rbp # 两个局部变量 15d4:\t53 push %rbx 15d5:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 15d9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值，用来防止恶意修改 15e0:\t00 00 15e2:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 把金丝雀值保存起来，这样被修改的时候就会提醒 15e7:\t31 c0 xor %eax,%eax # ??? 15e9:\t48 89 e6 mov %rsp,%rsi # 栈指针的值赋给了rsi 15ec:\te8 2d 07 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 调用一个读取6个数字的函数 15f1:\t83 3c 24 01 cmpl $0x1,(%rsp) # 第一个数字为1 15f5:\t75 0a jne 1601 \u0026lt;phase_2+0x32\u0026gt; 15f7:\t48 89 e3 mov %rsp,%rbx # rbx为当前栈顶的地址 15fa:\t48 8d 6c 24 14 lea 0x14(%rsp),%rbp # rbp存放rsp + 20bytes的地址 0 4 8 12 16 20刚好六个数字用栈传递 15ff:\teb 10 jmp 1611 \u0026lt;phase_2+0x42\u0026gt; # 无条件跳转1611 1601:\te8 c0 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1606:\teb ef jmp 15f7 \u0026lt;phase_2+0x28\u0026gt; 1608:\t48 83 c3 04 add $0x4,%rbx # 相等的情况下考察第二个参数的情况 160c:\t48 39 eb cmp %rbp,%rbx # 循环终止条件 160f:\t74 10 je 1621 \u0026lt;phase_2+0x52\u0026gt; 1611:\t8b 03 mov (%rbx),%eax # 取第一个参数到eax 1613:\t01 c0 add %eax,%eax # eax = eax * 2 1615:\t39 43 04 cmp %eax,0x4(%rbx) # 和第二个参数作比较 1618:\t74 ee je 1608 \u0026lt;phase_2+0x39\u0026gt; # 相等继续，不相等爆炸 161a:\te8 a7 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 161f:\teb e7 jmp 1608 \u0026lt;phase_2+0x39\u0026gt; 1621:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 1626:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 162d:\t00 00 162f:\t75 07 jne 1638 \u0026lt;phase_2+0x69\u0026gt; 1631:\t48 83 c4 28 add $0x28,%rsp 1635:\t5b pop %rbx 1636:\t5d pop %rbp 1637:\tc3 ret 1638:\te8 13 fc ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 再看它调用的读取六个数字的function\n0000000000001d1e \u0026lt;read_six_numbers\u0026gt;: 1d1e:\tf3 0f 1e fa endbr64 1d22:\t48 83 ec 08 sub $0x8,%rsp # 再分配8个字节 1d26:\t48 89 f2 mov %rsi,%rdx # 记住rsi是上一层栈顶的位置放到rdx这里 1d29:\t48 8d 4e 04 lea 0x4(%rsi),%rcx # 把这些参数用寄存器向下一个sscanf传递 1d2d:\t48 8d 46 14 lea 0x14(%rsi),%rax 1d31:\t50 push %rax 1d32:\t48 8d 46 10 lea 0x10(%rsi),%rax 1d36:\t50 push %rax 1d37:\t4c 8d 4e 0c lea 0xc(%rsi),%r9 1d3b:\t4c 8d 46 08 lea 0x8(%rsi),%r8 1d3f:\t48 8d 35 b6 15 00 00 lea 0x15b6(%rip),%rsi # 32fc \u0026lt;array.0+0x1fc\u0026gt; 这里应该是我们输入的数字 int sscanf(const char *str, const char *format, ...); 1d46:\tb8 00 00 00 00 mov $0x0,%eax # 分析一下sscanf的参数 rdi:就是我们输入的string,rsi是格式,就是\u0026#34;%d %d %d %d %d %d\u0026#34;,rdx是第一个数,rcx是第二个数,r8是第三个数,r9是第四个数,现在寄存器不够用，用栈传递参数，并且是从右向左的这就很好理解了 1d4b:\te8 b0 f5 ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; #这里要调用sscanf函数 1d50:\t48 83 c4 10 add $0x10,%rsp 1d54:\t83 f8 05 cmp $0x5,%eax 1d57:\t7e 05 jle 1d5e \u0026lt;read_six_numbers+0x40\u0026gt; 1d59:\t48 83 c4 08 add $0x8,%rsp 1d5d:\tc3 ret 1d5e:\te8 63 ff ff ff call 1cc6 \u0026lt;explode_bomb\u0026gt; phase3: # 本层就是关于一些条件的判断(大概就是switch语句)（理解提升了，之前自己肯定没办法做出来的）：\n000000000000163d \u0026lt;phase_3\u0026gt;: # 提醒是关于switch语句,不是哥们是否有些太长了 163d:\tf3 0f 1e fa endbr64 # 我们按照线性的方法先走一遍程序 1641:\t48 83 ec 28 sub $0x28,%rsp # 分配了40个字节 1645:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 164c:\t00 00 164e:\t48 89 44 24 18 mov %rax,0x18(%rsp) # 金丝雀值放在24个字节开始的位置 1653:\t31 c0 xor %eax,%eax # 检查 1655:\t48 8d 4c 24 0f lea 0xf(%rsp),%rcx # rcx = rsp + 15 占一个字节 第四个参数 a2 165a:\t48 8d 54 24 10 lea 0x10(%rsp),%rdx # rdx = rsp + 16 占四个字节 第三个参数 a1 165f:\t4c 8d 44 24 14 lea 0x14(%rsp),%r8 # r8 = rsp + 20 占四个字节 第五个参数 a3 1664:\t48 8d 35 5e 1a 00 00 lea 0x1a5e(%rip),%rsi # 30c9 \u0026lt;_IO_stdin_used+0xc9\u0026gt; 这里的rsi是\u0026#34;%d %c %d\u0026#34; 166b:\te8 90 fc ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 1670:\t83 f8 02 cmp $0x2,%eax # sscanf的返回值是读取的参数的个数,若参数小于2错 1673:\t7e 20 jle 1695 \u0026lt;phase_3+0x58\u0026gt; 1675:\t83 7c 24 10 07 cmpl $0x7,0x10(%rsp) # a1大于7就爆炸 167a:\t0f 87 0a 01 00 00 ja 178a \u0026lt;phase_3+0x14d\u0026gt; 1680:\t8b 44 24 10 mov 0x10(%rsp),%eax # rax = a1(我们先假设a1 = 6) 1684:\t48 8d 15 55 1a 00 00 lea 0x1a55(%rip),%rdx # 30e0 \u0026lt;_IO_stdin_used+0xe0\u0026gt; rdx中加载了一个-68? 168b:\t48 63 04 82 movslq (%rdx,%rax,4),%rax # rax = 4 * rax + rdx 168f:\t48 01 d0 add %rdx,%rax # rax = rax + rdx(可能是跳表位置的计算？) 1692:\t3e ff e0 notrack jmp *%rax # 其作用是 跳转到 RAX 寄存器存储的地址，并且不记录 return address 到 影子调用栈（Shadow Stack 1695:\te8 2c 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 169a:\teb d9 jmp 1675 \u0026lt;phase_3+0x38\u0026gt; 169c:\tb8 77 00 00 00 mov $0x77,%eax 16a1:\t81 7c 24 14 a8 01 00 cmpl $0x1a8,0x14(%rsp) 16a8:\t00 16a9:\t0f 84 e5 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16af:\te8 12 06 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16b4:\tb8 77 00 00 00 mov $0x77,%eax 16b9:\te9 d6 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16be:\tb8 70 00 00 00 mov $0x70,%eax 16c3:\t81 7c 24 14 bc 00 00 cmpl $0xbc,0x14(%rsp) 16ca:\t00 16cb:\t0f 84 c3 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16d1:\te8 f0 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16d6:\tb8 70 00 00 00 mov $0x70,%eax 16db:\te9 b4 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 16e0:\tb8 78 00 00 00 mov $0x78,%eax 16e5:\t81 7c 24 14 40 03 00 cmpl $0x340,0x14(%rsp) 16ec:\t00 16ed:\t0f 84 a1 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 16f3:\te8 ce 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 16f8:\tb8 78 00 00 00 mov $0x78,%eax 16fd:\te9 92 00 00 00 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1702:\tb8 6e 00 00 00 mov $0x6e,%eax 1707:\t83 7c 24 14 39 cmpl $0x39,0x14(%rsp) 170c:\t0f 84 82 00 00 00 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1712:\te8 af 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1717:\tb8 6e 00 00 00 mov $0x6e,%eax 171c:\teb 76 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 171e:\tb8 74 00 00 00 mov $0x74,%eax 1723:\t81 7c 24 14 c4 03 00 cmpl $0x3c4,0x14(%rsp) 172a:\t00 172b:\t74 67 je 1794 \u0026lt;phase_3+0x157\u0026gt; 172d:\te8 94 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1732:\tb8 74 00 00 00 mov $0x74,%eax 1737:\teb 5b jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1739:\tb8 67 00 00 00 mov $0x67,%eax 173e:\t81 7c 24 14 95 03 00 cmpl $0x395,0x14(%rsp) 1745:\t00 1746:\t74 4c je 1794 \u0026lt;phase_3+0x157\u0026gt; 1748:\te8 79 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 174d:\tb8 67 00 00 00 mov $0x67,%eax 1752:\teb 40 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 1754:\tb8 71 00 00 00 mov $0x71,%eax # a1小于7会跳转到这里 eax = 71,这里已经重新赋值了 1759:\t81 7c 24 14 f2 01 00 cmpl $0x1f2,0x14(%rsp) # 看第三个参数的值,不等于498就爆炸 1760:\t00 1761:\t74 31 je 1794 \u0026lt;phase_3+0x157\u0026gt; 1763:\te8 5e 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1768:\tb8 71 00 00 00 mov $0x71,%eax 176d:\teb 25 jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 176f:\tb8 6e 00 00 00 mov $0x6e,%eax 1774:\t81 7c 24 14 83 03 00 cmpl $0x383,0x14(%rsp) 177b:\t00 177c:\t74 16 je 1794 \u0026lt;phase_3+0x157\u0026gt; 177e:\te8 43 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1783:\tb8 6e 00 00 00 mov $0x6e,%eax 1788:\teb 0a jmp 1794 \u0026lt;phase_3+0x157\u0026gt; 178a:\te8 37 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 178f:\tb8 6e 00 00 00 mov $0x6e,%eax 1794:\t38 44 24 0f cmp %al,0xf(%rsp) # 等于498的情况下来到这里,看输入的字符和al的值是否相等，查ASCII这里应该是G 1798:\t75 15 jne 17af \u0026lt;phase_3+0x172\u0026gt; # 不相等爆炸 179a:\t48 8b 44 24 18 mov 0x18(%rsp),%rax # 第二个是q，OK结束，完全不知道具体的switch但是能做 179f:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 17a6:\t00 00 17a8:\t75 0c jne 17b6 \u0026lt;phase_3+0x179\u0026gt; 17aa:\t48 83 c4 28 add $0x28,%rsp 17ae:\tc3 ret 17af:\te8 12 05 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 17b4:\teb e4 jmp 179a \u0026lt;phase_3+0x15d\u0026gt; 17b6:\te8 95 fa ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; phase4: # 关于递归函数？\n这是phase4中调用的方法：\n00000000000017bb \u0026lt;func4\u0026gt;: # 开始的参数 edi:a1(x1) esi:0(x2) edx:14(x3) 设返回值为x 17bb:\tf3 0f 1e fa endbr64 # 这应该是一个递归函数 17bf:\t53 push %rbx # 临时变量 (temp) 17c0:\t89 d0 mov %edx,%eax # x = x3 17c2:\t29 f0 sub %esi,%eax # x -= x2 17c4:\t89 c3 mov %eax,%ebx # temp = x 17c6:\tc1 eb 1f shr $0x1f,%ebx # 这里相当于是取了temp的符号 17c9:\t01 c3 add %eax,%ebx # temp += x 17cb:\td1 fb sar %ebx # temp /= 2(这里就是默认省略了1,愚蠢) 17cd:\t01 f3 add %esi,%ebx # temp += x2 17cf:\t39 fb cmp %edi,%ebx # 比较和x1相不相等 17d1:\t7f 06 jg 17d9 \u0026lt;func4+0x1e\u0026gt; # 如果大于\u0026gt; 17d3:\t7c 10 jl 17e5 \u0026lt;func4+0x2a\u0026gt; # 如果小于\u0026lt; 17d5:\t89 d8 mov %ebx,%eax # x = temp 17d7:\t5b pop %rbx 17d8:\tc3 ret 17d9:\t8d 53 ff lea -0x1(%rbx),%edx # 大于x1的情况 x3 = temp - 1 17dc:\te8 da ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17e1:\t01 c3 add %eax,%ebx # temp += x 17e3:\teb f0 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 17e5:\t8d 73 01 lea 0x1(%rbx),%esi # 小于的情况 x1 = temp + 1 17e8:\te8 ce ff ff ff call 17bb \u0026lt;func4\u0026gt; # 递归调用 17ed:\t01 c3 add %eax,%ebx # temp += x 17ef:\teb e4 jmp 17d5 \u0026lt;func4+0x1a\u0026gt; # 返回 00000000000017f1 \u0026lt;phase_4\u0026gt;: 17f1:\tf3 0f 1e fa endbr64 17f5:\t48 83 ec 18 sub $0x18,%rsp # 分配24个字节 17f9:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1800:\t00 00 1802:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 把金丝雀值放到了stack上面 1807:\t31 c0 xor %eax,%eax 1809:\t48 8d 4c 24 04 lea 0x4(%rsp),%rcx # 栈上参数传递 第四个参数 4字节 a2 180e:\t48 89 e2 mov %rsp,%rdx # 第三个参数 4字节 a1 1811:\t48 8d 35 f0 1a 00 00 lea 0x1af0(%rip),%rsi # 参数格式：\u0026#34;%d %d\u0026#34; 1818:\te8 e3 fa ff ff call 1300 \u0026lt;__isoc99_sscanf@plt\u0026gt; 181d:\t83 f8 02 cmp $0x2,%eax # 是否读取正确 1820:\t75 06 jne 1828 \u0026lt;phase_4+0x37\u0026gt; # 不正确爆炸 1822:\t83 3c 24 0e cmpl $0xe,(%rsp) # a1 \u0026lt;= 14不然爆炸 1826:\t76 05 jbe 182d \u0026lt;phase_4+0x3c\u0026gt; 1828:\te8 99 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; # a1 \u0026lt;= 14跳到这里 这里大概是为调用f4做准备 182d:\tba 0e 00 00 00 mov $0xe,%edx # 第三个参数是14 1832:\tbe 00 00 00 00 mov $0x0,%esi # 第二个参数是0 1837:\t8b 3c 24 mov (%rsp),%edi # 第一个参数是a1 183a:\te8 7c ff ff ff call 17bb \u0026lt;func4\u0026gt; # 调用了f4,那就是说我们根据f4的逻辑来设置a1的输入 183f:\t83 f8 12 cmp $0x12,%eax # 将返回值和18作比较 1842:\t75 07 jne 184b \u0026lt;phase_4+0x5a\u0026gt; # 不相同就爆炸 1844:\t83 7c 24 04 12 cmpl $0x12,0x4(%rsp) # 把a2和18作比较 1849:\t74 05 je 1850 \u0026lt;phase_4+0x5f\u0026gt; # 不相同爆炸，相同结束 184b:\te8 76 04 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1850:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 1855:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 185c:\t00 00 185e:\t75 05 jne 1865 \u0026lt;phase_4+0x74\u0026gt; 1860:\t48 83 c4 18 add $0x18,%rsp 1864:\tc3 ret 1865:\te8 e6 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我对于fun4做了逆向：\n#include\u0026lt;stdio.h\u0026gt; //手动逆向代码fun4 int fun4(int num1, int num2, int num3){ int x = num3 - num2; int temp = x; if(temp \u0026lt; 0){ ++temp; } temp /= 2; temp += num2; if(temp \u0026gt; num1){ //要注意调用完成之后获取的rax的使用（因为这里只调用但没有获取值浪费了很长时间） return fun4(num1, num2, temp - 1) + temp; }else if(temp \u0026lt; num1){ return fun4(num1, temp + 1, num3) + temp; }else{ return temp; } } //就是给一个输入，使得返回值为0x12 int main(){ int num1; //scanf(\u0026#34;%d\u0026#34;, \u0026amp;num1); //当输入11时，答案为18,也就是answer int value = fun4(11, 0, 0xe); printf(\u0026#34;%d\\n\u0026#34;, value); } phase5: # hint：我的输入和array之间的转换关系,也不是很难\nphase5:\n000000000000186a \u0026lt;phase_5\u0026gt;: 186a:\tf3 0f 1e fa endbr64 186e:\t53 push %rbx # 一个局部变量 186f:\t48 83 ec 10 sub $0x10,%rsp # 开了16字节空间 1873:\t48 89 fb mov %rdi,%rbx # 局部变量存放rdi,rdi就是字符串的首地址 1876:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 187d:\t00 00 187f:\t48 89 44 24 08 mov %rax,0x8(%rsp) # 放在栈上，也就是说有8字节的可用空间 1884:\t31 c0 xor %eax,%eax # 校验 1886:\te8 06 03 00 00 call 1b91 \u0026lt;string_length\u0026gt; # 调用string_length,这里应该是rdi作为参数读入了一个string 188b:\t83 f8 06 cmp $0x6,%eax # 返回值和6比较，不相等爆炸，输入的字符串的长度要是6才可以 188e:\t75 55 jne 18e5 \u0026lt;phase_5+0x7b\u0026gt; 1890:\tb8 00 00 00 00 mov $0x0,%eax # eax = 0？下面大概是为strings_not_equal做准备，不相等爆炸 1895:\t48 8d 0d 64 18 00 00 lea 0x1864(%rip),%rcx # maduiersnfotvbylWow! You\u0026#39;ve defused the secret stage! 189c:\t0f b6 14 03 movzbl (%rbx,%rax,1),%edx # 就是我输入数字,从上面这个stirng中找值，构造一个rdi 18a0:\t83 e2 0f and $0xf,%edx 18a3:\t0f b6 14 11 movzbl (%rcx,%rdx,1),%edx 18a7:\t88 54 04 01 mov %dl,0x1(%rsp,%rax,1) 18ab:\t48 83 c0 01 add $0x1,%rax 18af:\t48 83 f8 06 cmp $0x6,%rax # rax就是一个index作为循环控制量 18b3:\t75 e7 jne 189c \u0026lt;phase_5+0x32\u0026gt; 18b5:\tc6 44 24 07 00 movb $0x0,0x7(%rsp) # 最后为我们构造的字符串添加了一个结束符号 18ba:\t48 8d 7c 24 01 lea 0x1(%rsp),%rdi 18bf:\t48 8d 35 0c 18 00 00 lea 0x180c(%rip),%rsi # *rsi = \u0026#34;bruins\u0026#34; 通过上面的操作，*rdi要等于\u0026#34;bruins\u0026#34;怎么操作？ 18c6:\te8 e7 02 00 00 call 1bb2 \u0026lt;strings_not_equal\u0026gt; # 意思就是两个字符串不相同就爆炸 18cb:\t85 c0 test %eax,%eax 18cd:\t75 1d jne 18ec \u0026lt;phase_5+0x82\u0026gt; 18cf:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 18d4:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 18db:\t00 00 18dd:\t75 14 jne 18f3 \u0026lt;phase_5+0x89\u0026gt; 18df:\t48 83 c4 10 add $0x10,%rsp 18e3:\t5b pop %rbx 18e4:\tc3 ret 18e5:\te8 dc 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18ea:\teb a4 jmp 1890 \u0026lt;phase_5+0x26\u0026gt; 18ec:\te8 d5 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 18f1:\teb dc jmp 18cf \u0026lt;phase_5+0x65\u0026gt; 18f3:\te8 58 f9 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 我们不必细究它调用的两个方法的具体实现了，就和函数名字一样。我输入的string是\u0026quot;M63487\u0026quot;,因为实际上会和0xf作与运算，所以每个字符都是可选的。\nphase6: # [!CAUTION]\n应该是最难的一层了，hint：链表，那就要用到结构体了吧。（做完：其实还好，只要你理解它在干什么。）\n00000000000018f8 \u0026lt;phase_6\u0026gt;: 18f8:\tf3 0f 1e fa endbr64 # 关于链表操作,最逆天的一层，孩子们 18fc:\t41 57 push %r15 # 6个局部变量,都是拿来干嘛的？？？ 18fe:\t41 56 push %r14 1900:\t41 55 push %r13 1902:\t41 54 push %r12 1904:\t55 push %rbp 1905:\t53 push %rbx 1906:\t48 83 ec 78 sub $0x78,%rsp # 分配120个bytes 190a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax # 金丝雀值 1911:\t00 00 1913:\t48 89 44 24 68 mov %rax,0x68(%rsp) # 放到栈上，有104个bytes是可用的 1918:\t31 c0 xor %eax,%eax # 检测金丝雀值 191a:\t4c 8d 74 24 10 lea 0x10(%rsp),%r14 # 此时r14存放的是rsp + 16的地址 191f:\t4c 89 74 24 08 mov %r14,0x8(%rsp) # 把rsp + 16的地址放在rsp + 8的位置 1924:\t4c 89 f6 mov %r14,%rsi # 把rsp + 16的地址作为第二个参数 1927:\te8 f2 03 00 00 call 1d1e \u0026lt;read_six_numbers\u0026gt; # 读取了六个数字 rsp + 16 20 24 28 32 36放在这六个位置 192c:\t4d 89 f4 mov %r14,%r12 # r12中放 rsp + 16的地址 192f:\t41 bf 01 00 00 00 mov $0x1,%r15d # r15 = 1 1935:\t4d 89 f5 mov %r14,%r13 # r13中放 rsp + 16的地址 1938:\te9 c6 00 00 00 jmp 1a03 \u0026lt;phase_6+0x10b\u0026gt; # 跳转 193d:\te8 84 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1942:\te9 ce 00 00 00 jmp 1a15 \u0026lt;phase_6+0x11d\u0026gt; 1947:\t48 83 c3 01 add $0x1,%rbx # rbx刚刚为1,这里就是作为一个循环控制变量 ++index（第二层循环） 194b:\t83 fb 05 cmp $0x5,%ebx # 和5比较 194e:\t0f 8f a7 00 00 00 jg 19fb \u0026lt;phase_6+0x103\u0026gt; # 如果大于5跳转 1954:\t41 8b 44 9d 00 mov 0x0(%r13,%rbx,4),%eax # r15小于5的情况：eax中存放 *(rsp + 4 * index) 1959:\t39 45 00 cmp %eax,0x0(%rbp) # 和首元素做比较 195c:\t75 e9 jne 1947 \u0026lt;phase_6+0x4f\u0026gt; # 不相等跳转，相等直接爆炸 195e:\te8 63 03 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1963:\teb e2 jmp 1947 \u0026lt;phase_6+0x4f\u0026gt; 1965:\t48 8b 54 24 08 mov 0x8(%rsp),%rdx # 至此输入检查已经结束,rdx = rsp + 16（不要想错了，这里存放的值是rsp + 16） 196a:\t48 83 c2 18 add $0x18,%rdx # rdx = rsp + 36 196e:\tb9 07 00 00 00 mov $0x7,%ecx # rcx = 7 1973:\t89 c8 mov %ecx,%eax # eax = 7 1975:\t41 2b 04 24 sub (%r12),%eax # eax为7减去数组中的元素 1979:\t41 89 04 24 mov %eax,(%r12) # 再把这个减了之后的值加载回去 197d:\t49 83 c4 04 add $0x4,%r12 # 下一个数字 1981:\t4c 39 e2 cmp %r12,%rdx # 检查终止条件 1984:\t75 ed jne 1973 \u0026lt;phase_6+0x7b\u0026gt; 1986:\tbe 00 00 00 00 mov $0x0,%esi # 现在输入的每个数字都成了它对于7的补 rsi = 0，假设输入2 6 1 5 4 3 此时的值就是 5 1 6 2 3 4 rsi = 0 198b:\t8b 4c b4 10 mov 0x10(%rsp,%rsi,4),%ecx # rcx = *(rsp + 16 + 4 * rsi) 为数组的第一个值 198f:\tb8 01 00 00 00 mov $0x1,%eax # eax = 1 1994:\t48 8d 15 75 38 00 00 lea 0x3875(%rip),%rdx # gdb查看内存这里就是把一个链表的node1的地址加载给了rdx,尝试用gdb去查看链表的具体结构，大概就是结构体{value + key + nextAddress} 199b:\t83 f9 01 cmp $0x1,%ecx # rcx处的值和1比较 199e:\t7e 0b jle 19ab \u0026lt;phase_6+0xb3\u0026gt; # 小于等于1就跳转 19a0:\t48 8b 52 08 mov 0x8(%rdx),%rdx # rdx此时应该为节点指向的节点的地址 19a4:\t83 c0 01 add $0x1,%eax # ++eax 19a7:\t39 c8 cmp %ecx,%eax # rcx和 eax比较 19a9:\t75 f5 jne 19a0 \u0026lt;phase_6+0xa8\u0026gt; # 不相等跳转，直到数组的第一个值和链表第一个节点的值相等就跳转 19ab:\t48 89 54 f4 30 mov %rdx,0x30(%rsp,%rsi,8) # *(rsp + 48 + 8 * rsi) = rdx 把这个地址存放在stack上面 19b0:\t48 83 c6 01 add $0x1,%rsi # ++rsi 19b4:\t48 83 fe 06 cmp $0x6,%rsi # 循环终止条件 19b8:\t75 d1 jne 198b \u0026lt;phase_6+0x93\u0026gt; # 不相等继续 19ba:\t48 8b 5c 24 30 mov 0x30(%rsp),%rbx # 现在我们已经把按照输入数字顺序节点指向的地址放在了栈上（人话？）rbx为第一个地址 19bf:\t48 8b 44 24 38 mov 0x38(%rsp),%rax # rax是第二个地址 19c4:\t48 89 43 08 mov %rax,0x8(%rbx) # 以下就是把链表按照我们输入的顺序连接在一起，看不明白就画图 19c8:\t48 8b 54 24 40 mov 0x40(%rsp),%rdx 19cd:\t48 89 50 08 mov %rdx,0x8(%rax) 19d1:\t48 8b 44 24 48 mov 0x48(%rsp),%rax 19d6:\t48 89 42 08 mov %rax,0x8(%rdx) 19da:\t48 8b 54 24 50 mov 0x50(%rsp),%rdx 19df:\t48 89 50 08 mov %rdx,0x8(%rax) 19e3:\t48 8b 44 24 58 mov 0x58(%rsp),%rax 19e8:\t48 89 42 08 mov %rax,0x8(%rdx) 19ec:\t48 c7 40 08 00 00 00 movq $0x0,0x8(%rax) # 0就是null节点 19f3:\t00 19f4:\tbd 05 00 00 00 mov $0x5,%ebp # rbp = 5 19f9:\teb 35 jmp 1a30 \u0026lt;phase_6+0x138\u0026gt; # 连接完了之后跳转 19fb:\t49 83 c7 01 add $0x1,%r15 # 这是应该是第一层循环 19ff:\t49 83 c6 04 add $0x4,%r14 # 下一个 1a03:\t4c 89 f5 mov %r14,%rbp # 在成功读取六个数字之后跳转到这里，rbp存放rsp + 16地址（第一次） 1a06:\t41 8b 06 mov (%r14),%eax # 读取的第一个数字 1a09:\t83 e8 01 sub $0x1,%eax # 读取的数字-1 1a0c:\t83 f8 05 cmp $0x5,%eax # 和5作比较 1a0f:\t0f 87 28 ff ff ff ja 193d \u0026lt;phase_6+0x45\u0026gt; # 大于5爆炸（这意味着不能输入大于6的数字） 1a15:\t41 83 ff 05 cmp $0x5,%r15d # r15刚刚赋值为1,现在和5作比较 1a19:\t0f 8f 46 ff ff ff jg 1965 \u0026lt;phase_6+0x6d\u0026gt; # 大于5跳转（到这里为止，经过了一个类似于冒泡排序的比较，这意味着我们输入的数字不能有重复的也不能大于6） 1a1f:\t4c 89 fb mov %r15,%rbx # rbx = 1 1a22:\te9 2d ff ff ff jmp 1954 \u0026lt;phase_6+0x5c\u0026gt; 1a27:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 1a2b:\t83 ed 01 sub $0x1,%ebp 1a2e:\t74 11 je 1a41 \u0026lt;phase_6+0x149\u0026gt;\t1a30:\t48 8b 43 08 mov 0x8(%rbx),%rax # 连接之后在这里 1a34:\t8b 00 mov (%rax),%eax 1a36:\t39 03 cmp %eax,(%rbx) 1a38:\t7d ed jge 1a27 \u0026lt;phase_6+0x12f\u0026gt;\t# 也就是说链表必须是递增还是递减的一个顺序？ 1a3a:\te8 87 02 00 00 call 1cc6 \u0026lt;explode_bomb\u0026gt; 1a3f:\teb e6 jmp 1a27 \u0026lt;phase_6+0x12f\u0026gt; 1a41:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 1a46:\t64 48 2b 04 25 28 00 sub %fs:0x28,%rax 1a4d:\t00 00 1a4f:\t75 0f jne 1a60 \u0026lt;phase_6+0x168\u0026gt; 1a51:\t48 83 c4 78 add $0x78,%rsp 1a55:\t5b pop %rbx 1a56:\t5d pop %rbp 1a57:\t41 5c pop %r12 1a59:\t41 5d pop %r13 1a5b:\t41 5e pop %r14 1a5d:\t41 5f pop %r15 1a5f:\tc3 ret 1a60:\te8 eb f7 ff ff call 1250 \u0026lt;__stack_chk_fail@plt\u0026gt; 不容易，终于写完了。\n","date":"9 March 2025","externalUrl":null,"permalink":"/tech/csappbomblab/","section":"Tech","summary":"","title":"CSAPP:BombLab","type":"tech"},{"content":" \u0026ldquo;My Heart Is In The Work.\u0026rdquo; \u0026mdash;Andrew Carnegie\n","date":"8 March 2025","externalUrl":null,"permalink":"/tech/","section":"Tech","summary":"","title":"Tech","type":"tech"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]