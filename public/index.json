
[{"content":"","date":"21 March 2025","externalUrl":null,"permalink":"/","section":"Mio's Tea Time","summary":"","title":"Mio's Tea Time","type":"page"},{"content":" \u0026ldquo;What kind of path are we walking on?\u0026rdquo;\n","date":"21 March 2025","externalUrl":null,"permalink":"/thinking/","section":"Thinking","summary":"","title":"Thinking","type":"thinking"},{"content":" 本期封面是笔者早期最喜欢的动漫角色之一，《とある科学の超電磁砲》中的长点上机学园的天才少女布束砥信，至今笔者的github头像都是她\u0026hellip;\u0026hellip;\nMySQL # 本文仅仅是笔者对于SQL语句的简单熟悉和复习的笔记，所以并不会对于更深刻的细节进行考究，也不会介绍怎么安装和配置MySQL的环境以及为什么我们要使用关系型数据库。\n1.Table # 创建表：有B格的创建一张表\n查看表结构：desc\ndelete:drop table if exists; 修改表字段\n**`alter table \u0026lt;name\u0026gt; add/change/modify \u0026lt;name\u0026gt; \u0026lt;name1\u0026gt;……`** **`alter table \u0026lt;name1\u0026gt; rename to \u0026lt;name2\u0026gt;`** delete from student; 绝对不要用这样的方式去清空一张表\n1.遍历删除，会浪费时间和资源\n2.若设置auto increment 主键，那么再加入数据的时候会从原来增长的部分继续\ntruncate table student; 直接报废表并且创建一张和原来一样的新表\n2.Data # update data:\n`update \u0026lt;tablename\u0026gt; set \u0026lt;field\u0026gt;=\u0026lt;newValue\u0026gt; where \u0026lt;field\u0026gt;=\u0026lt;value\u0026gt;;` search data from table:\n`select \u0026lt;fieldname,…\u0026gt; from \u0026lt;tablename\u0026gt;;` `select* from\u0026lt;tablename\u0026gt;` database definition language: create drop alter show\ndata manipulation language: insert delete update select\ndatabase control language: 关于数据库的角色控制？\n3.DataType # Decimal数据存储原理？\nenum枚举类型：仅能选取其中已经有的元素来存储，代表从一开始的数字\nset集合类型:能从集合中选取多个元素进行存储——用户兴趣标签\nset存储原理？？？\n4.列属性完整性(重点) # auto_increment 必须是 primarykey主键 primary key主键：唯一性—\u0026gt;一组或者一个字段 # 1.保证数据的完整性\n2.加快数据的查询速度—用来做表的关联\n`alter table \u0026lt;tablename\u0026gt; add primary key (\u0026lt;filedname\u0026gt;......);`添加主键，多个字段就是**组合键** `alter table \u0026lt;tablename\u0026gt; drop primary key;` 复合主键解决的问题\nunique唯一键\n和primary的区别：可以为null，不和其他表产生关联，但是必须唯一（null不唯一）\ndelete:`alter table \u0026lt;tablename\u0026gt; drop index \u0026lt;filedname\u0026gt;;` comment 注释问题\nSQL内注释和代码注释\n数据库的完整性问题\nForeign Key（外键约束技术） # 怎么在两张表之间建立联系？\n主表：\n建立从表：\n从表：\n`alter table \u0026lt;tablename\u0026gt; add foreign key (\u0026lt;filedname\u0026gt;) references \u0026lt;tablename\u0026gt;(\u0026lt;filedname\u0026gt;);` `show create table \u0026lt;tablename\u0026gt;;` 查看创建的表结构并且删除外键\n当主表中的数据发生变化的时候，从表中的数据应该如何修改？\n置空和级联的操作（在创建表的时候就要声明清楚） # 置空：主表中的数据被删除，那么从表中的数据依然保存，但是外键的被删除的字段为NULL；\n级联：主表中的数据发生修改，从表中的外键对应字段的数据全部发生修改；\n如图：删除——set null\n5.数据库设计思维 # a.基本概念 # 关系：两张表通过共同的字段来确立数据的完整性\n行——一条数据——实体\n列——一个字段——属性\n数据冗余：牺牲空间，提升查询性能（高考总分）\nb.实体之间的关系 # 一对多（学生表和食堂消费记录之间的关系）\n一对一\n多对一\n多对多\nc.范式 # Codd第一范式：确保字段的原子性，一个字段不可以再分 2018-2019 —— 2018 2019\nCodd第二范式：非键字段必须依赖于主键字段（无关的字段不应当加入，一张表只描述一种信息）\nCodd第三范式：消除传递依赖——根据实际情况，我们到底要不要考虑加入数据冗余的处理\n6.单表查询 # a.基本关键字 # select # from # 指定要查的表；返回两张表的笛卡尔积\ndual # 默认的一个虚拟表，单行单列\nwhere # 限制select查询条件 \u0026lt; ≤ \u0026gt; ≥ or and……\nin # 限定查询的字段的值在一个范围之内\nbetween…and… # 限制查询的范围在给定的闭区间内部\nis null # 查看是空或者非空，简单\n几种常见的聚合函数 # [!TIP]\n**Q:select count(*) and select count(1); **\nwhat’s the difference?\nlike模糊查询——通配符 # group by分组查询 # select \u0026lt;function-name\u0026gt;(\u0026lt;fieldname1\u0026gt;) as \u0026#39;alias1\u0026#39;, \u0026lt;fieldname2\u0026gt; as \u0026#39;alias2\u0026#39; group by \u0026lt;fieldname2\u0026gt;;#要根据哪个字段去查询 比如想求男性和女性的平均年龄：\n利用group_concat函数查询对应字段对应的实体\nhaving # 和where一样作为条件筛选，但是：\n1.where是根据条件对于实际存在于数据库中的数据进行筛选\n2.having对于查询之后的虚拟表使用——比如配合group_by(此时就不能使用where条件来处理)\nlimit # 选取顺序中的下标范围\nselect \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt; limit \u0026lt;start-index\u0026gt;,\u0026lt;length\u0026gt;; distinct # 去重复关键字\n默认情况下有all\nselect (all) \u0026lt;fieldname\u0026gt; from \u0026lt;tablename\u0026gt;; 至此，单表查询基础结束。\n7.多表查询 # 1.union # select… + union + DISTINCT + select… 对应字段个数必须相等\n2.join # 用两个表创建公共字段进行连接——内连接——有多张表就用多个inner进行连接\nselect f1,f2 from t1 inner join t2 on t1.f3=t2.f4 (having score \u0026gt; 90); left join 以左表为一个基准（就算左边没有也要写上去 right join 同理）\ncross join返回两张表的笛卡尔积\nselect* from t1 cross join t2; natural join自动寻找公共字段并且建立inner join的连接\n没有公共字段就返回cross join的结果\nusing\n当两张表的字段完全相同的时候，using指定建立连接的公共字段\n8.子查询 # 用一个select语句返回的数据范围作为限制的基准（用in和not in 来控制）\n只要存在就全部查询 exists and not exists\n至此，所有基础内容结束，以上的内容都是对于一名实习生来说最为重要的内容（每一种语法单独看来都是很好理解的，但是都联合起来的话就显得很困难），以下为扩展：\n扩展内容： # 1.视图(View) # 作用：简化SQL查询；掩盖敏感数据\n创建视图\n以后就可以直接查询\nalter修改视图\ndrop直接删除视图\n视图底层算法（在使用子查询创建视图的时候）\nunchecked\n1.temp table 临时表算法\n2.merge 合并算法\nQ:有什么区别？\n2.事务（Transaction） # 处理非常严谨的操作，例如转账等\n设置回滚点 并且返回—— rollback to\n事务的ACID特性\n原子：一个事务不可再分，要么全部执行，要么不执行\n隔离：多个事务同时对一个数据库进行操作，不会产生冲突\n注意：仅当engine=innodb的时候，才能使用事务\n3.index（索引） # 快速查询数据——实习生要理解到什么程度？\n4.存储过程 # 提前写好SQL一次执行，有点像函数\n利用delimiter设置结束符号\n企业规范约束 # 1.库表字段的约束规范 # 是否： is_vip unsigned tiny int length1️⃣ （不能浪费存储）\ndont’s\n不能有大写字母，\n不能以数字开头，\n下划线之间不能只有数字，\n不能出现负数，\n不能有关键字\n凡是有小数，必须用decimal数据类型\ndos\n主键：pk_key，\n字符串长度较小时，请使用char，\n强制存在的字段：\n1.id(unsigned bigint 单表的时候必须自增 primary key)\n2.create_time(datetime)\n3.update_time(datatime),\n2.索引规范 # 有某些必须：唯一索引\n不能查两个以上的关联查询\nvarchar上建立索引：建立索引的长度\n3.SQL开发约束 # count(xx,xxx,xx) count(*);\n判断为空的方法：\nwhere name = null ；\nwhere name is null；\n不要使用外键和级联（尤其是在高并发的项目中，牵一发而动全身）\n这些问题在Server层解决\n不允许使用存储过程（很难调试，其中的SQL写错了怎么办，和脚本不一样，移植性也很差）\nutf-8作为标准编码格式\n4.其他约束 # ORM框架查询不能写*\nQ:pujo类bool类型不能加is?\n","date":"12 March 2025","externalUrl":null,"permalink":"/tech/mysql/","section":"Tech","summary":"","title":"MySQL","type":"tech"},{"content":" \u0026ldquo;My Heart Is In The Work.\u0026rdquo; \u0026mdash;Andrew Carnegie\n","date":"8 March 2025","externalUrl":null,"permalink":"/tech/","section":"Tech","summary":"","title":"Tech","type":"tech"},{"content":"Computer Orgnization\n","externalUrl":null,"permalink":"/tech/computerorgnization/","section":"Tech","summary":"","title":"","type":"tech"},{"content":"attackLab\n","externalUrl":null,"permalink":"/tech/csappattacklab/","section":"Tech","summary":"","title":"","type":"tech"},{"content":"bomblab\n","externalUrl":null,"permalink":"/tech/csappbomblab/","section":"Tech","summary":"","title":"","type":"tech"},{"content":"#include \u0026lt;stdio.h\u0026gt;\nint main(void) { int sum = 0, i = 0; char input[5];\nwhile (1) { sum = 0; scanf(\u0026quot;%s\u0026quot;, input); for (i = 0; input[i] != '\\0'; i++) sum = sum*10 + input[i] - '0'; printf(\u0026quot;input=%d\\n\u0026quot;, sum); } return 0; }\n","externalUrl":null,"permalink":"/thinking/itsolving_problems/","section":"Thinking","summary":"","title":"","type":"thinking"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]