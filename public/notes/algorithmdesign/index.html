<!DOCTYPE html>
<html lang="en" dir="ltr" class="scroll-smooth" data-default-appearance="dark"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="en" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>AlgorithmDesign &middot; Mio&#39;s Tea Time</title>
  <meta name="title" content="AlgorithmDesign &middot; Mio&#39;s Tea Time" />
  
  <meta name="description" content="Mio&#39;s Tea Time" />
  
  
  
  <link rel="canonical" href="http://localhost:1313/notes/algorithmdesign/" />
  
  
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.1c9cd0d1ebaf117272b5c4f6bd49878475cb210d5e0da4f061632d779f5bb46851881c187e6e634dba5071c4e3d80e7d5cec1dd80443b2fa68acd358f9eda881.css"
    integrity="sha512-HJzQ0euvEXJytcT2vUmHhHXLIQ1eDaTwYWMtd59btGhRiBwYfm5jTbpQccTj2A59XOwd2ARDsvporNNY&#43;e2ogQ==" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.3ad74b33440334ca29f8801ec6dac1f314951cf580e503d49631816b48d1f28d03543275f92b651565b48045b90731f47595b1396214b8b6aa11c6990f867f7e.js"
    integrity="sha512-OtdLM0QDNMop&#43;IAextrB8xSVHPWA5QPUljGBa0jR8o0DVDJ1&#43;StlFWW0gEW5BzH0dZWxOWIUuLaqEcaZD4Z/fg==" data-copy="" data-copied=""></script>
  
  
  
  <script src="/lib/zoom/zoom.min.37d2094687372da3f7343a221a470f6b8806f7891aa46a5a03966af7f0ebd38b9fe536cb154e6ad28f006d184b294525a7c4054b6bbb4be62d8b453b42db99bd.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S&#43;Yti0U7QtuZvQ=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="http://localhost:1313/notes/algorithmdesign/">
  <meta property="og:site_name" content="Mio&#39;s Tea Time">
  <meta property="og:title" content="AlgorithmDesign">
  <meta property="og:description" content="算法设计与分析 # 1.课太蠢，简单写一点复习笔记
2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https://github.com/DANNHIROAKI/XJTU-CS-Courses/tree/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。
3.代码就会按照原书中来的，利用Java来实现。
4.https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/CS170/ 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2025-05-11T15:06:21+08:00">
    <meta property="article:modified_time" content="2025-05-11T15:06:21+08:00">
    <meta property="og:image" content="http://localhost:1313/notes/algorithmdesign/featured.png">

  
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/notes/algorithmdesign/featured.png">
  <meta name="twitter:title" content="AlgorithmDesign">
  <meta name="twitter:description" content="算法设计与分析 # 1.课太蠢，简单写一点复习笔记
2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https://github.com/DANNHIROAKI/XJTU-CS-Courses/tree/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。
3.代码就会按照原书中来的，利用Java来实现。
4.https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/CS170/ 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "",
    "name": "AlgorithmDesign",
    "headline": "AlgorithmDesign",
    
    "abstract": "\u003ch1 class=\u0022relative group\u0022\u003e算法设计与分析 \n    \u003cdiv id=\u0022%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\u0022 class=\u0022anchor\u0022\u003e\u003c\/div\u003e\n    \n    \u003cspan\n        class=\u0022absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\u0022\u003e\n        \u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022\n            style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\n    \u003c\/span\u003e        \n    \n\u003c\/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e1.课太蠢，简单写一点复习笔记\u003c\/p\u003e\n\u003cp\u003e2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https:\/\/github.com\/DANNHIROAKI\/XJTU-CS-Courses\/tree\/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。\u003c\/p\u003e\n\u003cp\u003e3.代码就会按照原书中来的，利用\u003cstrong\u003eJava\u003c\/strong\u003e来实现。\u003c\/p\u003e\n\u003cp\u003e4.\u003ca href=\u0022https:\/\/csdiy.wiki\/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95\/CS170\/\u0022 target=\u0022_blank\u0022\u003ehttps:\/\/csdiy.wiki\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95\/CS170\/\u003c\/a\u003e 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。\u003c\/p\u003e",
    "inLanguage": "en",
    "url" : "http:\/\/localhost:1313\/notes\/algorithmdesign\/",
    "author" : {
      "@type": "Person",
      "name": "mio"
    },
    "copyrightYear": "2025",
    "dateCreated": "2025-05-11T15:06:21\u002b08:00",
    "datePublished": "2025-05-11T15:06:21\u002b08:00",
    
    "dateModified": "2025-05-11T15:06:21\u002b08:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "7868"
  }]
  </script>


  
  
  <meta name="author" content="mio" />
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  



  
  
  <meta name="theme-color"/>
  
  
  
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script>

    const firebaseConfig = {
      apiKey: "AIzaSyCswaKAVVuCYg9UesFR0aQOkre1tVIv5co",
      authDomain: "AIzaSyCswaKAVVuCYg9UesFR0aQOkre1tVIv5co",
      projectId: "mio-s-app",
      storageBucket: "mio-s-app.firebasestorage.app",
      messagingSenderId: "491061548873",
      appId: "1:491061548873:web:9de625ab436bdfd1e3ec98",
      measurementId: "G-EH5EXVC7V4"
    };

    var app = firebase.initializeApp(firebaseConfig);
    var db = firebase.firestore();
    var auth = firebase.auth();

  </script>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3">
    
    
    
    <div>
        <a href="/" class="flex">
            <span class="sr-only">Mio&rsquo;s Tea Time</span>

            
            <img src="/img/logo.png" width="342" height="318"
                class="logo max-h-[5rem] max-w-[5rem] object-scale-down object-left nozoom" alt="Mio&#39;s Tea Time" />
            

        </a>
    </div>
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">Mio&rsquo;s Tea Time</a>
            

        </nav>
        <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">

            
            
             
  <div>
  <div class="cursor-pointer flex items-center nested-menu">
    
    <a  class="text-base font-medium text-gray-500 hover:text-primary-600 dark:hover:text-primary-400" title="">
      Class
    </a>
    <span>
      

  <span class="relative block icon">
    <svg
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 20 20"
  fill="currentColor"
  aria-hidden="true"
>
  <path
    fill-rule="evenodd"
    d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"
    clip-rule="evenodd"
  />
</svg>

  </span>


    </span>
  </div>
  <div class="absolute menuhide">
    <div class="pt-2 p-5 mt-2 rounded-xl backdrop-blur shadow-2xl">
      <div class="flex flex-col space-y-3">
        
        <a href="/notes/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
          
          <p class="text-sm font-sm" title="">
            学校课程笔记
          </p>
        </a>
        
        <a href="/csapp/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
          
          <p class="text-sm font-sm" title="">
            CS:APP
          </p>
        </a>
        
      </div>
    </div>
  </div>
</div>



            
            
  <a href="/tech/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Tech">
        Tech
    </p>
</a>



            
            
  <a href="/thinking/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Thinking">
        Thinking
    </p>
</a>



            
            
  <a href="/life/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Life">
        せいかつ
    </p>
</a>



            
            
  <a href="/author/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        Author
    </p>
</a>



            
            
  <a href="https://github.com/Ada-Church-Closure"  target="_blank"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <span >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>


    </span>
    
    <p class="text-base font-medium" title="">
        
    </p>
</a>



            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class=" flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 md:hidden">

        <label id="menu-button" class="block">
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li id="menu-close-button">
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                     
  <li class="mt-1">
    <a href="" class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            Class
        </p>
        <span>
            

  <span class="relative block icon">
    <svg
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 20 20"
  fill="currentColor"
  aria-hidden="true"
>
  <path
    fill-rule="evenodd"
    d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"
    clip-rule="evenodd"
  />
</svg>

  </span>


        </span>
    </a>
</li>

<li class="mt-1">
    <a href="/notes/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-sm font-small" title="">
            学校课程笔记
        </p>
    </a>
</li>

<li class="mt-1">
    <a href="/csapp/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-sm font-small" title="">
            CS:APP
        </p>
    </a>
</li>

<li class="mb-2"></li>




                    

                    
  <li class="mt-1">
    <a href="/tech/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Tech">
            Tech
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/thinking/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Thinking">
            Thinking
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/life/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Life">
            せいかつ
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/author/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            Author
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="https://github.com/Ada-Church-Closure"  target="_blank"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <div >
            

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>


        </div>
        
        <p class="text-bg font-bg" title="">
            
        </p>
    </a>
</li>




                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      AlgorithmDesign
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  



  



  



  







<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2025-05-11T15:06:21&#43;08:00">11 May 2025</time><span class="px-2 text-primary-500">&middot;</span><span>7868 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">37 mins</span><span class="px-2 text-primary-500">&middot;</span><span>
  
  
    
    
      
      
        
        
      
      
    
  
  <span id="views_Notes/AlgorithmDesign/index.md" class="animate-pulse inline-block text-transparent max-h-3 rounded-full mt-[-2px] align-middle bg-neutral-300 dark:bg-neutral-400" title="views">loading</span>
  <span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
<path fill="currentColor" d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg>
  </span>

</span>
</span><span class="px-2 text-primary-500">&middot;</span><span>
  
  
    
    
      
      
        
        
      
      
    
  
  <span id="likes_Notes/AlgorithmDesign/index.md"
    class="animate-pulse inline-block text-transparent max-h-3 rounded-full mt-[-2px] align-middle bg-neutral-300 dark:bg-neutral-400"
    title="likes">loading</span>
  <span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
<path fill="currentColor" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>
  </span>

</span>
</span><span class="px-2 text-primary-500">&middot;</span><span>
    <button id="button_likes"
        class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400"
        onclick="process_article()">
        <span id="button_likes_heart" style="display:none" class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
<path fill="currentColor" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>
  </span>

 </span>
        <span id="button_likes_emtpty_heart" class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
<path fill="currentColor" d="M244 84L255.1 96L267.1 84.02C300.6 51.37 347 36.51 392.6 44.1C461.5 55.58 512 115.2 512 185.1V190.9C512 232.4 494.8 272.1 464.4 300.4L283.7 469.1C276.2 476.1 266.3 480 256 480C245.7 480 235.8 476.1 228.3 469.1L47.59 300.4C17.23 272.1 0 232.4 0 190.9V185.1C0 115.2 50.52 55.58 119.4 44.1C164.1 36.51 211.4 51.37 244 84C243.1 84 244 84.01 244 84L244 84zM255.1 163.9L210.1 117.1C188.4 96.28 157.6 86.4 127.3 91.44C81.55 99.07 48 138.7 48 185.1V190.9C48 219.1 59.71 246.1 80.34 265.3L256 429.3L431.7 265.3C452.3 246.1 464 219.1 464 190.9V185.1C464 138.7 430.4 99.07 384.7 91.44C354.4 86.4 323.6 96.28 301.9 117.1L255.1 163.9z"/></svg>
  </span>

</span>
        <span id="button_likes_text">&nbsp;Like</span>
    </button>
</span>
  

  
  
</div>








    </div>

    
    
    
    
    

    

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
     <div
      class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8">
      <div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10">

         <details open id="TOCView"
  class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1算法概述">1.算法概述</a>
      <ul>
        <li><a href="#时间复杂性问题">时间复杂性问题</a></li>
        <li><a href="#np问题">NP问题</a>
          <ul>
            <li><a href="#概括">概括</a></li>
            <li><a href="#解释">解释</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2递归和分治策略">2.递归和分治策略</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#递归的求解">递归的求解</a>
          <ul>
            <li><a href="#1递归树法">1.递归树法</a></li>
            <li><a href="#2主方法">2.主方法</a></li>
          </ul>
        </li>
        <li><a href="#分治算法具体问题设计">分治算法具体问题设计</a>
          <ul>
            <li><a href="#1二分算法">1.二分算法</a></li>
            <li><a href="#2大整数乘法">2.大整数乘法</a></li>
            <li><a href="#3strassen矩阵乘法">3.Strassen矩阵乘法</a></li>
            <li><a href="#4棋盘覆盖问题">4.棋盘覆盖问题</a></li>
            <li><a href="#5合并排序merge-sort">5.合并排序（merge sort）</a></li>
            <li><a href="#6快速排序quick-sort">6.快速排序（Quick Sort）</a></li>
            <li><a href="#7线性时间选择">7.线性时间选择</a></li>
            <li><a href="#8最近点对问题">8.最近点对问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#3动态规划">3.动态规划</a>
      <ul>
        <li><a href="#基本概念和步骤">基本概念和步骤</a>
          <ul>
            <li><a href="#1与分治法的异同">1、与分治法的异同</a></li>
            <li><a href="#2动态规划的核心思想">2、动态规划的核心思想</a></li>
            <li><a href="#3解题步骤">3、解题步骤</a></li>
            <li><a href="#4基本要素">4、基本要素</a></li>
            <li><a href="#5两种基本形态">5、两种基本形态</a></li>
          </ul>
        </li>
        <li><a href="#具体问题设计">具体问题设计</a>
          <ul>
            <li><a href="#1矩阵连乘问题">1.*矩阵连乘问题</a></li>
            <li><a href="#2凸多边形最优三角剖分">2.凸多边形最优三角剖分</a></li>
            <li><a href="#3多边形游戏">3.多边形游戏</a></li>
            <li><a href="#4公园游艇问题考试难度类似">4.公园游艇问题(考试难度类似)</a></li>
            <li><a href="#5最大子段和">5.最大子段和</a></li>
            <li><a href="#6图像压缩问题没看懂">6.*图像压缩问题（没看懂）</a></li>
            <li><a href="#7最长公共子序列">7.*最长公共子序列</a></li>
            <li><a href="#8电路布线问题">8.电路布线问题</a></li>
            <li><a href="#901背包问题重要">9.01背包问题（重要）</a></li>
          </ul>
        </li>
        <li><a href="#一维dp数组滚动数组">一维dp数组（滚动数组）</a>
          <ul>
            <li><a href="#10最优二叉搜索树">10.最优二叉搜索树</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4贪心算法">4.贪心算法</a>
      <ul>
        <li>
          <ul>
            <li><a href="#1活动安排问题">1.活动安排问题</a></li>
            <li><a href="#201背包问题">2.01背包问题</a></li>
            <li><a href="#3haffman编码">3.HaffMan编码</a></li>
            <li><a href="#4dijkstra算法单源最短路径">4.Dijkstra算法&mdash;单源最短路径</a></li>
            <li><a href="#5最小生成树mst算法大意要描述">5.最小生成树MST(算法大意要描述)</a></li>
            <li><a href="#6多机调度问题">6.*多机调度问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#5回溯算法">5.回溯算法</a>
      <ul>
        <li><a href="#学习要点">学习要点</a></li>
        <li><a href="#51-回溯法的算法框架">5.1 回溯法的算法框架</a>
          <ul>
            <li><a href="#1问题的解空间">1、问题的解空间</a></li>
            <li><a href="#2回溯的基本思想">2、回溯的基本思想</a></li>
            <li><a href="#3递归回溯背诵">3、递归回溯——背诵</a></li>
            <li><a href="#4迭代回溯会填空即可">4、迭代回溯——会填空即可</a></li>
            <li><a href="#5子集树和排列树重点">5、子集树和排列树(重点)</a></li>
          </ul>
        </li>
        <li><a href="#52-装载问题">5.2 装载问题</a>
          <ul>
            <li><a href="#1问题描述-2">1、问题描述</a></li>
            <li><a href="#2算法分析">2、算法分析</a></li>
            <li><a href="#3上界函数">3、上界函数</a></li>
            <li><a href="#4构造最优解">4、构造最优解</a></li>
            <li><a href="#5迭代回溯填空即可">5、迭代回溯(填空即可)</a></li>
            <li><a href="#53-n皇后问题重点三个函数都要掌握">5.3 n皇后问题(重点,三个函数都要掌握)</a></li>
            <li><a href="#54-0-1背包问题重点">5.4 0-1背包问题(重点)</a></li>
            <li><a href="#55-图的m着色问题">5.5 图的m着色问题</a></li>
            <li><a href="#56-tsp问题旅行售货员问题一级重点">5.6 TSP问题（旅行售货员问题）【一级重点】</a></li>
            <li><a href="#57--最大团问题">5.7  最大团问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#6分支限界法">6.分支限界法</a>
      <ul>
        <li><a href="#61-分支限界法的基本思想">6.1 分支限界法的基本思想</a>
          <ul>
            <li><a href="#分支限界法和回溯法"><strong>分支限界法和回溯法</strong></a></li>
            <li><a href="#基本思想">基本思想</a></li>
          </ul>
        </li>
        <li><a href="#示例">示例</a>
          <ul>
            <li><a href="#队列式分支限界法">队列式分支限界法</a></li>
            <li><a href="#优先队列式">优先队列式</a></li>
          </ul>
        </li>
        <li><a href="#62-单源最短路径问题">6.2 单源最短路径问题</a>
          <ul>
            <li><a href="#问题描述">问题描述</a></li>
            <li><a href="#算法思想">算法思想</a></li>
            <li><a href="#实例说明">实例说明</a></li>
            <li><a href="#算法设计">算法设计</a></li>
          </ul>
        </li>
        <li><a href="#63-0-1背包问题重点">6.3 0-1背包问题[重点]</a>
          <ul>
            <li><a href="#问题描述-1">问题描述</a></li>
            <li><a href="#算法的思想">算法的思想</a></li>
            <li><a href="#步骤">步骤</a></li>
            <li><a href="#样例">样例</a></li>
            <li><a href="#核心代码">核心代码</a></li>
            <li><a href="#上界函数">上界函数</a></li>
            <li><a href="#结点定义">结点定义</a></li>
            <li><a href="#0-1背包问题优先队列分支限界搜索算法">0-1背包问题优先队列分支限界搜索算法</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#64-作业分配问题重点没看懂">6.4 作业分配问题【重点,没看懂】</a>
      <ul>
        <li>
          <ul>
            <li><a href="#1问题描述-5">1、问题描述</a></li>
            <li><a href="#2思想方法">2、思想方法</a></li>
            <li><a href="#3下界的确认">3、下界的确认</a></li>
            <li><a href="#4算法实现步骤">4、算法实现步骤</a></li>
            <li><a href="#5实现代码">5、实现代码</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#近似算法">近似算法</a>
      <ul>
        <li><a href="#顶点覆盖问题的近似算法">顶点覆盖问题的近似算法</a></li>
      </ul>
    </li>
    <li><a href="#一些题目解答">一些题目解答</a></li>
    <li><a href="#递归分治1">递归分治1</a></li>
    <li><a href="#递归分治2">递归分治2</a></li>
    <li><a href="#递归分治3">递归分治3</a></li>
    <li><a href="#动态规划1">动态规划1</a></li>
    <li><a href="#动态规划2">动态规划2</a></li>
    <li><a href="#动态规划3">动态规划3</a></li>
    <li><a href="#动态规划4">动态规划4</a></li>
    <li><a href="#动态规划5">动态规划5</a></li>
    <li><a href="#动态规划6">动态规划6</a></li>
    <li><a href="#贪心算法1">贪心算法1</a></li>
    <li><a href="#贪心算法2">贪心算法2</a></li>
    <li><a href="#贪心算法3">贪心算法3</a></li>
    <li><a href="#回溯法1">回溯法1</a></li>
    <li><a href="#回溯法2">回溯法2</a></li>
    <li><a href="#回溯法3">回溯法3</a></li>
    <li><a href="#回溯法4">回溯法4</a></li>
    <li><a href="#回溯法5递归回溯">回溯法5(递归回溯)</a></li>
    <li><a href="#np1">NP1</a></li>
    <li><a href="#np2">NP2</a></li>
    <li><a href="#np3">NP3</a></li>
    <li><a href="#np4">NP4</a></li>
    <li><a href="#算法导论">算法导论</a></li>
    <li><a href="#递归分治">递归分治</a></li>
    <li><a href="#贪心">贪心</a></li>
    <li><a href="#dp">DP</a></li>
    <li><a href="#回溯算法">回溯算法</a></li>
    <li><a href="#分支限界">分支限界</a></li>
    <li><a href="#概念题目">概念题目</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1算法概述">1.算法概述</a>
      <ul>
        <li><a href="#时间复杂性问题">时间复杂性问题</a></li>
        <li><a href="#np问题">NP问题</a>
          <ul>
            <li><a href="#概括">概括</a></li>
            <li><a href="#解释">解释</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2递归和分治策略">2.递归和分治策略</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#递归的求解">递归的求解</a>
          <ul>
            <li><a href="#1递归树法">1.递归树法</a></li>
            <li><a href="#2主方法">2.主方法</a></li>
          </ul>
        </li>
        <li><a href="#分治算法具体问题设计">分治算法具体问题设计</a>
          <ul>
            <li><a href="#1二分算法">1.二分算法</a></li>
            <li><a href="#2大整数乘法">2.大整数乘法</a></li>
            <li><a href="#3strassen矩阵乘法">3.Strassen矩阵乘法</a></li>
            <li><a href="#4棋盘覆盖问题">4.棋盘覆盖问题</a></li>
            <li><a href="#5合并排序merge-sort">5.合并排序（merge sort）</a></li>
            <li><a href="#6快速排序quick-sort">6.快速排序（Quick Sort）</a></li>
            <li><a href="#7线性时间选择">7.线性时间选择</a></li>
            <li><a href="#8最近点对问题">8.最近点对问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#3动态规划">3.动态规划</a>
      <ul>
        <li><a href="#基本概念和步骤">基本概念和步骤</a>
          <ul>
            <li><a href="#1与分治法的异同">1、与分治法的异同</a></li>
            <li><a href="#2动态规划的核心思想">2、动态规划的核心思想</a></li>
            <li><a href="#3解题步骤">3、解题步骤</a></li>
            <li><a href="#4基本要素">4、基本要素</a></li>
            <li><a href="#5两种基本形态">5、两种基本形态</a></li>
          </ul>
        </li>
        <li><a href="#具体问题设计">具体问题设计</a>
          <ul>
            <li><a href="#1矩阵连乘问题">1.*矩阵连乘问题</a></li>
            <li><a href="#2凸多边形最优三角剖分">2.凸多边形最优三角剖分</a></li>
            <li><a href="#3多边形游戏">3.多边形游戏</a></li>
            <li><a href="#4公园游艇问题考试难度类似">4.公园游艇问题(考试难度类似)</a></li>
            <li><a href="#5最大子段和">5.最大子段和</a></li>
            <li><a href="#6图像压缩问题没看懂">6.*图像压缩问题（没看懂）</a></li>
            <li><a href="#7最长公共子序列">7.*最长公共子序列</a></li>
            <li><a href="#8电路布线问题">8.电路布线问题</a></li>
            <li><a href="#901背包问题重要">9.01背包问题（重要）</a></li>
          </ul>
        </li>
        <li><a href="#一维dp数组滚动数组">一维dp数组（滚动数组）</a>
          <ul>
            <li><a href="#10最优二叉搜索树">10.最优二叉搜索树</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4贪心算法">4.贪心算法</a>
      <ul>
        <li>
          <ul>
            <li><a href="#1活动安排问题">1.活动安排问题</a></li>
            <li><a href="#201背包问题">2.01背包问题</a></li>
            <li><a href="#3haffman编码">3.HaffMan编码</a></li>
            <li><a href="#4dijkstra算法单源最短路径">4.Dijkstra算法&mdash;单源最短路径</a></li>
            <li><a href="#5最小生成树mst算法大意要描述">5.最小生成树MST(算法大意要描述)</a></li>
            <li><a href="#6多机调度问题">6.*多机调度问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#5回溯算法">5.回溯算法</a>
      <ul>
        <li><a href="#学习要点">学习要点</a></li>
        <li><a href="#51-回溯法的算法框架">5.1 回溯法的算法框架</a>
          <ul>
            <li><a href="#1问题的解空间">1、问题的解空间</a></li>
            <li><a href="#2回溯的基本思想">2、回溯的基本思想</a></li>
            <li><a href="#3递归回溯背诵">3、递归回溯——背诵</a></li>
            <li><a href="#4迭代回溯会填空即可">4、迭代回溯——会填空即可</a></li>
            <li><a href="#5子集树和排列树重点">5、子集树和排列树(重点)</a></li>
          </ul>
        </li>
        <li><a href="#52-装载问题">5.2 装载问题</a>
          <ul>
            <li><a href="#1问题描述-2">1、问题描述</a></li>
            <li><a href="#2算法分析">2、算法分析</a></li>
            <li><a href="#3上界函数">3、上界函数</a></li>
            <li><a href="#4构造最优解">4、构造最优解</a></li>
            <li><a href="#5迭代回溯填空即可">5、迭代回溯(填空即可)</a></li>
            <li><a href="#53-n皇后问题重点三个函数都要掌握">5.3 n皇后问题(重点,三个函数都要掌握)</a></li>
            <li><a href="#54-0-1背包问题重点">5.4 0-1背包问题(重点)</a></li>
            <li><a href="#55-图的m着色问题">5.5 图的m着色问题</a></li>
            <li><a href="#56-tsp问题旅行售货员问题一级重点">5.6 TSP问题（旅行售货员问题）【一级重点】</a></li>
            <li><a href="#57--最大团问题">5.7  最大团问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#6分支限界法">6.分支限界法</a>
      <ul>
        <li><a href="#61-分支限界法的基本思想">6.1 分支限界法的基本思想</a>
          <ul>
            <li><a href="#分支限界法和回溯法"><strong>分支限界法和回溯法</strong></a></li>
            <li><a href="#基本思想">基本思想</a></li>
          </ul>
        </li>
        <li><a href="#示例">示例</a>
          <ul>
            <li><a href="#队列式分支限界法">队列式分支限界法</a></li>
            <li><a href="#优先队列式">优先队列式</a></li>
          </ul>
        </li>
        <li><a href="#62-单源最短路径问题">6.2 单源最短路径问题</a>
          <ul>
            <li><a href="#问题描述">问题描述</a></li>
            <li><a href="#算法思想">算法思想</a></li>
            <li><a href="#实例说明">实例说明</a></li>
            <li><a href="#算法设计">算法设计</a></li>
          </ul>
        </li>
        <li><a href="#63-0-1背包问题重点">6.3 0-1背包问题[重点]</a>
          <ul>
            <li><a href="#问题描述-1">问题描述</a></li>
            <li><a href="#算法的思想">算法的思想</a></li>
            <li><a href="#步骤">步骤</a></li>
            <li><a href="#样例">样例</a></li>
            <li><a href="#核心代码">核心代码</a></li>
            <li><a href="#上界函数">上界函数</a></li>
            <li><a href="#结点定义">结点定义</a></li>
            <li><a href="#0-1背包问题优先队列分支限界搜索算法">0-1背包问题优先队列分支限界搜索算法</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#64-作业分配问题重点没看懂">6.4 作业分配问题【重点,没看懂】</a>
      <ul>
        <li>
          <ul>
            <li><a href="#1问题描述-5">1、问题描述</a></li>
            <li><a href="#2思想方法">2、思想方法</a></li>
            <li><a href="#3下界的确认">3、下界的确认</a></li>
            <li><a href="#4算法实现步骤">4、算法实现步骤</a></li>
            <li><a href="#5实现代码">5、实现代码</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#近似算法">近似算法</a>
      <ul>
        <li><a href="#顶点覆盖问题的近似算法">顶点覆盖问题的近似算法</a></li>
      </ul>
    </li>
    <li><a href="#一些题目解答">一些题目解答</a></li>
    <li><a href="#递归分治1">递归分治1</a></li>
    <li><a href="#递归分治2">递归分治2</a></li>
    <li><a href="#递归分治3">递归分治3</a></li>
    <li><a href="#动态规划1">动态规划1</a></li>
    <li><a href="#动态规划2">动态规划2</a></li>
    <li><a href="#动态规划3">动态规划3</a></li>
    <li><a href="#动态规划4">动态规划4</a></li>
    <li><a href="#动态规划5">动态规划5</a></li>
    <li><a href="#动态规划6">动态规划6</a></li>
    <li><a href="#贪心算法1">贪心算法1</a></li>
    <li><a href="#贪心算法2">贪心算法2</a></li>
    <li><a href="#贪心算法3">贪心算法3</a></li>
    <li><a href="#回溯法1">回溯法1</a></li>
    <li><a href="#回溯法2">回溯法2</a></li>
    <li><a href="#回溯法3">回溯法3</a></li>
    <li><a href="#回溯法4">回溯法4</a></li>
    <li><a href="#回溯法5递归回溯">回溯法5(递归回溯)</a></li>
    <li><a href="#np1">NP1</a></li>
    <li><a href="#np2">NP2</a></li>
    <li><a href="#np3">NP3</a></li>
    <li><a href="#np4">NP4</a></li>
    <li><a href="#算法导论">算法导论</a></li>
    <li><a href="#递归分治">递归分治</a></li>
    <li><a href="#贪心">贪心</a></li>
    <li><a href="#dp">DP</a></li>
    <li><a href="#回溯算法">回溯算法</a></li>
    <li><a href="#分支限界">分支限界</a></li>
    <li><a href="#概念题目">概念题目</a></li>
  </ul>
</nav>
  </div>
</details>

<script>

  var margin = 200;
  var marginError = 50;

  (function () {
    var $window = $(window);
    var $toc = $('#TOCView');
    var tocHeight = $toc.height();

    function onResize() {
      var windowAndMarginHeight = $window.height() - margin;
      if(tocHeight >= windowAndMarginHeight) {
        $toc.css("overflow-y", "scroll")
        $toc.css("max-height", (windowAndMarginHeight + marginError) + "px")
      } else {
        $toc.css("overflow-y", "hidden")
        $toc.css("max-height", "9999999px")
      }
    }

    $window.on('resize', onResize);
    $(document).ready(onResize);
  })();



</script>
   </div>
      </div>
      

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h1 class="relative group">算法设计与分析 
    <div id="%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<blockquote>
<p>1.课太蠢，简单写一点复习笔记</p>
<p>2.大量的数学笔记都是我复制下来的，我没有手打这么多公式的耐心，只能感谢那名陌生的同学了,原来的仓库https://github.com/DANNHIROAKI/XJTU-CS-Courses/tree/master,可能这篇文章的阅读体验相对会更好一点，因为数学公式会直接渲染并且我会多余做一些补充和更改，如果原作者看到并且觉得这样不好，您可以直接联系我删除。</p>
<p>3.代码就会按照原书中来的，利用<strong>Java</strong>来实现。</p>
<p>4.<a href="https://csdiy.wiki/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95/CS170/" target="_blank">https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/CS170/</a> 笔者非常后悔在学校老师狂念PPT的时候没有自学这个CS170,如果你还有机会，一定要看一看。</p>
<p>5.关于本课程你理论上能找到两套往年题目，有参考价值，模拟题目参考价值较少，本课程从选修变成必修之后难度应当有所降低，不管你的老师怎么样，考试之前的复习课一定去听，<strong>会透露原题</strong>。</p></blockquote>


<h2 class="relative group">1.算法概述 
    <div id="1%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>算法的执行次数和时间都有限。程序不一定，因为有可能有while(true)。</p>


<h3 class="relative group">时间复杂性问题 
    <div id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>O omu o theta</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250423155916596.png?lastModify=1746948169" alt="image-20250423155916596" />
      
    </figure>
</p>
<p>举例子：</p>
<p>f = O(g)</p>
<p>g是f的一个上界，f &lt;= g</p>
<p>omu: &gt;=</p>
<p>o: &lt;</p>
<p>theta: = (既是O 又是omu)</p>
<p>omega: &gt;</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5459784d5449324d5463304e6a45304d6a45343f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67.png?lastModify=1746948169" alt="https://camo.githubusercontent.com/a2f8f6321c885c9b6bd322369beecebf9dce2cb182066b68264fdf64475e2156/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5459784d5449324d5463304e6a45304d6a45343f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67" />
      
    </figure>
</p>
<p><strong>n的阶乘</strong></p>
<p>Stirling’s approximation 是对n !趋于无穷速度的估计，公式如下</p>
<p>𝑛!=2𝜋𝑛(𝑛𝑒𝑛)(1+Θ(1𝑛))</p>
<p>可推导：</p>
<p>𝑛!=𝑜(𝑛𝑛)  𝑛!=𝜔(2𝑛)  log⁡(𝑛!)=Θ(𝑛log⁡𝑛)</p>
<p>课后题证明以及上下界的练习。</p>
<p>渐进分析的算术运算与证明</p>
<blockquote>
<p>应该不难，想办法凑就可以。</p></blockquote>
<p>常用公式：</p>
<blockquote>
<p>•<em>O</em>(<em>f</em>(<em>n</em>))+<em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(max{<em>f</em>(n),<em>g</em>(<em>n</em>)}) ；</p>
<p>•<em>O</em>(<em>f</em>(<em>n</em>))+<em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(<em>f</em>(n)+<em>g</em>(<em>n</em>)) ；</p>
<p>•<em>O</em>(<em>f</em>(<em>n</em>))<em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(<em>f</em>(n)*<em>g</em>(<em>n</em>)) ；</p>
<p>•<em>O</em>(<em>cf</em>(<em>n</em>)) = <em>O</em>(<em>f</em>(n)) ；</p>
<p>•<em>g</em>(<em>n</em>)= <em>O</em>(<em>f</em>(<em>n</em>))   ⇒ <em>O</em>(<em>f</em>(<em>n</em>))+<em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(<em>f</em>(n))</p></blockquote>
<p>证明示例：以第一个公式举例</p>
<blockquote>
<p>•规则<em>O</em>(<em>f</em>(<em>n</em>)) + <em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(max{<em>f</em>(n),<em>g</em>(<em>n</em>)}) 的<strong>证明：</strong></p>
<p>•对于任意<em>f</em>1(<em>n</em>)∈ <em>O</em>(<em>f</em>(<em>n</em>)) ，存在正常数<em>c</em>1和自然数<em>n</em>1，使得对所有<em>n</em>  ≥ <em>n</em>1，有<em>f</em>1(<em>n</em>)≤<em>c</em>1<em>f</em>(<em>n</em>) 。</p>
<p>•类似地，对于任意<em>g</em>1(<em>n</em>)∈  <em>O</em>(<em>g</em>(<em>n</em>)) ，存在正常数<em>c</em>2和自然数<em>n</em>2，使得对所有<em>n</em>  ≥ <em>n</em>2，有<em>g</em>1(<em>n</em>)   ≤ <em>c</em>2<em>g</em>(<em>n</em>) 。</p>
<p>•令<em>c</em>3=max{<em>c</em>1, <em>c</em>2}， <em>n</em>3 =max{<em>n</em>1, <em>n</em>2}，<em>h</em>(<em>n</em>)= max{<em>f</em>(n),<em>g</em>(<em>n</em>)} 。</p>
<p>•则对所有的 <em>n</em>  ≥ <em>n</em>3，有</p>
<p>•<em>f</em>1(<em>n</em>) +<em>g</em>1(<em>n</em>)   ≤ <em>c</em>1<em>f</em>(<em>n</em>) + <em>c</em>2<em>g</em>(<em>n</em>)</p>
<p>≤ <em>c</em>3<em>f</em>(<em>n</em>) + <em>c</em>3<em>g</em>(<em>n</em>)= <em>c</em>3(<em>f</em>(<em>n</em>) + <em>g</em>(<em>n</em>))</p>
<p>≤ <em>c</em>3×2 max{<em>f</em>(n),<em>g</em>(<em>n</em>)}</p>
<p>= 2<em>c</em>3<em>h</em>(<em>n</em>)</p>
<p>则有<em>f</em>1(<em>n</em>) +<em>g</em>1(<em>n</em>)=<em>O(h(n))</em>= <em>O</em>(max{<em>f</em>(n),<em>g</em>(<em>n</em>)})</p>
<p>即<em>O</em>(<em>f</em>(<em>n</em>))+<em>O</em>(<em>g</em>(<em>n</em>)) = <em>O</em>(max{<em>f</em>(n),<em>g</em>(<em>n</em>)})</p></blockquote>
<p>能搞清楚上下界就没问题。</p>


<h3 class="relative group">NP问题 
    <div id="np%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<blockquote>
<p>应该会考相关的归约的方法。</p></blockquote>


<h4 class="relative group">概括 
    <div id="%E6%A6%82%E6%8B%AC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A6%82%E6%8B%AC" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<ul>
<li><strong>P</strong>：可以“<strong>快速解决</strong>”的问题（即，多项式时间内能求解）。</li>
<li><strong>NP</strong>：可以“<strong>快速验证答案</strong>”的问题。</li>
<li><strong>NPC（NP-Complete，NP 完全）</strong>：目前认为“<strong>最难的 NP 问题</strong>”，一旦能快速解决一个，就能快速解决所有 NP 问题。</li>
<li><strong>NP-hard（NP 困难）</strong>：至少跟 NP 中最难的问题一样难，但本身<strong>不一定属于 NP</strong>。</li>
</ul>


<h4 class="relative group">解释 
    <div id="%E8%A7%A3%E9%87%8A" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%A7%A3%E9%87%8A" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>注意这张图的关系：
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250506165909494.png?lastModify=1746948169" alt="image-20250506165909494" />
      
    </figure>
</p></blockquote>


<h5 class="relative group">P（Polynomial Time）问题 
    <div id="ppolynomial-time%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#ppolynomial-time%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<ul>
<li><strong>定义</strong>：能在“多项式时间”内求出解的问题。</li>
<li><strong>理解方式</strong>：你的程序运行时间是 O(n),O(n2),O(n3)O(n), O(n^2), O(n^3)O(n),O(n2),O(n3) 这种（不是指数或阶乘），就属于 P。</li>
<li><strong>例子</strong>：
<ul>
<li>排序（冒泡、快排）</li>
<li>最短路径（Dijkstra）</li>
<li>匹配括号是否合法（栈）</li>
</ul>
</li>
</ul>


<h5 class="relative group">NP（Non-deterministic Polynomial Time）问题 
    <div id="npnon-deterministic-polynomial-time%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#npnon-deterministic-polynomial-time%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<ul>
<li><strong>定义</strong>：解可以在多项式时间内被验证的问题。</li>
<li><strong>关键点</strong>：你不一定能很快找到解，但<strong>一旦别人告诉你答案，你可以很快验证</strong>它对不对。</li>
<li><strong>例子</strong>：
<ul>
<li>给一个图，问是否存在一个旅行路径经过所有城市一次？（TSP）</li>
<li>给一个布尔表达式，问是否存在变量组合使其为真？（SAT）</li>
</ul>
</li>
</ul>


<h5 class="relative group">NP 完全（NPC, NP-Complete） 
    <div id="np-%E5%AE%8C%E5%85%A8npc-np-complete" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np-%E5%AE%8C%E5%85%A8npc-np-complete" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<ul>
<li><strong>定义</strong>：NP 中<strong>最难</strong>的问题。</li>
<li>满足两个条件：
<ol>
<li>本身属于 NP。</li>
<li>所有 NP 问题都可以在多项式时间归约到它上。</li>
</ol>
</li>
<li><strong>通俗理解</strong>：它是“NP 阶层中的老大哥”。如果有一天你能快速解决一个 NPC 问题，那你就能快速解决所有 NP 问题（即 P=NPP = NPP=NP）。</li>
<li><strong>著名例子</strong>：
<ul>
<li>SAT（布尔可满足性问题）</li>
<li>TSP（旅行商问题）</li>
<li>3-Coloring（三染色问题）</li>
<li>Subset Sum（子集和问题）</li>
</ul>
</li>
</ul>


<h5 class="relative group">NP-hard（NP 困难） 
    <div id="np-hardnp-%E5%9B%B0%E9%9A%BE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np-hardnp-%E5%9B%B0%E9%9A%BE" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>注意：<strong>NP难问题不一定是NP问题</strong>！</p></blockquote>
<ul>
<li><strong>定义</strong>：比 NP 还难的问题（不一定能验证解）。</li>
<li>不一定在 NP 类别中，比如<strong>不要求答案验证要快</strong>。</li>
<li>一些 NP-hard 问题甚至<strong>不可判定</strong>（比如停机问题）。</li>
</ul>


<h2 class="relative group">2.递归和分治策略 
    <div id="2%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<blockquote>
<p>凡治众如治寡，分数是也。 &mdash;-《孙子兵法》</p></blockquote>
<blockquote>
<p>求解采用自顶向下的计算方式。</p>
<p>1.最优子结构。2.小问题可以直接解决。3.最后可以小的问题合并成最终答案。4.子问题之间相互独立。</p></blockquote>


<h3 class="relative group">概念 
    <div id="%E6%A6%82%E5%BF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A6%82%E5%BF%B5" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>hanoi问题：</p>
<p>设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的这一叠圆盘移到塔座b上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：</p>
<p>规则1：每次只能移动1个圆盘；</p>
<p>规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；</p>
<p>规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">hanoi</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">hanoi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">	</span><span class="c1">//设法将n-1个较小的圆盘依照移动规则从塔座a移至塔座c</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span><span class="w">			</span><span class="c1">//将塔座a上编号为n的圆盘移到b上</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">hanoi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">	</span><span class="c1">//设法将n-1个较小的圆盘依照移动规则从塔座c移至塔座b</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>一般的流程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="n">divide</span><span class="o">-</span><span class="n">and</span><span class="o">-</span><span class="n">conquer</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n0</span><span class="p">)</span><span class="w"> </span><span class="n">adhoc</span><span class="p">(</span><span class="n">P</span><span class="p">);</span><span class="w">   					 </span><span class="c1">//解决小规模的问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">divide</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="n">subinstances</span><span class="w"> </span><span class="n">P1</span><span class="p">,</span><span class="n">P2</span><span class="p">,...,</span><span class="n">Pk</span><span class="err">；</span><span class="c1">//分解问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="p">,</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">yi</span><span class="o">=</span><span class="n">divide</span><span class="o">-</span><span class="n">and</span><span class="o">-</span><span class="n">conquer</span><span class="p">(</span><span class="n">Pi</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">												</span><span class="c1">//递归的解各子问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">merge</span><span class="p">(</span><span class="n">y1</span><span class="p">,...,</span><span class="n">yk</span><span class="p">);</span><span class="w">  						</span><span class="c1">//将各子问题的解合并为原问题的解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h3 class="relative group">递归的求解 
    <div id="%E9%80%92%E5%BD%92%E7%9A%84%E6%B1%82%E8%A7%A3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%B1%82%E8%A7%A3" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>​	一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30333764313733383065643134616236383834653132376437653761633033342e706e67.png?lastModify=1746948169" alt="https://camo.githubusercontent.com/34570d68be3ffbd46fe9df313b8661cc9aa229ae2c6e5d071ae6dc26f9c4472d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30333764313733383065643134616236383834653132376437653761633033342e706e67" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250424180426165.png?lastModify=1746948169" alt="image-20250424180426165" />
      
    </figure>
</p>


<h4 class="relative group">1.递归树法 
    <div id="1%E9%80%92%E5%BD%92%E6%A0%91%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%80%92%E5%BD%92%E6%A0%91%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250424174447475.png?lastModify=1746948169" alt="image-20250424174447475" />
      
    </figure>
</p>
<p>考虑分解和合并的时间：</p>
<p>由于该递归表达式分为两项，所以算树的高度时，我们只需要看n/2的分解，由</p>
<p>𝑛2ℎ=1</p>
<p>可得递归树的层数为</p>
<p>ℎ=log2⁡𝑛</p>
<p>分解的时间消耗为</p>
<p>𝑡1\len2(1+516+25256+&hellip;+(516)log2⁡𝑛−1=(516)log2⁡𝑛−1516−1&lt;1611𝑛2</p>
<p>则有</p>
<p>𝑡1=𝑂(𝑛2)</p>
<p>叶子节点小于n个，所以合并就是O（n），那么最终就为t1。</p>


<h4 class="relative group">2.主方法 
    <div id="2%E4%B8%BB%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E4%B8%BB%E6%96%B9%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>令和𝑎≥1和𝑏&gt;1是常数，𝑓(𝑛)是一个函数，𝑇(𝑛)是定义在非负整数上的递归式： 𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)</p>
<p><strong>T(n)</strong> 有如下渐进界：</p>
<p>1️⃣ 若对某个常数   ϵ  &gt;  0 有𝑓(𝑛)=𝑂(𝑛log𝑏⁡𝑎−𝜖)，则   T  (  n  )  =  Θ  (nlogba)</p>
<p>2️⃣ 若𝑓(𝑛)=Θ(𝑛log𝑏⁡𝑎)，则𝑇(𝑛)=Θ(𝑛log𝑏⁡𝑎lg⁡𝑛)</p>
<p>3️⃣ 若对某个常数   ϵ  &gt;  0 有𝑓(𝑛)=Ω(𝑛log𝑏⁡𝑎+𝜖)，且对某个常数𝑐&lt;1和足够大的<em>n</em>有𝑎𝑓(𝑛/𝑏)≤𝑐𝑓(𝑛)则</p>
<p>T  (  n  )  =  Θ  (  f  (  n  )  )</p>
<p><strong>注意点</strong></p>
<blockquote>
<p>在第一种情况中，不是𝑓(𝑛)小于𝑛log𝑏⁡𝑎就够了，而是要多项式意义上的小于，也就是说，𝑓(𝑛)必须渐进小于𝑛log𝑏⁡𝑎，要相差一个因子𝑛𝜖。</p>
<p>其中𝜖是大于0的常数。</p>
<p>在第三种情况中，不是𝑓(𝑛)大于𝑛log𝑏⁡𝑎就够了，而是要多项式意义上的大于，而且还要满足&quot;正则&quot;条件𝑎𝑓(𝑛/𝑏)≤𝑐𝑓(𝑛)。遇到的多项式界的函数中，多数都满足这个条件。</p>
<p>此外，这三种情况并非覆盖了𝑓(𝑛)的所有情况，𝑓(𝑛)可能小于𝑛log𝑏⁡𝑎，但不是多项式意义上的小于，也有可能大于但不是多项式意义上的大于，这时候就<strong>不能用主方法来求解，而是需要用递归树。</strong></p></blockquote>


<h5 class="relative group"><strong>举例说明</strong> 
    <div id="%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>1️⃣   T  (n)  =  9  T  (n/3)  +  n</p>
<p>​	有𝑎=9,𝑏=3,𝑓(𝑛)=𝑛,因此𝑛log𝑏⁡𝑎=𝑛log3⁡9=Θ(𝑛2)，当我们取𝜖=1,有𝑓(𝑛)=𝑂(𝑛log3⁡9−1)，由定理一则有𝑇(𝑛)=Θ(𝑛2)</p>
<p>2️⃣   T  (n)  =  T  (2n/3)  +  1</p>
<p>​	有𝑎=1,𝑏=3/2,𝑓(𝑛)=1,因此𝑛log𝑏⁡𝑎=𝑛log3/2⁡1=𝑛0=Θ(1)，由于𝑓(𝑛)=Θ(𝑛log𝑏⁡𝑎)=Θ(1)，由定理二则有𝑇(𝑛)=Θ(lg⁡𝑛)</p>
<p>3️⃣   T  (n)  =  3  T  (n/4)  +  nlgn</p>
<p>​	有𝑎=3,𝑏=4,𝑓(𝑛)=𝑛lg⁡𝑛,因此𝑛log𝑏⁡𝑎=𝑛log4⁡3=𝑂(𝑛0.793)，由于𝑓(𝑛)=Ω(𝑛log4⁡3+𝜖)，其中𝜖≈0.2，因此如果可以证明正则条件成立，则可以使用定理三。当n足够大时，对于𝑐=3/4，（𝑎𝑓(𝑛/𝑏)=3（𝑛/4)lg⁡(𝑛/4)≤(3/4)𝑛lg⁡𝑛=𝑐𝑓(𝑛)，由定理二则有𝑇(𝑛)=Θ(𝑛lg⁡𝑛)</p>
<p>⚠️主方法不适用于𝑇(𝑛)+2𝑇(𝑛/2)+𝑛lg⁡𝑛</p>
<p>​	有𝑎=2,𝑏=2,𝑓(𝑛)=𝑛lg⁡𝑛,因此𝑛log𝑏⁡𝑎=𝑛，𝑓(𝑛)虽然渐进大于n，但是并不是多项式意义上的的大于**(比值要是n的次方)**，对于任意的正常数𝜖，比值𝑓(𝑛)/𝑛log𝑏⁡𝑎=lg⁡𝑛都渐进小于𝑛𝜖，陷入了特殊情况，使用递归树可解决。</p>
<blockquote>
<p>可以这么理解，谁大就由谁来决定，相等的情况就是对数和算出来的式子直接做乘法。</p></blockquote>


<h3 class="relative group">分治算法具体问题设计 
    <div id="%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%E8%AE%BE%E8%AE%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%E8%AE%BE%E8%AE%A1" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>merge and sort</strong></p>


<h4 class="relative group">1.二分算法 
    <div id="1%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>​	每执行一次算法的while循环，待搜索的数组的大小就减少一半。因此，在最坏情况下，while循环被执行了𝑂(log⁡𝑛)次。循环体内运算需要𝑂(1)时间，因此整个算法在最坏情况下的时间复杂性为𝑂(log⁡𝑛)。</p>
<p>二分代码的纠错，写出bugfree的二分代码，分析七个二分算法的错误。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427222029891.png?lastModify=1746948169" alt="image-20250427222029891" />
      
    </figure>
</p>
<p>下标变化错误，会进入死循环。（1  2 3 5 6 7 这个序列中去找数字4）</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427222523969.png?lastModify=1746948169" alt="image-20250427222523969" />
      
    </figure>
</p>
<p>right控制的有问题，当要查找的数据在最右边的时候就找不到了（1 2 3 5 6 7 中找 7）</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427223008634.png?lastModify=1746948169" alt="image-20250427223008634" />
      
    </figure>
</p>
<p>和上面是同理的，left + 1 != right 就是 left &lt; right - 1</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427223434467.png?lastModify=1746948169" alt="image-20250427223434467" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427223448361.png?lastModify=1746948169" alt="image-20250427223448361" />
      
    </figure>
</p>
<p>下标控制错误，left = middle + 1,当要查找的元素为数组中的最后一个的时候，此时陷入死循环。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427223903487.png?lastModify=1746948169" alt="image-20250427223903487" />
      
    </figure>
</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>第五个是正确的代码，middle控制的向上作取整可以使得left不用等于middle加1,当有多个重复的时候，取的值是最右边的值。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427224910210.png?lastModify=1746948169" alt="image-20250427224910210" />
      
    </figure>
</p>
<p>多了<strong>right = mid - 1</strong>，这样我们就没办法找到最右边的值了。注意这两个代码都是 left &lt; right 而非相等的。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427225045870.png?lastModify=1746948169" alt="image-20250427225045870" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427225057168.png?lastModify=1746948169" alt="image-20250427225057168" />
      
    </figure>
</p>
<p>right = mid，右边的值到不了左边来，那么当你找的数字为第一个元素的时候就会陷入死循环。</p>
<p>从判断错误的角度来讲，举极端例子（找最左边或者最右边），或者数组长度只有1的情况都是很好的方法。</p>


<h4 class="relative group">2.大整数乘法 
    <div id="2%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>处理两个位数很大的数字的乘法：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35363135313537393261356434393635396262366562636438386638303836642e706e67.png?lastModify=1746948169" alt="https://camo.githubusercontent.com/eb222a0dc23e0ca72f065dd554c8d085828f06657966e41739e098a898f27368/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35363135313537393261356434393635396262366562636438386638303836642e706e67" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250427230331626.png?lastModify=1746948169" alt="image-20250427230331626" />
      
    </figure>
</p>
<p>用类似于因式分解的方法，把原来的两次乘法改成一次乘法，但是只是多了几次加法而已。</p>


<h4 class="relative group">3.Strassen矩阵乘法 
    <div id="3strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>这一部分可以看书，把八次乘法转换成了七次的乘法，和上面的大整数乘法是类似的思想。</p>


<h4 class="relative group">4.棋盘覆盖问题 
    <div id="4%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	在一个2𝑘×2𝑘  个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30333564623030613535346134643361616635336638323234366361633763352e706e67.png?lastModify=1746948169" alt="https://camo.githubusercontent.com/0e41e0d76785ae12696a48309a9d11e70f243d5abb0343e74acd40ebb61ff264/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30333564623030613535346134643361616635336638323234366361633763352e706e67" />
      
    </figure>
</p>
<p>​	将2𝑘×2𝑘 棋盘分割为4个2𝑘−1×2𝑘−1  子棋盘(a)所示。特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，如 (b)所示，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘1×1。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35613239396638373738396334366337613361313164303931656363326435612e706e67.png?lastModify=1746948169" alt="棋盘问题的分治办法" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64376434376165626536306634363132613431363164363664393231656136382e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</p>
<p>​	解此递归方程可得𝑇(𝑘)=𝑂(4𝑘)，由于覆盖一个2𝑘×2𝑘 棋盘所需要的L型骨牌个数为(4𝑘−1)/3，所以该算法为一个在<strong>渐进意义下的最优算法。</strong></p>


<h4 class="relative group">5.合并排序（merge sort） 
    <div id="5%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	<strong>基本思想</strong>：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。</p>
<p>最坏时间复杂度：O(nlogn)	平均时间复杂度：O(nlogn)	辅助空间：O(n)</p>
<p>最坏情况下的时间复杂度：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f61633762313463336164343334376463616335383331363165376661616665342e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</p>
<p>​	<strong>概念</strong>：解此递归方程为𝑇(𝑛)=𝑂(𝑛log⁡𝑛)，由于排序问题的计算时间下界为Ω(𝑛log⁡𝑛)，所以合并排序算法为一个渐进最优算法。</p>
<p>​	对于算法MergeSort，可以利用分治法消除其中的递归。可以先将数组a中相邻的元素两两配对，用合并算法将他们排序，构成n/2组长度为2的排好序的子数组段，然后再把它们排成长度为4的排好序的子数组段，如此继续下去，直至整个数组排好序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">Recursion</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MergeSort</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sortArray</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">temp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mid</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp1</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">temp1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp2</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">temp2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp1</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp2</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//注意这里保证了排序的稳定性，小于等于就直接放进去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">temp2</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">array</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">array</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp2</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp1</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">array</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">temp2</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">array</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp2</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="o">/</span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">9</span><span class="p">,</span><span class="n">8</span><span class="p">,</span><span class="n">7</span><span class="p">,</span><span class="n">6</span><span class="p">,</span><span class="n">5</span><span class="p">,</span><span class="n">4</span><span class="p">,</span><span class="n">3</span><span class="p">,</span><span class="n">2</span><span class="p">,</span><span class="n">1</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">MergeSort</span><span class="w"> </span><span class="n">mergeSort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MergeSort</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mergeSort</span><span class="p">.</span><span class="na">sortArray</span><span class="p">(</span><span class="n">array</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">6.快速排序（Quick Sort） 
    <div id="6%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#6%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	在快速排序中，记录的比较和交换是从两端向中间进行的，关键字较大的记录一次就能交换到后面单元，关键字较小的记录一次就能交换到前面单元，记录每次移动的距离较大，因而总的比较和移动次数较少。</p>
<p>算法分析如下：</p>
<p>对于输入的子数组a[p:r]，按照以下三个步骤排序：</p>
<p>1️⃣ 分解：以a[p]作为基准元素将a[p:r]分解为三段a[p:q-1],a[q],a[q+1:r]，使a[p:q-1]中的任意一个元素小于等于a[q]，a[q+1:r]中任何一个元素大于等于a[q]，下标在划分过程中确定。</p>
<p>2️⃣ 递归求解：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序</p>
<p>3️⃣ 合并：由于对a[p:q-1]和a[q+1:r]的排序使就地进行的，因此排好序后不需要再执行其他计算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">Recursion</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">QuickSort</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">15</span><span class="p">,</span><span class="n">14</span><span class="p">,</span><span class="n">13</span><span class="p">,</span><span class="n">12</span><span class="p">,</span><span class="n">11</span><span class="p">,</span><span class="n">10</span><span class="p">,</span><span class="n">9</span><span class="p">,</span><span class="n">8</span><span class="p">,</span><span class="n">7</span><span class="p">,</span><span class="n">6</span><span class="p">,</span><span class="n">5</span><span class="p">,</span><span class="n">4</span><span class="p">,</span><span class="n">3</span><span class="p">,</span><span class="n">2</span><span class="p">,</span><span class="n">1</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">0</span><span class="p">,</span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="n">arr</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">partitionIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="o">-</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="o">+</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//找到第一个小于pivot的元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">right</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//把右边的值移到左边来</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//找到第一个大于pivot的元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">left</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//把左边的值移到右边来</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//最后进行交换</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>这里是取第一个元素作为划分的基准，如果取最后一个元素作为基准而且其是数组中最大的元素，那么会陷入死循环。</p>
<p>对于输入序列a[p:r] , Partition的计算时间显然为𝑂(𝑟−𝑝−1)。</p>
<p>​	快速排序的运行时间与<strong>划分是否对称有关</strong>,其最坏情况发生在划分过程产生的两个区域分别包含n- 1个元素和1个元素的时候。由于函数Partition的计算时间为𝑂(𝑛),所以如果算法Partition的每一步都出现这种不对称划分,则其计算时间复杂性T(n) 满足 <a href="https://camo.githubusercontent.com/a6e5e7c1a77eb2e65957fbd6b31472302c25524be9fac8ce2a6bc443eb46288a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f63633635383732383365363934303630383937373562623131363438613863392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f63633635383732383365363934303630383937373562623131363438613863392e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>解此递归方程可得𝑇(𝑛)=𝑂(𝑛2)。</p>
<p>​	在最好情况下,每次划分所取的基准都恰好为中值,即每次划分都产生两个大小为n/2的区域，此时，Partition的计算时间T(n)满足 <a href="https://camo.githubusercontent.com/1ea51ce3c82731854dcbaff5dda444687cd28bc956fdcc6b3440ad6bcb0d268c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31333963343466336435613734343661613632373038323333353863396435642e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31333963343466336435613734343661613632373038323333353863396435642e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>​	可以证明,快速排序算法在<strong>平均情况下的时间复杂性也是</strong>  T  (  n  )  =  O  (  n  log  ⁡  n  ) ,这在基于比较的排序算法类中算是快速的,快速排序也因此而得名。</p>
<p>​	随机选取值而不是每次都选取第一个就可以解决这个问题。</p>


<h4 class="relative group">7.线性时间选择 
    <div id="7%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#7%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>⭐ <strong>要能根据代码分析时间复杂度</strong></p>
<p>​	给定线性序集中n个元素和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素，只需要调用如下方法：RandomizedSelect(a,0,n-1,k)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kd">class</span> <span class="nc">Type</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Type</span><span class="w"> </span><span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="o">[]</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">r</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">p</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RandomizePartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">j</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>​	在算法RandomizedSelect中执行RandomizedPartition后;数组a[p:r]被划分成两个子数组a[p:i]和a[i+1:r],使得中每个元素都不大于a[i+1:r]中每个元素。接着算法计算子数组a[p:i]中元素个数j。如果k≤j,则a[p:r]中第k小元素落在子数组a[p:i]中如果k&gt;  j,则要找的第k小元素落在子数组a[i+1:r]中。由于此时已知道子数组a[p:i]中元素均小于要找的第k小元素,因此，要找的a[p:r]中第k小元素是a[i+ 1:r]中的第k- j 小元素。</p>
<p>​	在最坏情况下,算法RandomizedSelect需要𝑂(𝑛2)计算时间。例如在找最小元素时，总是在最大元素处划分。尽管如此,该算法的平均性能很好。<strong>在平均情况下，算法RandomizedSelect可以在𝑂(𝑛)时间内解决</strong>⭐</p>
<p>​	如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的ε倍(0&lt;ε&lt;1是某个正常数)，那么就可以<strong>在最坏情况下</strong>用O(n)时间完成选择任务。例如，若ε=9/10，算法递归调用所产生的子数组的长度至少缩短1/10。所以，在最坏情况下，算法所需的计算时间T(n)满足递归式T(n)≤T(9n/10)+O(n) 。由此可得T(n)=O(n)。</p>
<p>寻找划分标准的算法如下：</p>
<blockquote>
<p>分组，寻找中位数的中位数，这样的分割位置相对来说比较公平。</p></blockquote>
<p>​	1️⃣ 将n个输入元素划分成⌈𝑛/5⌉个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共⌈𝑛/5⌉个。</p>
<p>​	2️⃣ 递归调用<strong>Select</strong>来找出这⌈𝑛/5⌉个元素的中位数。如果⌈𝑛/5⌉是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</p>
<p>​	设所有元素互不相同。在这种情况下，找出的基准x至少比3(n-5)/10个元素大，因为在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n/5-1)/2=(n-5)/10个小于基准x。同理，基准x也至少比3(n-5)/10个元素小。而当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250428224459244.png?lastModify=1746948169" alt="image-20250428224459244" />
      
    </figure>
</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kd">class</span> <span class="nc">Type</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Type</span><span class="w"> </span><span class="nf">Select</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">&lt;</span><span class="n">75</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">Sort</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//用某个简单排序算法对数组a[p:r]排序;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">-</span><span class="n">4</span><span class="p">)</span><span class="o">/</span><span class="n">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="c1">//将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">Type</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">-</span><span class="n">4</span><span class="p">)</span><span class="o">/</span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">-</span><span class="n">4</span><span class="p">)</span><span class="o">/</span><span class="n">10</span><span class="p">);</span><span class="w"> </span><span class="c1">//找中位数的中位数，r-p-4即上面所说的n-5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>​	上述算法<strong>将每一组的大小定为5，并选取75作为是否作递归调用的分界点</strong>。这2点保证了T(n)的递归式中2个自变量之和n/5+3n/4=19n/20=εn，0&lt;ε&lt;1。这是使T(n)=O(n)的关键之处。当然，除了5和75之外，还有其他选择</p>
<p>时间复杂度分析为： <a href="https://camo.githubusercontent.com/a000900defcd2331e11269f7a36e6cea59e0b74e273c6490789d6682efc059c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f39396130323931643331303634636136393964616636316264303236313562302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f39396130323931643331303634636136393964616636316264303236313562302e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>解得：𝑇(𝑛)=𝑂(𝑛)，要会用递归树求解</p>
<blockquote>
<p>看不懂就记住时间复杂度为O（n），考试前再看一下原理，记忆一下数字规律也可以。</p></blockquote>


<h4 class="relative group">8.最近点对问题 
    <div id="8%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#8%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>会写伪代码，典型的简答题。</strong></p>
<blockquote>
<p>给定平面上n个点，找其中的一对点，使得在n个点组成的所有点对中，该点对的距离最小。</p></blockquote>
<p>​	为了使问题易于理解和分析，先来考虑<strong>一维</strong>的情形。此时，S中的n个点退化为x轴上的n个实数 x1,x2,…,xn。最接近点对即为这n个实数中相差最小的2个实数。</p>
<p>​	假设我们用x轴上某个点m将S划分为2个子集S1和S2 ，基于<strong>平衡子问题</strong>的思想，用S中各点坐标的中位数来作分割点。递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设<strong>d=min{|p1-p2|,|q1-q2|}</strong>，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;d，则p3和q3两者与m的距离不超过d，即p3∈(m-d,m]，q3∈(m,m+d]。由于在S1中，每个长度为d的半闭区间至多包含一个点（否则必有两点距离小于d），并且m是S1和S2的分割点，因此(m-d,m]中至多包含S中的一个点。由图可以看出，如果(m-d,m]中有S中的点，则此点就是S1中最大点，同理S2这么找就会找到最小的点。因此，我们用线性时间就能找到区间(m-d,m]和(m,m+d]中所有点，即p3和q3。从而我们<strong>用线性时间就可以将S1的解和S2的解合并成为S的解</strong>。</p>
<p><a href="https://camo.githubusercontent.com/af47185d8c0bf99ec348b4d46be98a4e3ea138843b43b76dc849cd7392775829/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35393735316235383565633834383235616361313633376535356136333335302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35393735316235383565633834383235616361313633376535356136333335302e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>以下是<strong>二维</strong>的情况：</p>
<p>​	选取一垂直线<strong>l:x=m</strong>来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1和S2。递归地在S1和S2上找出其最小距离d1和d2，并设<strong>d=min{d1,d2}</strong>，S中的最接近点对或者是d，或者是某个{p,q}，其中p∈P1且q∈P2。</p>
<p>考虑P1中任意一点p，它若与P2中的点q构成最接近点对的候选者，则必有distance(p，q)＜d。满足这个条件的P2中的点一定落在一个d×2d的矩形R中由d的意义可知，P2中任何2个S中的点的距离都不小于d。由此可以推出矩形R中<strong>最多只有6个S中的点</strong>。因此，在分治法的合并步骤中最多只需要检查6×n/2=3n个候选者</p>
<p>⭐ <strong>证明</strong> 将矩形R的长为2d的边3等分，将它的长为d的边2等分，由此导出6个(d/2)×(2d/3)的矩形。若矩形R中有多于6个S中的点，则由<strong>鸽舍原理</strong>易知至少有一个(d/2)×(2d/3)的小矩形中有2个以上S中的点。设u，v是位于同一小矩形中的2个点，则</p>
<p>​	证明就是六等分，那么一个小矩形的对角边就是最大的长度。</p>
<p><a href="https://camo.githubusercontent.com/e0d8d218dabcb622ddcd8523a027bf0ac7a00025d4f81a38c0da2c890ad2c361/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f33373231333133393762646234393635383738623736346361663031336134322e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f33373231333133393762646234393635383738623736346361663031336134322e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>distance(u,v)&lt;d。这与d的意义相矛盾。图b是具有6个S中的点的极端情况。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250429195052475.png?lastModify=1746948169" alt="image-20250429195052475" />
      
    </figure>
</p>
<p><strong>由上述证明可知，在分治法的合并步骤中，最多只需要检查6xn/2=3n个候选者，而不是n^2/4个。</strong></p>
<p>​	为了确切地知道要检查哪6个点，可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于d。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S中点按其y坐标排好序，则对P1中所有点，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者。对P1中每一点最多只要检查P2中排好序的相继6个点。</p>
<p>以下就是伪代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">double</span><span class="w"> </span><span class="nf">cpair2</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">n</span><span class="o">=|</span><span class="n">S</span><span class="o">|</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">无穷</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">1</span><span class="err">、</span><span class="n">m</span><span class="o">=</span><span class="n">S中各点x间坐标的中位数</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//构造S1和S2；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">S1</span><span class="o">=</span><span class="p">{</span><span class="n">p</span><span class="err">∈</span><span class="n">S</span><span class="o">|</span><span class="n">x</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">S2</span><span class="o">=</span><span class="p">{</span><span class="n">p</span><span class="err">∈</span><span class="n">S</span><span class="o">|</span><span class="n">x</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;</span><span class="n">m</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//作递归的处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">2</span><span class="err">、</span><span class="w"> </span><span class="n">d1</span><span class="o">=</span><span class="n">cpair2</span><span class="p">(</span><span class="n">S1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">d2</span><span class="o">=</span><span class="n">cpair2</span><span class="p">(</span><span class="n">S2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">//找到集合内的最近距离点对，并且记录大小</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">3</span><span class="err">、</span><span class="n">dm</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">//预先排序的处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">4</span><span class="err">、</span><span class="n">设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">P2是S2中距分割线l的距离在dm之内所有点组成的集合</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">将P1和P2中点依其y坐标值排序</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">并设X和Y是相应的已排好序的点列</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//1对6的扫描找最小值 所以最多是3 * n</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">5</span><span class="err">、</span><span class="n">通过扫描X以及对于X中每个点检查Y中与其距离在dm之内的所有点</span><span class="p">(</span><span class="n">最多6个</span><span class="p">)</span><span class="n">可以完成合并</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">当X中的扫描指针逐次向上移动时</span><span class="err">，</span><span class="n">Y中的扫描指针可在宽为2dm的区间内移动</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">设dl是按这种扫描方式找到的点对间的最小距离</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">6</span><span class="err">、</span><span class="n">d</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span><span class="n">dl</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>核心过程就是第五步。</p></blockquote>
<p>​	下面分析算法Cpair2的计算复杂性。设对于n个点的平面点集S  ,算法耗时T(n)。算法的第1步和第5步用了𝑂(𝑛)时间。第3步和第6步用了常数时间。第2步用了2T(n/2)时间。若在每次执行第4步时进行排序,则在最坏情况下第4步要用𝑂(𝑛log⁡𝑛)时间。这不符合我们 的要求。因此，在这里我们采用设计算法时常用的<strong>预排序技术</strong>,在使用分治法之前,预先将S中n个点依其y坐标值排好序,设排好序的点列为P  。在执行分治法的第4步时,只要对𝑃∗作一次线性扫描,即可抽取出我们所需要的排好序的点列X和Y。然后，在第5步中再对X作一次线性扫描,即可求得dl.因此,第4步和第5步的两遍扫描合在一起只要用0(n)时间。这样,经过预排序处理后算法Cpair2 所需的计算时间T(n)满足递归方程 <a href="https://camo.githubusercontent.com/24070aa0163a5fb300c024792299c551e6310f16a5dcfc3e54cf9e545f181a6d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30643337373965643838646334626263396563313163623438363462623234322e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30643337373965643838646334626263396563313163623438363462623234322e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>由此易知,   T  (n)  =  O(nlogn) 。预排序所需的计算时间显然为𝑂(𝑛log⁡𝑛)。因此,整个算法所需的计算时间为𝑂(𝑛log⁡𝑛),在渐近的意义下,此算法已是最优算法。</p>
<p>注意考试的时候要写上边界（n = 4）。</p>


<h2 class="relative group">3.动态规划 
    <div id="3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">基本概念和步骤 
    <div id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%AD%A5%E9%AA%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%AD%A5%E9%AA%A4" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1、与分治法的异同 
    <div id="1%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>相同点：都是将求解问题分为若干个子问题</p>
<p>不同点：分治法所要求的子问题是独立的，而动态规划所求解的子问题往往不是独立的，重叠的子问题的多次运算可能会造成指数级的运算量。</p>


<h4 class="relative group">2、动态规划的核心思想 
    <div id="2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>**记表备查：**保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</p>


<h4 class="relative group">3、解题步骤 
    <div id="3%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>1️⃣ 找出最优解的性质，并刻划其结构特征。</p>
<p>2️⃣ 递归地定义最优值。</p>
<p>3️⃣ 以自底向上的方式计算出最优值。</p>
<p>4️⃣ 根据计算最优值时得到的信息，构造最优解</p>


<h4 class="relative group">4、基本要素 
    <div id="4%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>重叠子问题与最优子结构。</p>
<blockquote>
<p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优<strong>子结构性质。</strong></p>
<p>要证明最优子结构的性质。</p></blockquote>
<p><strong>最优子结构的证明</strong>通常采用<strong>反证法</strong>，需要掌握。</p>
<p>全局的最优一定有局部的最优，局部的最优不一定会形成全局的最优，必要不充分条件</p>


<h4 class="relative group">5、两种基本形态 
    <div id="5%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>动态规划(自底向上)与备忘录（memo）方法。</p>
<p>备忘录方法是动态规划方法的变形，都是记表备查，不同点在于备忘录方法是自顶向下的递归，而动态规划是自底向上的递归</p>
<p>一般来说，当一个问题的所有子问题都需要至少解一次时，用动态规划算法比用备忘录方法要好</p>


<h3 class="relative group">具体问题设计 
    <div id="%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%E8%AE%BE%E8%AE%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%E8%AE%BE%E8%AE%A1" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1.*矩阵连乘问题 
    <div id="1%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	给定n个矩阵𝐴1,𝐴2,…,𝐴𝑛，其中𝐴𝑖与𝐴𝑖+1是可乘的，i=1, 2,…, n-1。考察这n个矩阵的连乘积𝐴1𝐴2…𝐴𝑛。</p>
<p>​	由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用<strong>加括号</strong>的方式来确定。若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。</p>
<p>完全加括号的矩阵连乘积可递归地定义为：</p>
<p>①单个矩阵是完全加括号的；</p>
<p>②矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)</p>
<p>设有四个矩阵A,B,C,D，可以有以下5种不同的加括号方式：</p>
<blockquote>
<p>(A(B(CD)))   (A((BC)D))    ((AB)(CD))    ((A(BC))D)    (((AB)C)D)</p></blockquote>
<p>​	每一种完全加括号方式对应于一种矩阵连乘积的计算次序，而<strong>矩阵连乘积的计算次序与其计算量有密切关系</strong>。矩阵A(p×q)和矩阵B(q×r)的乘积C=AB是一个p×r的矩阵，数乘次数为pqr</p>
<p>❓ <strong>问题：</strong></p>
<blockquote>
<p>给定n个矩阵𝐴1,𝐴2,…,𝐴𝑛，其中𝐴𝑖与𝐴𝑖+1是可乘的，i=1, 2,…, n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p></blockquote>


<h5 class="relative group">1）穷举法 
    <div id="1%E7%A9%B7%E4%B8%BE%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E7%A9%B7%E4%B8%BE%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序。</p>
<p>对于n个矩阵的连乘积，设其不同的计算次序为P(n)。由于每种加括号方式都可以分解为两个子矩阵的加括号问题：(A1&hellip;Ak)(Ak+1…An)可以得到关于P(n)的递推式如下：</p>
<p><a href="https://camo.githubusercontent.com/addf39b097823e9c60c4e777b4ae1566f9dc9b7675b09a28cce9118eeba56d58/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323231343132323131392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323231343132323131392e706e67.png?lastModify=1746948169" alt="image-20211002214122119" />
      
    </figure>
</a></p>
<p>这个数字太大，没有计算价值。</p>


<h5 class="relative group">2）动态规划法 
    <div id="2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>将矩阵连乘积AiAi+1…Aj简记为A[i:j] ，这里i≤j 。</p>
<p>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为：</p>
<p><strong>(AiAi+1…Ak)  (Ak+1Ak+2…Aj)</strong></p>
<p>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。</p>
<p>1️⃣ <strong>分析最优解的结构</strong></p>
<p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。</p>
<p><strong>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质</strong>。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p>
<p>2️⃣ <strong>建立递归关系</strong></p>
<p>设计算A[i:j]，1≤i≤j≤n，所需要的<strong>最少数乘次数m[i,j]</strong>，则原问题的最优值为m[1,n]。</p>
<p>设Ai的维数为𝑝𝑖−1×𝑝𝑖，则</p>
<p>当i=j时，𝐴[𝑖:𝑗]=𝐴𝑖，因此，m[i,i]=0，i=1,2,…,n</p>
<p>当i&lt;j时，𝑚[𝑖:𝑗]=𝑚[𝑖,𝑘]+𝑚[𝑘+1,𝑗]+𝑝𝑖−1𝑝𝑘𝑝𝑗</p>
<p>可以递归地定义m[i,j]为：</p>
<blockquote>
<p>必考问题。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/c00a894230a2351b9428cb14bc336927e534d0d7965cb2e5cc1466f9912c9b18/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323231353030333738362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323231353030333738362e706e67.png?lastModify=1746948169" alt="image-20211002215003786" />
      
    </figure>
</a></p>
<p>k的位置只有j-i种可能</p>
<p>3️⃣ <strong>计算最优值</strong></p>
<p>对于1≤i≤j≤n不同的有序对(i,j)对应于不同的子问题。因此，不同子问题的个数最多只有</p>
<p><a href="https://camo.githubusercontent.com/019c015fcf8daf3ff5c2dc17213818d0da6a9dc863b57c3da625bb33ecb8d8f2/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323232313930373632362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323232313930373632362e706e67.png?lastModify=1746948169" alt="image-20211002221907626" />
      
    </figure>
</a></p>
<p>​	<strong>由此可见，在递归计算时，许多子问题被重复计算多次</strong>。这也是该问题可用动态规划算法求解的又一显著特征</p>
<p>用动态规划算法解此问题，可依据其递归式以<strong>自底向上</strong>的方式进行计算。在计算过程中，保存已解决的子问题答案。<strong>每个子问题只计算一次</strong>，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法。</p>
<p><a href="https://camo.githubusercontent.com/a0daa754d8c4b9d9d046a51ed3c9569592a3f4af0969ca20ad3db85d235dd048/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323232323932383134312e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313030323232323932383134312e706e67.png?lastModify=1746948169" alt="image-20211002222928141" />
      
    </figure>
</a></p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">matrixChain</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//有n个矩阵</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//初始化为0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//控制矩阵链的长度</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">len</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="c1">//以第一个为基础</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                   </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="p">}</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>​	算法MatrixChain的主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为𝑂(1)，而3重循环的总次数为𝑂(𝑛3)。因此算法的计算时间上界为𝑂(𝑛3)。算法所占用的空间显然为𝑂(𝑛2)。</p>
<p>traceback递归地来构造答案，那么完整可运行的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">Dynamic</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">demo01</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">matrixChain</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//有n个矩阵</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//初始化为0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//控制矩阵链的长度</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">len</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="c1">//以第一个为基础</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                   </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">traceBack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">left</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="s">&#34;(&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">traceBack</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">traceBack</span><span class="p">(</span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="s">&#34;)&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">30</span><span class="p">,</span><span class="w"> </span><span class="n">35</span><span class="p">,</span><span class="w"> </span><span class="n">15</span><span class="p">,</span><span class="w"> </span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">,</span><span class="w"> </span><span class="n">20</span><span class="p">,</span><span class="w"> </span><span class="n">25</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">6</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">7</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">7</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">matrixChain</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">traceBack</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">6</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">6</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h5 class="relative group">3）备忘录方法 
    <div id="3%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>memo (python:@cache)</p>
<p>​	备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个<strong>解过的子问题</strong>建立了备忘录以备需要时查看，避免了相同子问题的重复求解。</p>
<p>​	备忘录方法的递归方式是<strong>自顶向下</strong>的，而动态规划算法则是<strong>自底向上</strong>递归的。</p>
<p>​	用递归解决问题的期间把值记录起来。</p>
<p>以下是代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">Dynamic</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">demo02</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">lookUpChain</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookUpChain</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lookUpChain</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">left</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookUpChain</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lookUpChain</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">left</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">curr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">m</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="n">right</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">min</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">2.凸多边形最优三角剖分 
    <div id="2%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>用多边形顶点的逆时针序列表示凸多边形，即P={v0,v1,…,vn-1}表示具有n条边的凸多边形。</p>
<p>若vi与vj是多边形上不相邻的2个顶点，则线段vivj称为多边形的一条弦。弦将多边形分割成2个多边形{vi,vi+1,…,vj}和{vj,vj+1,…,vi}。</p>
<p><strong>多边形的三角剖分</strong>是将多边形分割成互不相交的三角形的弦的集合T。</p>
<p>注意：T中各弦互不相交，且集合T已达到最大；有n个顶点的凸多边形的三角剖分中，恰有n-3条弦和n-2个三角形。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502103112539.png?lastModify=1746948169" alt="image-20250502103112539" />
      
    </figure>
</p>
<p><strong>题目描述</strong>：给定凸多边形P，以及定义在由多边形的边和弦组成的三角形上的权函数w。要求确定该凸多边形的三角剖分，使得该三角剖分中诸三角形上权之和为最小。</p>


<h5 class="relative group">① 三角剖分的结构 
    <div id="-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E7%BB%93%E6%9E%84" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	一个表达式的完全加括号方式相应于一棵完全二叉树，称为表达式的语法树。例如，完全加括号的矩阵连乘积((A1(A2A3))(A4(A5A6)))所相应的语法树如图 (a)所示。凸多边形{v0,v1,…vn-1}的三角剖分也可以用语法树表示。例如，图 (b)中凸多边形的三角剖分可用图 (a)所示的语法树表示。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502103537885.png?lastModify=1746948169" alt="image-20250502103537885" />
      
    </figure>
</p>
<p>​	矩阵连乘积中的每个矩阵Ai对应于凸(n+1)边形中的一条边𝑣𝑖−1𝑣𝑖。三角剖分中的一条弦𝑣𝑖𝑣𝑗，i&lt;j，对应于矩阵连乘积A[i+1:j]。</p>
<p>​	给定矩阵链𝐴1𝐴2𝐴3𝐴4𝐴5𝐴6，Ai的维数为𝑝𝑖−1×𝑝𝑖；定义凸多边形P={𝑣0,𝑣1,𝑣2,𝑣3,𝑣4,𝑣5,𝑣6}，其三角形𝑣𝑖𝑣𝑗𝑣𝑘上的权函数值为𝑤(𝑣𝑖𝑣𝑗𝑣𝑘)=𝑝𝑖𝑝𝑗𝑝𝑘，依此定义，P的最优三角剖分所对应的语法树给出了矩阵链的最优完全加括号方式。</p>


<h5 class="relative group">② 最优子结构性质 
    <div id="-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	凸多边形的最优三角剖分问题有最优子结构性质。</p>
<blockquote>
<p>证明的时候就要使用反证法。</p></blockquote>
<p>​	事实上，若凸(n+1)边形P={v0,v1,…,vn-1}的最优三角剖分T包含三角形v0vkvn，1≤k≤n-1，则T的权为3个部分权的和：三角形v0vkvn的权，子多边形{v0,v1,…,vk}和{vk,vk+1,…,vn}的权之和。<strong>可以断言，由T所确定的这2个子多边形的三角剖分也是最优的。<strong>因为若有{v0,v1,…,vk}或{vk,vk+1,…,vn}的</strong>更小权的三角剖分将导致T不是最</strong>优三角剖分的矛盾。</p>


<h5 class="relative group">③ 最优三角形剖分的递归结构 
    <div id="-%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%BD%A2%E5%89%96%E5%88%86%E7%9A%84%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#-%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%BD%A2%E5%89%96%E5%88%86%E7%9A%84%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>注意定义的时候前面有一个-1,所以最优方案也是从1开始为t1n</p></blockquote>
<p>​	定义𝑡[𝑖][𝑗]，1≤i&lt;j≤n为<strong>凸子多边形</strong>{vi-1, vi,…,vj}的最优三角剖分所对应的权函数值，即其最优值。为方便起见，设退化的多边形{vi-1,vi}具有权值0。据此定义，要计算的凸(n+1)边形P的最优权值为𝑡[1][𝑛]。</p>
<pre tabindex="0"><code>t  [  i  ]  [  j  ] 的值可以利用最优子结构性质递归地计算。当j-i≥1时，凸子多边形至少有3个顶点。由最优子结构性质，**$t[i][j]$**的值应为$t[i][k]$的值加上$t[k+1][j]$的值，再加上三角形$v_{i-1}v_kv_j$的权值，其中i≤k≤j-1。由于在计算时还不知道k的确切位置，而k的所有可能位置只有j-i个，因此可以在这j-i个位置中选出使值$t[i][j]$达到最小的位置。由此，$t[i][j]$可递归地定义为
</code></pre><p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132353232333530393338352e706e67.png?lastModify=1746948169" alt="image-20211125223509385" />
      
    </figure>
</p>
<p>那么代码如下，和矩阵乘法是类似的处理方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">Dynamic</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">demo03</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">w</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">minWeightTriangulation</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">partitionIndex</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//initialize</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">minValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">currValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="n">currValue</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minValue</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">minValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currValue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">partitionIndex</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">3.多边形游戏 
    <div id="3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	多边形游戏是一个单人玩的游戏，开始时有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符“+”或“*”。所有边依次用整数从1到n编号。</p>
<p>1️⃣ 游戏第1步，将一条边删除。</p>
<p>2️⃣ 随后n-1步按以下方式操作：</p>
<p>(1)选择一条边E以及由E连接着的2个顶点V1和V2；</p>
<p>(2)用一个新的顶点取代边E以及由E连接着的2个顶点V1和V2。将由顶点V1和V2的整数值通过边E上的运算得到的结果赋予新顶点。</p>
<p>3️⃣ 最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502110809077.png?lastModify=1746948169" alt="image-20250502110809077" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502123739356.png?lastModify=1746948169" alt="image-20250502123739356" />
      
    </figure>
</p>
<p>先只作证明，具体可以看书。</p>


<h4 class="relative group">4.公园游艇问题(考试难度类似) 
    <div id="4%E5%85%AC%E5%9B%AD%E6%B8%B8%E8%89%87%E9%97%AE%E9%A2%98%E8%80%83%E8%AF%95%E9%9A%BE%E5%BA%A6%E7%B1%BB%E4%BC%BC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E5%85%AC%E5%9B%AD%E6%B8%B8%E8%89%87%E9%97%AE%E9%A2%98%E8%80%83%E8%AF%95%E9%9A%BE%E5%BA%A6%E7%B1%BB%E4%BC%BC" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	<strong>题目描述</strong>：长江游艇俱乐部在长江上设置了n  个游艇出租站{1,2,…,n}。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 i 到游艇出租站 j  之间的租金为r(i,j),1≤i&lt;j≤n。试设计一个算法，计算出从游艇出租站 1 到游艇出租站 n 所需的最少租金。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502124346426.png?lastModify=1746948169" alt="image-20250502124346426" />
      
    </figure>
</p>
<p>思考一下，还是和矩阵连乘的问题是类似的。</p>
<p>1️⃣ 最优解结构</p>
<p>​	r(i,j)表示游艇出租站i直接到j之间的租金，m(i,j)表示从出租站i出发，到达第j站需要的租金 例如m(1,3)就表示从第1站出发，到达第3站所需的租金，而m(1,3)可以有多种租用方案，例如可以1-2.2-3与1-3。</p>
<p>假设在第k站换游艇(  i  ≤  k  ≤  j )  ,则有m(i,j)=m(i,k)+m(k,j)，其中m(i,j)的最优解包括m(i,k)与m(k,j)的最优解。</p>
<p>2️⃣ 建立递归关系</p>
<p>由以上分析可知，显然有：</p>
<p><a href="https://camo.githubusercontent.com/8d62e83ad2bd1a9265f06bb1591a18332b278ffc6b06820456ab7e457ada2aa3/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132353233313330323438332e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132353233313330323438332e706e67.png?lastModify=1746948169" alt="image-20211125231302483" />
      
    </figure>
</a></p>
<p>3️⃣ 计算最优值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">cent</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">n</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="c1">//在第k站下</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>构造最优解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">traceBack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="s">&#34;[&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">traceBack</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">traceBack</span><span class="p">(</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="s">&#34;]&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">5.最大子段和 
    <div id="5%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>和最大的一个连续子数组。</p></blockquote>
<p>​	<strong>LeetCode</strong>：https://leetcode.cn/problems/maximum-subarray/description/</p>
<p>​	<strong>题目描述</strong>：给定由n个整数（可能为负整数）组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。依此定义，所求的最优值为： <a href="https://camo.githubusercontent.com/660d3586cbe8cf26461b80c0c80a3df32a96ea1aa0d2b8e6077ff9f403c085d6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32636361663339326637376234313537613733323733323363636338303733342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32636361663339326637376234313537613733323733323363636338303733342e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</a></p>
<p>例，序列{-2,11,-4,13,-5,-2}的最大子段和为20。</p>
<p>​	做法：<strong>定义状态 f[i] 表示以 a[i] 结尾的最大子数组和</strong>，不和 i 左边拼起来就是 f[i]=a[i]，和 i 左边拼起来就是 f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 <strong>Kadane</strong> 算法。</p>
<p><a href="https://camo.githubusercontent.com/91faab97f01b82b556107c8b670c48d600659c0f095e91a54bf9c6606bed60ae/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232313534373134322e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232313534373134322e706e67.png?lastModify=1746948169" alt="image-20211129221547142" />
      
    </figure>
</a></p>
<p>由b[j]的定义易知，当b[j-1]&gt;0时，b[j]=b[j-1]+a[j]，否则b[j]=a[j]，故<a href="https://camo.githubusercontent.com/409cdb9a82bb8ebae56c943ce76bf7c77733f6531bc84fdb869e48b7f52b8130/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232313631353032302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232313631353032302e706e67.png?lastModify=1746948169" alt="image-20211129221615020" />
      
    </figure>
</a></p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">maxSubArray</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h5 class="relative group"><strong>最大子段和问题与动态规划算法的推广</strong> 
    <div id="%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E5%B9%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E5%B9%BF" aria-label="Anchor">#</a>
    </span>        
    
</h5>


<h6 class="relative group">1、最大子矩阵和问题 
    <div id="1%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h6>
<p>给定一个m行n列的整数矩阵A，试求矩阵A的一个子矩阵，使其各元素之和为最大。</p>
<blockquote>
<p>把每两行之间的数字相加起来，使之成为一个一维的数组，接着用上面的方法来处理即可，这个问题比较简单。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/3ddfc945052ded69e92c0a11a408c66d67eb6a03049a177266e120bc7ba8620a/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232333830323639352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393232333830323639352e706e67.png?lastModify=1746948169" alt="image-20211129223802695" />
      
    </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 最大子矩阵和
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param m
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param n
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param a
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">MaxSum2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="kt">int</span><span class="o">[][]</span><span class="n">a</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="n">b</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">  </span><span class="c1">//从第i行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="c1">//初始化数组b</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="w">  </span><span class="c1">//到第j行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">]+=</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="p">;</span><span class="c1">//按列取值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">max</span><span class="o">=</span><span class="n">solveByDP</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">max</span><span class="o">&gt;</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">sum</span><span class="o">=</span><span class="n">max</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h6 class="relative group">2.*最大M子段和问题 
    <div id="2%E6%9C%80%E5%A4%A7m%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E6%9C%80%E5%A4%A7m%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h6>
<p>​	<strong>定由n个整数（可能为负数）组成的序列{a1,a2,…,an}，以及一个正整数m，要求确定序列{a1,a2,…,an}的m个不相交子段，使这m个子段的总和达到最大。</strong></p>
<p>设b(i,j)表示数组a的前j项中i个子段和的最大值，且第i个子段含a[j]（1≤i ≤ m，i ≤j ≤n），则计算b(i,j)的递归式为</p>
<p><a href="https://camo.githubusercontent.com/af0096b6c1c742cc734d60d337f01fb0814b7e357aaae27af77559edfc79d135/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393233303131353238342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393233303131353238342e706e67.png?lastModify=1746948169" alt="image-20211129230115284" />
      
    </figure>
</a></p>
<p>初始时</p>
<blockquote>
<p>b(0,j)=0, (1≤j ≤n)</p>
<p>b(i,0)=0, (1≤i ≤m)</p></blockquote>
<p><a href="https://camo.githubusercontent.com/dcc3a0709056fbe3c5bb5fe4a711687c1de532f237fee87ece22e267fb8d1e75/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393233303330383534362e706e67" target="_blank">
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://camo.githubusercontent.com/dcc3a0709056fbe3c5bb5fe4a711687c1de532f237fee87ece22e267fb8d1e75/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393233303330383534362e706e67" alt="image-20211129230308546" />
    
  </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="nf">MaxSum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="n">m</span><span class="o">||</span><span class="n">m</span><span class="o">&lt;</span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">b</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*[</span><span class="n">m</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">//定义二维数组b</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">   </span><span class="c1">//初始值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="c1">//1≤i ≤m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="c1">//j≥i, t&lt;j</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]+</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w">   </span><span class="c1">//i-1≤t&lt;j</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="o">][</span><span class="n">k</span><span class="o">]+</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="o">][</span><span class="n">k</span><span class="o">]+</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w">  </span><span class="c1">//j=i, 每个数都是一个子段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]+</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">sum</span><span class="o">&lt;</span><span class="n">b</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">sum</span><span class="o">=</span><span class="n">b</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">6.*图像压缩问题（没看懂） 
    <div id="6%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98%E6%B2%A1%E7%9C%8B%E6%87%82" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#6%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98%E6%B2%A1%E7%9C%8B%E6%87%82" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>我没看懂在干嘛，先放着吧。</p></blockquote>
<p>​	计算机中常用像素点灰度值序列{𝑝1,𝑝2,&hellip;,𝑝𝑛}表示图像，𝑝𝑖表示像素点i的灰度值。灰度值的范围常为0~255，需要用8位来表示。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502133107370.png?lastModify=1746948169" alt="image-20250502133107370" />
      
    </figure>
</p>
<p>​	<strong>图像的变位压缩存储格式</strong>将所给的像素点序列{𝑝1,𝑝2,&hellip;,𝑝𝑛}分割成<strong>m个连续段</strong>{𝑆1,𝑆2,&hellip;,𝑆𝑚}。第i个像素段<strong>Si中有l[i]个像素</strong>，且该段中每个像素都<strong>只用b[i]位</strong>表示。需用3位表示b[i]，如果限制1≤l[i]≤255，则需要用8位表示l[i]，因此第i个像素段所需的存储空间为l[i]*b[i]+11。——即一段中最多有255个像素，用8位二进制表示</p>
<p>整个像素序列的存储空间为</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31333739633436303736373834333538393464386331323162353933383061622e706e67.png?lastModify=1746948169" alt="在这里插入图片描述" />
      
    </figure>
</p>
<p><strong>问题描述</strong>：确定像素序列{p1,p2,&hellip;,pn}的一个最优分段，使得依此分段所需的存储空间最小。其中0≤pi ≤255，1 ≤i ≤n，每个分段的长度不超过255位。</p>


<h5 class="relative group">1️⃣ 最优子结构 
    <div id="1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>设l[i],b[i]，1≤i ≤m是{𝑝1,𝑝2,…,𝑝𝑛}的最优分段。显而易见，l[1],b[1]是{𝑝1,𝑝2,…,𝑝𝑙[1]}的最优分段，且l[i],b[i]， 2≤i ≤m是</p>
<p>{𝑝𝑙[1]+1,…,𝑝𝑛}的最优分段。即图象压缩问题满足最优子结构性质。</p>


<h5 class="relative group">2️⃣ 递归计算最优值 
    <div id="2-%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BC%98%E5%80%BC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2-%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BC%98%E5%80%BC" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>设s[i]，1≤i≤n，是像素序列{𝑝1,𝑝2,…,𝑝𝑖}的最优分段所需的存储位数。由最优子结构性质易知：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250502134028279.png?lastModify=1746948169" alt="image-20250502134028279" />
      
    </figure>
</p>
<p>举例：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136313630343937322e706e67.png?lastModify=1746948169" alt="image-20211130161604972" />
      
    </figure>
</p>


<h5 class="relative group">3️⃣ 构造最优解 
    <div id="3-%E6%9E%84%E9%80%A0%E6%9C%80%E4%BC%98%E8%A7%A3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3-%E6%9E%84%E9%80%A0%E6%9C%80%E4%BC%98%E8%A7%A3" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>算法用l[i],b[i]记录了最优分段所需的信息。</p>
<p>最优分段的最后一段的段长和像素位数分别存储于l[n]和b[n]中，其前一段的段长度和像素位数存储于l[n-l[n]]和b[n-l[n]]中。依此类推，可在O(n)时间内构造出相应的最优解</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 计算十进制数i所需的二进制位数
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param i
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">k</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param n
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param l [p1:pi]的最优分段中最后1个分段的像素个数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param p p[p1:pn]，像素点灰度值序列
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param s 像素序列[p1:pi]的最优分段所需的存储位数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param b 像素p[i]所需的存储位数
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Compress</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">Lmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">255</span><span class="p">;</span><span class="c1">//每个分段的长度不超过255位</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">11</span><span class="p">;</span><span class="c1">//分段段头所需的位数,表示一个段的附加信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">//[p1:pi]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">bmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bmax</span><span class="p">;</span><span class="w"> </span><span class="c1">//k=1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">l</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Lmax</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">//最后的1个分段中有j个像素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bmax</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">bmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="c1">//这一段中的最大位数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bmax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//找到更好的分段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bmax</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">l</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">header</span><span class="p">;</span><span class="c1">//加上额外开销</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Traceback</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Traceback</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="c1">// 重新为s[]数组赋值，用来存储分段位置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Output</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;The optimal value is &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">m</span><span class="o">=</span><span class="n">Traceback</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">);</span><span class="w">  </span><span class="c1">//m:分段数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s</span><span class="o">[</span><span class="n">m</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">  </span><span class="c1">//m个分段像素的累积和，Traceback算到m-1个</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Decompose into &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; segments&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">l</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="c1">//计算第j个分段像素个数: l[j]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">b</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="n">s</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span><span class="p">;</span><span class="w">  </span><span class="c1">//计算第j个分段所需的存储位数: b[j]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">l</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">0</span><span class="p">,</span><span class="n">10</span><span class="p">,</span><span class="n">12</span><span class="p">,</span><span class="n">15</span><span class="p">,</span><span class="n">255</span><span class="p">,</span><span class="n">2</span><span class="p">,</span><span class="n">1</span><span class="p">};</span><span class="c1">//第一位不算</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Compress</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Output</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">-</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">7.*最长公共子序列 
    <div id="7%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#7%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>LeetCode:https://leetcode.cn/problems/longest-common-subsequence/description/</p>
<p>​	若给定序列𝑋=𝑥1,𝑥2,…,𝑥𝑚，则另一序列𝑍=𝑧1,𝑧2,…,𝑧𝑘，是X的子序列是指存在一个严格递增下标序列𝑖1,𝑖2,…,𝑖𝑘使得对于所有j=1,2,…,k有：𝑧𝑗=𝑥𝑖𝑗。例如，序列Z={B, C, D, B}是序列X={A, B, C , B, D, A, B}的子序列，相应的递增下标序列为{2, 3, 5,  7}。给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例：X={A,B,C,B,D,A,B}，Y={B,D,C,A,B,A}，则序列{B,C,A}是X和Y的一个公共子序列。</p>


<h5 class="relative group">1）最长公共子序列的结构 
    <div id="1%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则</p>
<p>⑴若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列。</p>
<p>⑵若xm≠yn且zk≠xm，则Z是Xm-1和Y的最长公共子序列。</p>
<p>⑶若xm≠yn且zk≠yn，则Z是X和Yn-1的最长公共子序列。</p>
<p>由此可见，2个序列的最长公共子序列包含了这2个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。</p>


<h5 class="relative group">2）子问题的递归结构 
    <div id="2%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用𝑐[𝑖][𝑗]记录序列的最长公共子序列的长度。其中，</p>
<p>X  i  =      x    1    ,    x    2    ,    …    ,    x    i    ；  Y  j  =      y    1    ,    y    2    ,    …    ,    y    j 。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时𝐶[𝑖][𝑗]=0。其它情况下，由最优子结构性质可建立递归关系如下：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313132393230333734333135372e706e67.png?lastModify=1746948169" alt="image-20211129203743157" />
      
    </figure>
</p>


<h5 class="relative group">3）计算最优值 
    <div id="3%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BC%98%E5%80%BC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BC%98%E5%80%BC" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</p>
<p>输入：x,y （序列数组）</p>
<p>输出：</p>
<blockquote>
<p>c  [  i  ]  [  j  ] ，存储x[1:i]和y[1:j]的最长公共子序列的长度；</p>
<p>b  [  i  ]  [  j  ] ，记录上面𝑐[𝑖][𝑗]的值是由哪个子问题的解得到的。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 计算最长公共子序列
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param x 序列数组
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param y 序列数组
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param c 存储x[1:i]和y[1:j]的最长公共子序列的长度
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param b 记录上面c[i][j]的值是由哪个子问题的解得到的
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w">  </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">LCSLength</span><span class="p">(</span><span class="kt">char</span><span class="o">[]</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">[]</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">c</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="c1">//第一个条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//表示Xi和Yi的最长公共子序列是由Xi-1和Yi-1的最长公共子序列在尾部加上xi所得到的。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//表示Xi和Yi的最长公共子序列与Xi-1和Yi的最长公共子序列相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">//表示Xi和Yi的最长公共子序列与Xi和Yj-1的最长公共子序列相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>算法耗时O(mn)</p>


<h5 class="relative group">4）构造最长公共子序列 
    <div id="4%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>从𝑏[𝑚][𝑛] 开始，依其值在数组b中搜索。</p>
<p>b  [  i  ]  [  j  ] 的值为：</p>
<blockquote>
<p>1，表示Xi和Yi的最长公共子序列是由Xi-1和Yi-1的最长公共子序列在尾部加上xi所得到的。</p>
<p>2，表示Xi和Yi的最长公共子序列与Xi-1和Yi的最长公共子序列相同。</p>
<p>3， 表示Xi和Yi的最长公共子序列与Xi和Yi-1的最长公共子序列相同。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">LCS</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">[]</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LCS</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">m</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LCS</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LCS</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h5 class="relative group">5）算法的改进 
    <div id="5%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	在算法lcsLength和lcs中，可进一步将数组b省去。事实上，数组元素𝑐[𝑖][𝑗]的值仅由，和𝑐[𝑖−1][𝑗−1]，𝑐[𝑖−1][𝑗]和𝑐[𝑖][𝑗−1]这3个数组元素的值所确定。对于给定的数组元素𝑐[𝑖][𝑗]，可以不借助于数组b而仅借助于c本身在O(1)时间内确定𝑐[𝑖][𝑗]的值是由，和𝑐[𝑖−1][𝑗−1]，𝑐[𝑖−1][𝑗]和𝑐[𝑖][𝑗−1]中哪一个值所确定的。</p>
<p>​	如果只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。事实上，在计算𝑐[𝑖][𝑗]时，只用到数组c的第i行和第i-1行。因此，用2行的数组空间就可以计算出最长公共子序列的长度。进一步的分析还可将空间需求减至O(min(m,n))。</p>


<h4 class="relative group">8.电路布线问题 
    <div id="8%E7%94%B5%E8%B7%AF%E5%B8%83%E7%BA%BF%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#8%E7%94%B5%E8%B7%AF%E5%B8%83%E7%BA%BF%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>LeetCode类似问题：https://leetcode.cn/problems/uncrossed-lines/description/</p>
<blockquote>
<p>LCS的变种。</p></blockquote>
<p>​	在一块电路板的上、下2端分别有n个接线柱。根据电路设计，要求用导线(i,π(i))将上端接线柱与下端接线柱相连，其中π(i)是{1,2,…,n}的一个排列。导线(i,π(i))称为该电路板上的第i条连线。对于任何1≤i&lt;j≤n，第i条连线和第j条连线相交的充分且必要的条件是π(i)&gt;π(j)。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250503152432186.png?lastModify=1746948169" alt="image-20250503152432186" />
      
    </figure>
</p>
<p>​	电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets={(i,π(i)),1≤i≤n}的<strong>最大不相交子集</strong>。</p>
<p>
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://camo.githubusercontent.com/016ccf16f6f15d1966a9d3ff329fb074f1584a0b5ade2744dfa3509452431a53/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136333531323033312e706e67" alt="image-20211130163512031" />
    
  </figure>
</p>


<h5 class="relative group"><strong>最优子结构性质</strong> 
    <div id="%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>看清楚这里N(i,j)的实际含义。t &lt;= i&hellip;&hellip;</p></blockquote>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250503153749782.png?lastModify=1746948169" alt="image-20250503153749782" />
      
    </figure>
</p>
<blockquote>
<p>考试前再看一下，比较有意思。</p></blockquote>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MNS</span><span class="p">(</span><span class="kt">int</span> <span class="n">C</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="o">**</span><span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//C[i]，即π[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//size[i][j]，N(i,j)的最大不相交子集中连线的数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//i=1，j&lt;π(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//i=1，j&gt;=π(1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//1&lt;i&lt;n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//j&lt;π(i)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//j&gt;=π(i)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">C</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//i=n,j=n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Traceback</span><span class="p">(</span><span class="kt">int</span> <span class="n">C</span><span class="p">[],</span><span class="kt">int</span> <span class="o">**</span><span class="n">size</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">Net</span><span class="p">[],</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//Net[0:m-1]存储MNS(n,n)中的m条连线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>  <span class="c1">//第i条连线∈MNS(n,n)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Net</span><span class="p">[</span><span class="n">m</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>                       <span class="c1">//π[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">//i=1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Net</span><span class="p">[</span><span class="n">m</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">9.01背包问题（重要） 
    <div id="901%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E8%A6%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#901%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E8%A6%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>可以看代码随想录，我不知道为什么课本能写的这么逆天。</p>
<p>但是要理解书上的关于跳跃点的问题。</p>
<p><a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-2.html#%e7%ae%97%e6%b3%95%e5%85%ac%e5%bc%80%e8%af%be" target="_blank">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p></blockquote>
<p>重要：背下来</p>
<p>给定n种物品和一背包。物品i的重量是𝑤𝑖，其价值为𝑣𝑖，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p>
<p>0-1背包问题是一个特殊的整数规划问题</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136343735353130322e706e67.png?lastModify=1746948169" alt="image-20211130164755102" />
      
    </figure>
</p>


<h5 class="relative group">1️⃣ 最优子结构性质（证明题） 
    <div id="1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8%E8%AF%81%E6%98%8E%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8%E8%AF%81%E6%98%8E%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>注意证明的方法和思想。</p></blockquote>
<p>设(y1,y2,&hellip;,yn)是所给问题的一个最优解，则(y2,y3,&hellip;,yn)是下面相应子问题的的一个最优解：</p>
<p><a href="https://camo.githubusercontent.com/a2ccf1b22fe555b2fedfe8dc73338174e5b43cf7d1c8567dcb0af9262ac14277/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353031333330372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353031333330372e706e67.png?lastModify=1746948169" alt="image-20211130165013307" />
      
    </figure>
</a></p>
<p>若不然，设(z2,z3,&hellip;,zn)是上述子问题的一个最优解。</p>
<p><a href="https://camo.githubusercontent.com/f061cac60129d984694f96279d91cf775dc9b331b3f9d1a7f8153c8f9cf26b6c/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353135373938392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353135373938392e706e67.png?lastModify=1746948169" alt="image-20211130165157989" />
      
    </figure>
</a></p>
<p><strong>这说明(y1,z2,&hellip;,zn)是所给问题的一个更优解，从而与(y1,y2,&hellip;,yn)是所给问题的最优解相矛盾。</strong></p>
<blockquote>
<p>在这里反推矛盾，书上这里还写错了，纯垃圾书!</p></blockquote>


<h5 class="relative group">2️⃣ 递归关系 
    <div id="2-%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2-%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>设所给0-1背包问题的子问题的最优值为m(i,j)，即m(i,j)是背包容量为j，可选择物品为<strong>i,i+1,…,n</strong>时0-1背包问题的最优值。<a href="https://camo.githubusercontent.com/bae6f7fae1b534ea69f38319f7d78778c257855f9fcc80c171b4e1aac6272096/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353430373437352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353430373437352e706e67.png?lastModify=1746948169" alt="image-20211130165407475" />
      
    </figure>
</a></p>
<p>由0-1背包问题的最优子结构性质，可以建立计算m(i,j)的递归式如下。</p>
<p><a href="https://camo.githubusercontent.com/75caa9e0b986935613da711f3686877c77a12174a26adc214ce61602086ba016/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353532303636392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313133303136353532303636392e706e67.png?lastModify=1746948169" alt="image-20211130165520669" />
      
    </figure>
</a></p>


<h5 class="relative group">3️⃣ 算法描述 
    <div id="3-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">KnapsackProblem</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//0-1背包问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param v v[1:n]，物品i的价值
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param w w[1:n]，物品i的重量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param c 背包容量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param n
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param m m[i][j]，背包容量为j，可选物品为[i:n]时，0-1背包问题的最优值
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Knapsack</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="n">v</span><span class="p">,</span><span class="kt">int</span><span class="o">[]</span><span class="n">w</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="kt">int</span><span class="o">[][]</span><span class="n">m</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">jMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">w</span><span class="o">[</span><span class="n">n</span><span class="o">]-</span><span class="n">1</span><span class="p">,</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">jMax</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">m</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="c1">//j&lt;=c&amp;&amp;j&lt;w[n]，物品n无法放入背包</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">m</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">v</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="c1">//w[n]&lt;=j&lt;=c，物品n可以放入背包</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="c1">//画边界，从后往前看</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="n">1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">jMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">1</span><span class="p">,</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">jMax</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="c1">//物品i无法放入背包</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">c</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//物品i可放入背包</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">,</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]]+</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">m</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">c</span><span class="o">]=</span><span class="n">m</span><span class="o">[</span><span class="n">2</span><span class="o">][</span><span class="n">c</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">&gt;=</span><span class="n">w</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">m</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">c</span><span class="o">]=</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">c</span><span class="o">]</span><span class="p">,</span><span class="n">m</span><span class="o">[</span><span class="n">2</span><span class="o">][</span><span class="n">c</span><span class="o">-</span><span class="n">w</span><span class="o">[</span><span class="n">1</span><span class="o">]]+</span><span class="n">v</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 求解
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param m
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param w
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param c
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param n
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param x 具体的解
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">TraceBack</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="n">w</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="kt">int</span><span class="o">[]</span><span class="n">x</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">c</span><span class="o">]==</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">c</span><span class="o">]</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">c</span><span class="o">-=</span><span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]=</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">c</span><span class="o">]&gt;</span><span class="n">0</span><span class="p">)</span><span class="o">?</span><span class="n">1</span><span class="p">:</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="n">v</span><span class="o">=</span><span class="p">{</span><span class="n">0</span><span class="p">,</span><span class="n">1</span><span class="p">,</span><span class="n">13</span><span class="p">,</span><span class="n">8</span><span class="p">,</span><span class="n">4</span><span class="p">,</span><span class="n">5</span><span class="p">,</span><span class="n">6</span><span class="p">,</span><span class="n">7</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="n">w</span><span class="o">=</span><span class="p">{</span><span class="n">0</span><span class="p">,</span><span class="n">2</span><span class="p">,</span><span class="n">3</span><span class="p">,</span><span class="n">1</span><span class="p">,</span><span class="n">4</span><span class="p">,</span><span class="n">1</span><span class="p">,</span><span class="n">5</span><span class="p">,</span><span class="n">1</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="n">m</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">c</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Knapsack</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">,</span><span class="n">m</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">TraceBack</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">1</span><span class="p">,</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">&#34; &#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>一维的优化问题：</p>
<blockquote>
<p>以下从代码随想录的网站上复制的</p></blockquote>


<h3 class="relative group">一维dp数组（滚动数组） 
    <div id="%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：dp<a href="typora://app/typemark/window.html#">i</a> = max(dp<a href="typora://app/typemark/window.html#">i - 1</a>, dp<a href="typora://app/typemark/window.html#">i - 1</a>] + value[i]);</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp<a href="typora://app/typemark/window.html#">i</a> = max(dp<a href="typora://app/typemark/window.html#">i</a>, dp<a href="typora://app/typemark/window.html#">i</a>] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<p>读到这里估计大家都忘了 dp<a href="typora://app/typemark/window.html#">i</a>里的i和j表达的是什么了，i是物品，j是背包容量。</p>
<p><strong>dp<a href="typora://app/typemark/window.html#">i</a> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>关于dp数组的定义，我在 <a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank">01背包理论基础</a></p>
<p><a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank"> </a></p>
<p><a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank"> (opens new window)</a> 有详细讲解</p>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol>
<li>一维dp数组的递推公式</li>
</ol>
<p>二维dp数组的递推公式为：  <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p>
<p>公式是怎么来的 在这里 <a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank">01背包理论基础</a></p>
<p><a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank"> </a></p>
<p><a href="https://programmercarl.com/%e8%83%8c%e5%8c%85%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%8001%e8%83%8c%e5%8c%85-1.html" target="_blank"> (opens new window)</a> 有详细讲解。</p>
<p>一维dp数组，其实就上上一层 dp[i-1] 这一层 拷贝的 dp[i]来。</p>
<p>所以在 上面递推公式的基础上，去掉i这个维度就好。</p>
<p>递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></p>
<p>以下为分析：</p>
<p>dp[j]为 容量为j的背包所背的最大价值。</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p><code>dp[j - weight[i]] + value[i]</code> 表示 容量为 [j - 物品i重量] 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp<a href="typora://app/typemark/window.html#">i-1</a>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</span></span></code></pre></div><p>可以看出相对于二维dp数组的写法，就是把dp<a href="typora://app/typemark/window.html#">i</a>中i的维度去掉了。</p>
<ol>
<li>一维dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol>
<li>一维dp数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
</span></span><span class="line"><span class="cl">    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
</span></span><span class="line"><span class="cl">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15  （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp<a href="typora://app/typemark/window.html#">i</a>都是通过上一层即dp<a href="typora://app/typemark/window.html#">i - 1</a>计算而来，本层的dp<a href="typora://app/typemark/window.html#">i</a>并不会被覆盖！</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>


<h4 class="relative group">10.最优二叉搜索树 
    <div id="10%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#10%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>TODO：</p>


<h2 class="relative group">4.贪心算法 
    <div id="4%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<blockquote>
<p>由局部最优推理全局最优，但是结果不一定正确，数学上的证明才能说明最好。</p>
<p>一般来说简单的贪心都会先考虑排序问题。</p></blockquote>


<h4 class="relative group">1.活动安排问题 
    <div id="1%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>活动安排问题：要求高效地安排一系列争用某一公共资源的活动。</p></blockquote>
<table>
  <thead>
      <tr>
          <th>活动序号</th>
          <th><strong>1</strong></th>
          <th><strong>2</strong></th>
          <th><strong>3</strong></th>
          <th><strong>4</strong></th>
          <th><strong>5</strong></th>
          <th><strong>6</strong></th>
          <th><strong>7</strong></th>
          <th><strong>8</strong></th>
          <th><strong>9</strong></th>
          <th><strong>10</strong></th>
          <th><strong>11</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>起始时间</td>
          <td><strong>1</strong></td>
          <td><strong>3</strong></td>
          <td><strong>0</strong></td>
          <td><strong>5</strong></td>
          <td><strong>3</strong></td>
          <td><strong>5</strong></td>
          <td><strong>6</strong></td>
          <td><strong>8</strong></td>
          <td><strong>8</strong></td>
          <td><strong>2</strong></td>
          <td><strong>12</strong></td>
      </tr>
      <tr>
          <td>结束时间</td>
          <td><strong>4</strong></td>
          <td><strong>5</strong></td>
          <td><strong>6</strong></td>
          <td><strong>7</strong></td>
          <td><strong>8</strong></td>
          <td><strong>9</strong></td>
          <td><strong>10</strong></td>
          <td><strong>11</strong></td>
          <td><strong>12</strong></td>
          <td><strong>13</strong></td>
          <td><strong>14</strong></td>
      </tr>
  </tbody>
</table>


<h5 class="relative group">1、问题定义 
    <div id="1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。（临界资源）</p>
<p>​	每个活动<em>i</em>都有一个要求使用该资源的起始时间𝑠𝑖和一个结束时间𝑓𝑖，且𝑠𝑖&lt;𝑓𝑖 。</p>
<p>​	如果选择了活动i，则它在半开时间区间[𝑠𝑖,𝑓𝑖)内占用资源。<strong>若区间与[𝑠𝑖,𝑓𝑖)区间[𝑠𝑗,𝑓𝑗)不相交，则称活动i与活动j是相容的</strong>。即，当𝑠𝑖≥𝑓𝑗或𝑠𝑗≥𝑓𝑖时，活动i与活动j相容，</p>
<p>​	问题就是选择一个由互相兼容的活动组成的最大集合</p>


<h5 class="relative group">2、实现代码 
    <div id="2%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">GreedySelector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">Type</span> <span class="n">s</span><span class="p">[],</span> <span class="n">Type</span> <span class="n">f</span><span class="p">[],</span> <span class="kt">bool</span> <span class="n">A</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">//各活动的起始时间和结束时间存储在数组s和f中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//且按结束时间的非递减排序：f1≤f2≤…≤fn排列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>  <span class="c1">//用集合A存储所选择的活动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">   <span class="c1">//将与j相容的具有最早完成时间的相容活动加入集合A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h5 class="relative group">3、算法分析 
    <div id="3%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	设集合a包含已被选择的活动， 初始时为空。所有待选择的活动按结束时间的非递减顺序排列：𝑓1≤𝑓2≤&hellip;𝑓𝑛</p>
<p>​	变量j指出最近加入a的活动序号。由于按结束时间非递减顺序来考虑各项活动的，所以𝑓𝑗总是a中所有活动的最大结束时间</p>
<p><a href="https://camo.githubusercontent.com/03960b7774c778474e141a738e93f2a371b6eb8bb2a98d5b1a8879defa5242d3/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031313131303032373032312e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031313131303032373032312e706e67.png?lastModify=1746948169" alt="image-20211011110027021" />
      
    </figure>
</a></p>
<p>​	由于输入活动是以完成时间的非递减排列，所选择的下一个活动总是可被合法调度的活动中具有最早结束时间的那个，所以算法是一个**“贪心的”选择**，即使得使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</p>


<h5 class="relative group">4、复杂性分析 
    <div id="4%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	算法GreedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间就可安排n个活动，使最多的活动能相容地使用公共资源。 如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p>


<h5 class="relative group">5、贪心选择性质和最优子结构性质证明 
    <div id="5%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E5%92%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8%E8%AF%81%E6%98%8E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8%E5%92%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8%E8%AF%81%E6%98%8E" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>还是注意贪心的证明的方法。</p></blockquote>
<p>​	设集合E={1，2，…，n}为所给的活动集合。由于E中活动按结束时间的非减序排列，故活动1有最早完成时间。</p>
<p><strong>证明I：活动安排问题有一个最优解以贪心选择开始，即该最优解中包含活动1。</strong></p>
<p><a href="https://camo.githubusercontent.com/46cda325dab2a309e1814a491164a557abb88fb350d78417d300fe33396c9cf0/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373039323835303639372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373039323835303639372e706e67.png?lastModify=1746948169" alt="image-20211207092850697" />
      
    </figure>
</a></p>
<p><strong>证明II：对集合E中所有与活动1相容的活动进行活动安排求得最优解的子问题。</strong></p>
<p>​	即需证明：若<em>A</em>是原问题的最优解，则<em>A</em>’=<em>A</em>-{1}是活动安排问题<em>E</em>’={<em>i</em>∈<em>E</em>:<em>si</em>≥<em>f</em>1}的最优解。</p>
<blockquote>
<p>非常浅显的证明，考试前看一下。</p></blockquote>
<p>​	<strong>如果能找到*E*’的一个最优解*B*’，它包含比*A*’更多的活动，则将活动1加入到*B*’中将产生*E*的一个解*B*，它包含比*A*更多的活动。这与*A*的最优性矛盾。</strong></p>
<p>​	结论：每一步所做的贪心选择问题都将问题简化为一个更小的与原问题具有相同形式的子问题。</p>


<h4 class="relative group">2.01背包问题 
    <div id="201%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#201%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装入背包。 此问题的形式化描述为，给定𝑐&gt;0,𝑤𝑖&gt;0,𝑣𝑖&gt;0,1≤𝑖≤𝑛，要求找出一个n元0-1向量(𝑥1,𝑥2,..,𝑥𝑛)，其中0≤𝑥𝑖≤1,1≤𝑖≤𝑛 ，使得对𝑤𝑖𝑥𝑖求和小于等于c ，并且对𝑣𝑖𝑥𝑖求和达到最大。</p>
<p>​	对于0-1背包问题，贪心选择之所以不能得到最优解是因为，在这种情况下，无法保证最终能把背包装满，部分闲置的背包空间会使每千克背包空间的价值降低。</p>


<h5 class="relative group">1、题目描述 
    <div id="1%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	有3种物品，背包的容量为50千克。物品1重10千克，价值60元；物品2重20千克，价值100元；物品3重30千克，价值120元。用贪心算法求背包问题。</p>


<h5 class="relative group">2、基本步骤 
    <div id="2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	首先计算每种物品单位重量的价值𝑣𝑖/𝑤𝑖；</p>
<blockquote>
<p>还是根据这个单位重量进行一个排序。</p></blockquote>
<p>​	然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。</p>
<p>​	若将这种物品全部装入背包后，背包内的物品总重量未超过<em>c</em>，则选择单位重量价值次高的物品并尽可能多地装入背包。依此策略一直地进行下去，直到背包装满为止。</p>


<h5 class="relative group">3、贪心策略 
    <div id="3%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	贪心策略：物品1，6元/千克；物品2，5元/千克；物品3，4元/千克。</p>
<p><a href="https://camo.githubusercontent.com/e0c56bfd3d29ed4f68006acea7c300f8064d0b369a4c0b64322f149b9eca5b60/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373039353134303535302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373039353134303535302e706e67.png?lastModify=1746948169" alt="image-20211207095140550" />
      
    </figure>
</a></p>


<h5 class="relative group">4、算法描述 
    <div id="4%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	该算法前提：所有物品在集合中按其单位重量的价值从小到大排列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">float</span> <span class="n">w</span><span class="p">[],</span> <span class="kt">float</span> <span class="n">x</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">sort</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span><span class="c1">//按照单位价值从小到大排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span>  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>  <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//按比例放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>算法Knapspack的主要计算时间在于将各种物品按其单位重量的价值从小到大排序，算法的时间复杂度O(nlogn) 。</p>


<h4 class="relative group">3.HaffMan编码 
    <div id="3haffman%E7%BC%96%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3haffman%E7%BC%96%E7%A0%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>7分简答题</strong></p>
<blockquote>
<p>学过数据结构就比较简单。</p></blockquote>
<p>​	哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间。</p>
<p>​	哈夫曼编码算法是用字符在文件中出现的频率表来建立一个用0,1串表示各字符的最优表示方式。</p>
<p>​	编码目标：给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>


<h5 class="relative group">1、前缀码(考点) 
    <div id="1%E5%89%8D%E7%BC%80%E7%A0%81%E8%80%83%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E5%89%8D%E7%BC%80%E7%A0%81%E8%80%83%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	定义：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。这种编码称为前缀码。</p>
<p>​	编码的前缀性质可以使译码方法非常简单。由于任一字符的代码都不是其他字符代码的前缀，从编码文件中不断取出代表某一字符的前缀码，转换为原字符，即可逐个译出文件中的所有字符。</p>
<blockquote>
<p>规定一下，小的数字放在二叉树的左子结点，大的数字放在二叉树的右边子结点，左边是0,右边是1。</p></blockquote>
<table>
  <thead>
      <tr>
          <th></th>
          <th><strong>a</strong></th>
          <th><strong>b</strong></th>
          <th><strong>c</strong></th>
          <th><strong>d</strong></th>
          <th><strong>e</strong></th>
          <th><strong>f</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>频率</td>
          <td>45</td>
          <td>13</td>
          <td>12</td>
          <td>16</td>
          <td>9</td>
          <td>5</td>
      </tr>
      <tr>
          <td>定长码</td>
          <td>000</td>
          <td>001</td>
          <td>010</td>
          <td>011</td>
          <td>100</td>
          <td>101</td>
      </tr>
      <tr>
          <td>变长码</td>
          <td>0</td>
          <td>101</td>
          <td>100</td>
          <td>111</td>
          <td>1101</td>
          <td>1100</td>
      </tr>
  </tbody>
</table>
<p>给定序列：001011101，可以唯一的分解为0，0，101，1101，编译为aabe</p>


<h5 class="relative group">2、问题分 
    <div id="2%E9%97%AE%E9%A2%98%E5%88%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E9%97%AE%E9%A2%98%E5%88%86" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	译码过程需要方便地取出编码的前缀，因此需要一个表示前缀码的合适的数据结构。</p>
<p>​	用<strong>二叉树</strong>作为前缀编码的数据结构。在表示前缀码的二叉树中，树叶代表给定的字符，并将每个字符的前缀码看作是从树根到代表该字符的树叶的一条道路。代码中每一位的0或1分别作为指示某结点到其左儿子或右儿子的“路标”。</p>


<h5 class="relative group">3、前缀码的二叉树表示 
    <div id="3%E5%89%8D%E7%BC%80%E7%A0%81%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E5%89%8D%E7%BC%80%E7%A0%81%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p><a href="https://camo.githubusercontent.com/fff4da95c128e4dadeb3827e8e89ae3ef709c1cee7b0106edf91cfdb7dbcbd38/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031313131343833353832302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031313131343833353832302e706e67.png?lastModify=1746948169" alt="image-20211011114835820" />
      
    </figure>
</a></p>


<h5 class="relative group">4、构造哈夫曼编码(考点) 
    <div id="4%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%80%83%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%80%83%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。</p>
<p>​	编码字符集中每一字符<em>c</em>的频率是<em>f</em>(<em>c</em>)。以<em>f</em>为键值的优先队列Q用以在作贪心选择时有效地确定算法当前要合并的两棵具有最小频率的树。一旦两棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的两棵树的频率之和，并将新树插入优先队列Q中，再进行新的合并。</p>
<p><a href="https://camo.githubusercontent.com/f49d8bde074783c0d45fb404054bbac68ff62fb93f22d13c852901a4eee63483/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038313031373136342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038313031373136342e706e67.png?lastModify=1746948169" alt="image-20211013081017164" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/ed7b043aa0433feaea84ca805124953395ecacc989107c25ab3e6cea651e8d73/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373130343230373830362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373130343230373830362e706e67.png?lastModify=1746948169" alt="image-20211207104207806" />
      
    </figure>
</a></p>
<p>•由于字符集中有6个字符，优先队列的大小初始为6，总共用5次合并得到最终的编码树T。</p>
<p>• 每次合并使Q的大小减1，最终得到的树就是最优前缀编码：哈夫曼编码树，每个字符的编码由树T的根到该字符的路径上各边的标号所组成。</p>
<p>​	1️⃣ 算法首先用字符集C中每一个字符<em>c</em>的频率<em>f</em>(<em>c</em>)初始化优先队列Q。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。</p>
<p>​	2️⃣ 然后不断地从优先队列Q中取出具有<strong>最小频率的两棵树</strong>x和y，将它们合并为一棵新树z。z的频率是x和y的频率之和。</p>
<p>​	3️⃣ 新树z以x为其左儿子，y为其右儿子（也可以y为其左儿子，x为其右儿子。不同的次序将产生不同的编码方案，但平均码长是相同的）。经过n-1次的合并后，优先队列中只剩下一棵树，即所要求的树T。</p>


<h4 class="relative group">4.Dijkstra算法&mdash;单源最短路径 
    <div id="4dijkstra%E7%AE%97%E6%B3%95%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4dijkstra%E7%AE%97%E6%B3%95%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	给定<strong>带权有向图</strong>G=(V,E)，其中每条边的权是非负实数。</p>
<p>​	给定V中的一个顶点，称为源。</p>
<p>​	现在要计算从源到其他所有各顶点的最短路径长度。这里的路径长度是指路径上各边权之和，这个问题通常称为单源最短路径问题。</p>
<p><a href="https://camo.githubusercontent.com/7d69b58537e404b4ff3905262b88fdf20bbb3dbb37c36382a03a63692f6cff40/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373131303134383632352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373131303134383632352e706e67.png?lastModify=1746948169" alt="image-20211207110148625" />
      
    </figure>
</a></p>
<p><strong>考点</strong>：画一个迭代矩阵</p>


<h5 class="relative group">算法基本思想 
    <div id="%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	Dijkstra算法是求解单源最短路径问题的一个<strong>贪心算法</strong>。</p>
<p>​	基本思想：设置一个顶点集合S ，并不断地作贪心选择来扩充这个集合。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。</p>
<p>Dijkstra算法通过分步方法求出最短路径。</p>
<blockquote>
<p>每一步产生一个到达新的目的顶点的最短路径。</p>
<p>下一步所能达到的目的顶点通过这样的贪心准则选取：在还未产生最短路径的顶点中，选择路径长度最短的目的顶点。</p>
<p>也就是说， Dijkstra算法按路径长度顺序产生最短路径。</p></blockquote>


<h5 class="relative group">Dijkstra算法的执行 
    <div id="dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>1️⃣ 设置一个顶点集合S。一个顶点属于集合 S 当且仅当从源到该顶点的最短路径长度已知。</p>
<p>2️⃣ 初始时，S中仅含有源。</p>
<p>3️⃣ 设u是G的某一个顶点，把从源到u且<strong>中间只有经过S中顶点的路称为从源到u的特殊路径</strong>，并且用<strong>数组dis</strong>t来记录当前每个顶点所对应的<strong>最短特殊路径长度</strong>。</p>
<p>4️⃣ Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到 S 中，同时对数组dist作必要的修改。</p>
<p>5️⃣ 一旦S包含了所有V中顶点，dist就<strong>记录了从源到所有其他顶点之间的最短路径长度。</strong></p>


<h5 class="relative group">过程说明 
    <div id="%E8%BF%87%E7%A8%8B%E8%AF%B4%E6%98%8E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%87%E7%A8%8B%E8%AF%B4%E6%98%8E" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>已知：带权有向图</p>
<p>V = { v1, v2, v3, v4, v5 }</p>
<p>E = { &lt; v1, v2 &gt;, &lt; v1, v4 &gt;, &lt; v1, v5  &gt;, &lt; v2, v3 &gt;, &lt; v3, v5 &gt;, &lt; v4, v3 &gt;, &lt; v4, v5  &gt; }</p>
<p>设为v1源点，求其到其余顶点的最短路径。</p>
<p><a href="https://camo.githubusercontent.com/73d76f18c350e4f4efccb2630c6bcfe8e81f6f684135b065d4fea2d616d4f867/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373131313634303537342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373131313634303537342e706e67.png?lastModify=1746948169" alt="image-20211207111640574" />
      
    </figure>
</a></p>
<p>其中，没有特殊路径的顶点用maxint表示其最短特殊路径长度</p>


<h5 class="relative group">迭代矩阵(考点) 
    <div id="%E8%BF%AD%E4%BB%A3%E7%9F%A9%E9%98%B5%E8%80%83%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%AD%E4%BB%A3%E7%9F%A9%E9%98%B5%E8%80%83%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>可能会画这样的图，数据结构让画过。</p></blockquote>
<table>
  <thead>
      <tr>
          <th><strong>迭代</strong></th>
          <th><strong>S</strong></th>
          <th><strong>u</strong></th>
          <th><strong>dist[2]</strong></th>
          <th><strong>dist[3]</strong></th>
          <th><strong>dist[4]</strong></th>
          <th><strong>dist[5]</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>初始</strong></td>
          <td><strong>{1}</strong></td>
          <td><strong>-</strong></td>
          <td><strong>10</strong></td>
          <td><strong>maxint</strong></td>
          <td><strong>30</strong></td>
          <td><strong>100</strong></td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>{1,2}</strong></td>
          <td><strong>2</strong></td>
          <td><strong>10</strong></td>
          <td><strong>60</strong></td>
          <td><strong>30</strong></td>
          <td><strong>100</strong></td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td><strong>{1,2,4}</strong></td>
          <td><strong>4</strong></td>
          <td><strong>10</strong></td>
          <td><strong>50</strong></td>
          <td><strong>30</strong></td>
          <td><strong>90</strong></td>
      </tr>
      <tr>
          <td><strong>3</strong></td>
          <td><strong>{1,2,4,3}</strong></td>
          <td><strong>3</strong></td>
          <td><strong>10</strong></td>
          <td><strong>50</strong></td>
          <td><strong>30</strong></td>
          <td><strong>60</strong></td>
      </tr>
      <tr>
          <td><strong>4</strong></td>
          <td><strong>{1,2,4,3,5}</strong></td>
          <td><strong>5</strong></td>
          <td><strong>10</strong></td>
          <td><strong>50</strong></td>
          <td><strong>30</strong></td>
          <td><strong>60</strong></td>
      </tr>
  </tbody>
</table>
<p>​	按长度顺序产生最短路径时，下一条最短路径总是由一条已产生的最短路径加上一条边形成。</p>
<p>没有优化的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define N 510
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">grid</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">isInSet</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">minLen</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dij</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">minLen</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">minLen</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">isInSet</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">isInSet</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">minLen</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//遍历找到距离最小的点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isInSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">minLen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minLen</span><span class="p">[</span><span class="n">t</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">                <span class="n">t</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">isInSet</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//用t更新到所有其他点的距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">minLen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minLen</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">minLen</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">minLen</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x3f3f3f3f</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">minLen</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">grid</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">z</span><span class="p">);</span><span class="c1">//去重复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">dij</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用堆来做优化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 稀疏图用邻接表来存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ne</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">w</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">// 用来存权重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">st</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">// 如果为true说明这个点的最短路径已经确定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 并标记st为true，所以下一次弹出3+x会continue不会向下执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="n">h</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dijkstra</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dist</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">PII</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">PII</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">PII</span><span class="o">&gt;&gt;</span> <span class="n">heap</span><span class="p">;</span> <span class="c1">// 定义一个小根堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">heap</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span> <span class="c1">// 这个顺序不能倒，pair排序时是先根据first，再根据second，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// 这里显然要根据距离排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PII</span> <span class="n">k</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 取不在集合S中距离最短的点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ver</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">ver</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">st</span><span class="p">[</span><span class="n">ver</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">ver</span><span class="p">];</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// i只是个下标，e中在存的是i这个下标对应的点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">heap</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x3f3f3f3f</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">5.最小生成树MST(算法大意要描述) 
    <div id="5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst%E7%AE%97%E6%B3%95%E5%A4%A7%E6%84%8F%E8%A6%81%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst%E7%AE%97%E6%B3%95%E5%A4%A7%E6%84%8F%E8%A6%81%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h4>


<h5 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>设G=(V,E)是<strong>无向带权连通图</strong>，即一个网络。</p>
<p>E中每条边(v,w)的权为𝑐[𝑣][𝑤]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。</p>
<p>生成树上各边权的总和称为该生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树。</p>
<p>网络的最小生成树在实际中有广泛应用。</p>
<p>例如，在设计通信网络时，用图的顶点表示城市，用边(v,w)的权𝑐[𝑣][𝑤]表示建立城市v和城市w之间的通信线路所需的费用，则最小生成树就给出了建立通信网络的最经济的方案。</p>


<h5 class="relative group">2、贪心法求解准则 
    <div id="2%E8%B4%AA%E5%BF%83%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%86%E5%88%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E8%B4%AA%E5%BF%83%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%86%E5%88%99" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>根据最优量度标准，算法的每一步从图中选择一条符合准则的边，共选择n-1条边，构成无向连通图的一棵生成树。</p>
<p>贪心法求解的关键：该量度标准必须足够好。它应当保证依据此准则选出n-1条边构成原图的一棵生成树，必定是<strong>最小代价生成树。</strong></p>


<h5 class="relative group">3、prim算法 
    <div id="3prim%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3prim%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>​	MST（Minimum Spanning Tree，最小生成树）问题有两种通用的解法，Prim算法就是其中之一，它是<strong>从点的方面</strong>考虑构建一颗MST，大致思想是：设图G顶点集合为U，首先<strong>任意选择图G中的一点作为起始点a，将该点加入集合V，再从集合U-V中找到另一点b使得点b到V中任意一点的权值最小，此时将b点也加入集合V</strong>；以此类推，现在的集合V={a，b}，再从集合U-V中找到另一点c使得点c到V中任意一点的权值最小，此时将c点加入集合V，直至所有顶点全部被加入V，此时就构建出了一颗MST。因为有N个顶点，所以该MST就有N-1条边，每一次向集合V中加入一个点，就意味着找到一条MST的边。</p></blockquote>
<p>详解请参考https://blog.csdn.net/yeruby/article/details/38615045</p>
<p><strong>考点</strong>：<strong>算法思想与生成顺序方法说明</strong></p>
<p>Kruskal算法的贪心准则：按边代价的非减次序考察E中的边，从中选择一条代价最小的边e=(u,v)。这种做法使得算法在构造生成树的过程中，当前子图不一定是连通的。</p>
<p><strong>算法思想——从点出发</strong></p>
<p><a href="https://camo.githubusercontent.com/b35ca02816886d387bb7d1c455b98ef19bfff818894754ed811da65736eb7e35/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373139323833323333382e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373139323833323333382e706e67.png?lastModify=1746948169" alt="image-20211207192832338" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/807c89b33d15647edf6a77fcdebecf3c4ca078c59d62083d458b5a7810154614/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373139333031353432322e706e67" target="_blank">
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://camo.githubusercontent.com/807c89b33d15647edf6a77fcdebecf3c4ca078c59d62083d458b5a7810154614/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373139333031353432322e706e67" alt="image-20211207193015422" />
    
  </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Prim</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">Type</span> <span class="o">**</span><span class="n">c</span><span class="p">){</span><span class="c1">//c[i][j]为边(i,j)的权值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">TE</span><span class="o">=</span><span class="err">Ø</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">U</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">U</span><span class="o">!=</span><span class="n">V</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">=</span><span class="n">u属于U且v属于V</span><span class="o">-</span><span class="n">U的最小权边</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">		<span class="n">TE</span><span class="o">=</span><span class="n">TE</span><span class="err">∪</span><span class="p">{(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">		<span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="err">∪</span><span class="p">{</span><span class="n">v</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Prim算法的时间复杂度为𝑂(𝑛2)</p>


<h5 class="relative group">4、Kruskal算法 
    <div id="4kruskal%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4kruskal%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>从边的角度出发解决问题。</p></blockquote>
<p>详情请看https://www.cnblogs.com/fzl194/p/8723325.html</p>
<p><strong>算法思想——从边出发</strong></p>
<p>1️⃣设连通网  N = (V, E )，令最小生成树初始状态为只有 n 个顶点而无边的非连通图  T=(V, { })，每个顶点自成一个连通分量。</p>
<p>2️⃣在 E 中选取代价最小的边，若该边依附 的顶点落在 T 中相同的连通分量上（即： 不能形成环），则将此边加入到 T 中；否 则，舍去此边，选取下一条代价最小的边。</p>
<p>3️⃣ 依此类推，直至 T 中所有顶点都在同一 连通分量上为止。</p>
<p><a href="https://camo.githubusercontent.com/86c6b33be2ec0322b8a5a17ef899546e93bf48aae697d314e06a6a966335d886/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038333335353033372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038333335353033372e706e67.png?lastModify=1746948169" alt="image-20211013083355037" />
      
    </figure>
</a></p>
<p>Kruskal算法的时间复杂度为𝑂(𝑛𝑙𝑜𝑔𝑛)</p>


<h4 class="relative group">6.*多机调度问题 
    <div id="6%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#6%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>近似算法，最长的最先开始处理即可。</p></blockquote>


<h5 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。约定，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断处理。作业不能拆分成更小的子作业。</p>
<p>这个问题是NP完全问题，到目前为止还没有有效的解法。对于这一类问题,用贪心选择策略有时可以设计出较好的<strong>近似算法</strong>。</p>


<h5 class="relative group">2、算法思想 
    <div id="2%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	采用<strong>最长处理时间作业优先</strong>的贪心选择策略可以设计出解多机调度问题的较好的近似算法。 按此策略，当𝑛≤𝑚时，只要将机器i的[0, ti]时间区间分配给作业i即可，算法只需要O(1)时间。 当𝑛&gt;𝑚 时，<strong>首先将n个作业依其所需的处理时间从大到小排序。然后依此顺序将作业分配给空闲的处理机</strong>。算法所需的计算时间为O(nlogn)。</p>


<h5 class="relative group">3、举例说明 
    <div id="3%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	设7个独立作业{1,2,3,4,5,6,7}由3台机器M1，M2和M3加工处理。各作业所需的处理时间分别为{2,14,4,16,6,5,3}。按算法greedy产生的作业调度如下图所示，所需的加工时间为17。</p>
<p><a href="https://camo.githubusercontent.com/8d7beffe79aa8757efb3a9b80926d4f00cfda387bb45f22ec7cd805fa012b5f6/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038353530323030382e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031333038353530323030382e706e67.png?lastModify=1746948169" alt="image-20211013085502008" />
      
    </figure>
</a></p>


<h2 class="relative group">5.回溯算法 
    <div id="5%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://camo.githubusercontent.com/c6e439814af96ceb16c474042e8eac5f9bac0e990ed74ef543d99d42fd28454d/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373230313934393534362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373230313934393534362e706e67.png?lastModify=1746948169" alt="image-20211207201949546" />
      
    </figure>
</a></p>
<p><strong>填空题会有代码填空，大题会手动回溯</strong></p>


<h3 class="relative group">学习要点 
    <div id="%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>理解回溯法的深度优先搜索策略。</p>
<p>掌握用回溯法解题的算法框架</p>
<p>（1）递归回溯</p>
<p>（2）迭代回溯</p>
<p>（3）<strong>子集树</strong>算法框架</p>
<p>（4）<strong>排列树</strong>算法框架</p>


<h3 class="relative group">5.1 回溯法的算法框架 
    <div id="51-%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#51-%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>​	回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于<strong>解一些组合数相当大的问题。</strong></p>
<p>​	回溯法在问题的解空间树中，按<strong>深度优先</strong>策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>


<h4 class="relative group">1、问题的解空间 
    <div id="1%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>用回溯法解问题时，应明确定义<strong>问题的解空间</strong>。</p>
<p>解空间往往用向量集表示。</p>
<p>问题的解向量：回溯法希望一个问题的解能够表示成一个n元式(x1,x2,…,xn)的形式。</p>
<blockquote>
<p><strong>显约束</strong>：对分量xi的取值限定。</p>
<p><strong>隐约束</strong>：为满足问题的解而对不同分量之间施加的约束。</p>
<p><strong>解空间</strong>：对于问题的一个实例，解向量满足<strong>显式约束</strong>条件的所有多元组，构成了该实例的一个解空间。</p></blockquote>


<h4 class="relative group">2、回溯的基本思想 
    <div id="2%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>扩展结点</strong>：一个正在产生儿子的结点称为扩展结点。</p>
<p><strong>活结点</strong>：一个自身已生成但其儿子还没有全部生成的节点称做活结点。</p>
<p><strong>死结点</strong>：一个所有儿子已经产生的结点称做死结点。</p>
<p><strong>深度优先的问题状态生成法</strong>：如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）。</p>
<blockquote>
<p>所以回溯法中一个节点是可以多次成为一个扩展节点但是分支限界法一个节点最多仅有一次机会。</p></blockquote>
<p><strong>宽度优先的问题状态生成法</strong>：在一个扩展结点变成死结点之前，它一直是扩展结点。</p>
<p>回溯法从开始结点（根结点）出发，以<strong>深度优先方式</strong>搜索整个解空间。</p>
<p><strong>基本思想</strong></p>
<blockquote>
<p>1️⃣ 针对所给问题，定义问题的解空间；</p>
<p>2️⃣ 确定易于搜索的解空间结构；</p>
<p>3️⃣ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p>
<blockquote>
<p>常用剪枝函数：（这里可能会考察定义）</p>
<p>用<strong>约束函数</strong>在<strong>扩展结点处剪去不满足约束的子树</strong>；</p>
<p>用<strong>限界函数</strong>剪去<strong>得不到最优解的子树</strong>。</p></blockquote></blockquote>


<h4 class="relative group">3、递归回溯——背诵 
    <div id="3%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%83%8C%E8%AF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E8%83%8C%E8%AF%B5" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">Backtrack</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="c1">//t为递归深度</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">//记录或输出可靠解x，x为数组</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//f(n,t)表示在当前扩展结点处未搜索过的子树的起始编号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//g(n,t)为终止编号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]=</span><span class="n">h</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">//h(i)表示当前扩展结点处x[t]的第i个可选值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constraint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Bound</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="c1">//剪枝</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Backtrack</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。</p>


<h4 class="relative group">4、迭代回溯——会填空即可 
    <div id="4%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF%E4%BC%9A%E5%A1%AB%E7%A9%BA%E5%8D%B3%E5%8F%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF%E4%BC%9A%E5%A1%AB%E7%A9%BA%E5%8D%B3%E5%8F%AF" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">IterativeBacktrack</span><span class="w"> </span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]=</span><span class="n">h</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constraint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Bound</span><span class="p">(</span><span class="n">t</span><span class="p">)){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">solution</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">   </span><span class="c1">//判断是否已得到可行解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">t</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">           </span><span class="n">t</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>f(n,t)表示在当前扩展结点处未搜索过的子树的起始编号</p>
<p>g(n,t)为终止编号</p>
<p>h(i)表示当前扩展结点处x[t]的第i个可选值</p>


<h4 class="relative group">5、子集树和排列树(重点) 
    <div id="5%E5%AD%90%E9%9B%86%E6%A0%91%E5%92%8C%E6%8E%92%E5%88%97%E6%A0%91%E9%87%8D%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E5%AD%90%E9%9B%86%E6%A0%91%E5%92%8C%E6%8E%92%E5%88%97%E6%A0%91%E9%87%8D%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。时间复杂度𝛺(2𝑛)。算法描述如下：</p>
<p>LeetCode:https://leetcode.cn/problems/subsets/</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nf">subsets</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">path</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">path</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>类似于伪代码：</p>
<blockquote>
<p>每个代码选和不选。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">Backtrack</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]=</span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constraint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Bound</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Backtrack</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>​	<strong>排列树</strong>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。时间复杂度𝛺(𝑛!)。算法描述如下：</p>
<blockquote>
<p>时间复杂度就是排列的大小Ann = n!。</p></blockquote>
<p>LeetCode:https://leetcode.cn/problems/permutations</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nf">permute</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">nums</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">toList</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">path</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 重点：在基准之后循环，交换，接着继续递归。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>注意这里的两个swap函数。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">Backtrack</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Swap</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constraint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Bound</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Backtrack</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Swap</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h3 class="relative group">5.2 装载问题 
    <div id="52-%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#52-%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>有一批共n个集装箱要装上2艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且∑𝑖=1𝑛𝑤𝑖≤𝑐1+𝑐2，装载问题要求确定是否有一个合理的装载方案可将这些集装箱装上这2艘轮船。如果有，找出一种装载方案。</p>
<p>例如：</p>
<blockquote>
<p>n=3, c1=c2=50，且w=[10,40,40]。</p>
<p>装载方案：</p>
<p>第一艘轮船装集装箱1和2；二艘轮船装集装箱3。</p></blockquote>
<p>如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。(1)首先将第一艘轮船尽可能装满；(2)将剩余的集装箱装上第二艘轮船。将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。</p>


<h4 class="relative group">2、算法分析 
    <div id="2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>解空间：子集树</p>
<p>可行性约束函数(选择当前元素)：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝑐1𝑥𝑖∈0,1</p>
<p><a href="https://camo.githubusercontent.com/6bb519fa580ebb6ec64c42027e6d8a1bf4ea490a0cc4af5850328c2b8143ce7f/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032303038333434323334392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032303038333434323334392e706e67.png?lastModify=1746948169" alt="image-20211020083442349" />
      
    </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Loading</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">T</span> <span class="n">MaxLoading</span><span class="p">(</span><span class="n">T</span> <span class="p">[],</span><span class="n">T</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//集装箱数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>  <span class="c1">//集装箱重量数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">//第1艘轮船的载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">//当前载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">bestw</span><span class="p">;</span> <span class="c1">//当前最优载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Loading</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//搜索第i层结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span> <span class="c1">//到达叶结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">&gt;</span><span class="n">bestw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">bestw</span><span class="o">=</span><span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">+</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">)</span> <span class="c1">//进入左子树，x[i]=1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cw</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//继续搜索下一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cw</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//退出左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//进入右子树，x[i]=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">MaxLoading</span><span class="p">(</span><span class="n">Type</span> <span class="n">w</span><span class="p">[],</span><span class="n">Type</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//返回最优载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Loading</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">;</span> <span class="c1">//初始化X
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">X</span><span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">bestw</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">cw</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">Backtrack</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//从第1层开始搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">X</span><span class="p">.</span><span class="n">bestw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">w</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">};</span> <span class="c1">//下标从1开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="n">MaxLoading</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><p>算法在每个结点处花费O(1)时间，子集树中结点个数为O(2n)，故算法的计算时间为O(2n)。</p>


<h4 class="relative group">3、上界函数 
    <div id="3%E4%B8%8A%E7%95%8C%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E4%B8%8A%E7%95%8C%E5%87%BD%E6%95%B0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>对于上一算法可引入一个上界函数，用于剪去不含最优解的子树。</p>
<p>上界函数(不选择当前元素)：当前载重量cw+剩余集装箱的重量r≤当前最优载重量bestw。</p>
<blockquote>
<p>就是剪枝函数。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Loading</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">T</span> <span class="n">MaxLoading</span><span class="p">(</span><span class="n">T</span> <span class="p">[],</span><span class="n">T</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//集装箱数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>  <span class="c1">//集装箱重量数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">//第1艘轮船的载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">//当前载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">bestw</span><span class="p">;</span> <span class="c1">//当前最优载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">//剩余集装箱重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Loading</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//搜索第i层结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span> <span class="c1">//到达叶结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">&gt;</span><span class="n">bestw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">bestw</span><span class="o">=</span><span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">//剩余集装箱重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">+</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">)</span> <span class="c1">//进入左子树，x[i]=1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cw</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//继续搜索下一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cw</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//退出左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">+</span><span class="n">r</span><span class="o">&gt;</span><span class="n">bestw</span><span class="p">)</span> <span class="c1">//上界函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//进入右子树，x[i]=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">4、构造最优解 
    <div id="4%E6%9E%84%E9%80%A0%E6%9C%80%E4%BC%98%E8%A7%A3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E6%9E%84%E9%80%A0%E6%9C%80%E4%BC%98%E8%A7%A3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>为构造最优解，需在算法中记录与当前最优值相应的当前最优解。</p>
<p>在类Loading中增加两个私有数据成员：</p>
<blockquote>
<p>int* x：用于记录从根至当前结点的路径；</p>
<p>int* bestx：记录当前最优解。</p></blockquote>
<p>算法搜索到叶结点处，就修正bestx的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">Loading</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 船最大装载问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">// 集装箱数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">x</span><span class="p">;</span><span class="c1">// 当前解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">bestx</span><span class="p">;</span><span class="c1">// 当前最优解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">w</span><span class="p">;</span><span class="c1">// 集装箱重量数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span><span class="c1">// 第一艘船的载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span> <span class="n">cw</span><span class="p">;</span><span class="c1">// 当前载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span> <span class="n">bestw</span><span class="p">;</span><span class="c1">// 当前最优载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="kt">int</span> <span class="n">r</span><span class="p">;</span><span class="c1">// 剩余集装箱重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">backTrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="c1">// 搜索第i层结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 到达叶结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">cw</span> <span class="o">&gt;</span> <span class="n">bestw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">bestx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">bestw</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 剩余集装箱重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">cw</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 进入左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 装第i个集装箱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cw</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">backTrack</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 进入下一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cw</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 退出左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cw</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">bestw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 进入右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 不装第i个集装箱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">backTrack</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="nf">Loading</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">bestx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">bestx</span> <span class="o">=</span> <span class="n">bestx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">bestw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">cw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="n">r</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">// 构造器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">w</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span><span class="c1">// 下标从1开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">bestx</span><span class="p">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Loading</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Loading</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bestx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span><span class="p">.</span><span class="n">backTrack</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">bestx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">bestw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>由于bestx可能被更新O(2n)次，故算法的时间复杂性为O(n2^n)。</p>


<h4 class="relative group">5、迭代回溯(填空即可) 
    <div id="5%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF%E5%A1%AB%E7%A9%BA%E5%8D%B3%E5%8F%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E8%BF%AD%E4%BB%A3%E5%9B%9E%E6%BA%AF%E5%A1%AB%E7%A9%BA%E5%8D%B3%E5%8F%AF" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>理解循环遍历的原理。</p></blockquote>
<p>由于数组x记录了解空间树中从根到当前扩展结点的路径，利用这些信息，可将上述回溯法表示成非递归的形式。</p>
<p>n=3, c1=c2=50，且w=[10,40,40]</p>
<p><a href="https://camo.githubusercontent.com/4b45ebbde8d8557186d089026a0a1c2c4926669d43a605dcfa95e2d21c667916/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032303039303330383739362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032303039303330383739362e706e67.png?lastModify=1746948169" alt="image-20211020090308796" />
      
    </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//迭代回溯法，返回最优载重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">MaxLoading</span><span class="p">(</span><span class="n">Type</span> <span class="n">w</span><span class="p">[],</span><span class="n">Type</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">bestx</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化根结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">bestw</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">cw</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="c1">//搜索子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">&amp;&amp;</span><span class="n">cw</span><span class="o">+</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">)</span> <span class="c1">//进入左子树，条件为真，则一直往左搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">cw</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span>  <span class="c1">//到达叶结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">bestx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">bestw</span><span class="o">=</span><span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="c1">//进入右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span><span class="p">(</span><span class="n">cw</span><span class="o">+</span><span class="n">r</span><span class="o">&lt;=</span><span class="n">bestw</span><span class="p">)</span> <span class="c1">//剪枝回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;!</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">//从右子树返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">r</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="c1">//如返回到根，则结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">delete</span><span class="p">[]</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">bestw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//进入右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cw</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>算法的计算时间为O(2^n)。</p>


<h4 class="relative group">5.3 n皇后问题(重点,三个函数都要掌握) 
    <div id="53-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E9%83%BD%E8%A6%81%E6%8E%8C%E6%8F%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#53-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E9%83%BD%E8%A6%81%E6%8E%8C%E6%8F%A1" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>LeetCode:https://leetcode.cn/problems/n-queens/description/</p>
<blockquote>
<p>N皇后本质还是排列的问题。</p>
<p>详细的解答：https://leetcode.cn/problems/n-queens/solutions/2079586/hui-su-tao-lu-miao-sha-nhuang-hou-shi-pi-mljv/</p></blockquote>


<h5 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。</p>
<p><a href="https://camo.githubusercontent.com/9ecdc3ab3c1ec406f38622c92dd5035f948b0266828a8a84a33eb4142c540a51/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373231333735313931342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373231333735313931342e706e67.png?lastModify=1746948169" alt="image-20211207213751914" />
      
    </figure>
</a></p>


<h5 class="relative group">2、算法设计 
    <div id="2%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>解向量：(x1,x2,&hellip;,xn)</p>
<blockquote>
<p>用n元组x[1:n]表示n后问题的解，其中x[i]表示皇后i放在棋盘的第i行的第x[i]列。</p></blockquote>
<p>显约束：xi=1,2,&hellip;,n（能取值的范围）</p>
<p>隐约束：（两个皇后之间不能相互攻击）</p>
<blockquote>
<p>不同列：xi≠xj</p>
<p>不处于同一正反对角线：|i-j|≠|xi-xj|</p></blockquote>
<p>回溯法解n后问题时，用<strong>完全n叉树</strong>表示解空间，用可行性约束Place()剪去不满足行、列和斜线约束的子树。</p>
<p>Backtrack(i)搜索解空间中第i层子树。</p>
<p>sum记录当前已找到的可行方案数。</p>


<h5 class="relative group">3、四皇后问题 
    <div id="3%E5%9B%9B%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E5%9B%9B%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>问题描述</p>
<p>在4 x 4棋盘上放上4个皇后，使皇后彼此不受攻击。不受攻击的条件是彼此不在同行（列）、斜线上。求出全部的放法。</p>
<p>解表示</p>
<blockquote>
<p>解向量： 4元向量X=(x1,x2,x3,x4)， xi 表示皇后i放在i行上的列号，如(3,1,2,4)</p>
<p>解空间：｛(x1,x2,x3,x4)｜xi∈S，i=1~4｝S={1,2,3,4}</p></blockquote>
<p>可行性约束函数</p>
<blockquote>
<p>显约束：　 xi∈S，i=1~4</p>
<p>隐约束(i ≠ j)：xi ≠ xj   　(不在同一列)</p>
<p>​           　　　　 |i－xi|≠|j－xj|　　　(不在同一斜线)</p></blockquote>
<p>​	四皇后问题的解空间树是一棵完全4叉树，树的根结点表示搜索的初始状态，从根结点到第2层结点对应皇后1在棋盘中第1行的可能摆放位置，从第2层结点到第3层结点对应皇后2在棋盘中第2行的可能摆放位置，依此类推。</p>
<p><a href="https://camo.githubusercontent.com/ee839c6a4fcc57ab4176def59a7e08928ac40fd376271b6fee36f9c0ed6243a9/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373231343331313534372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373231343331313534372e706e67.png?lastModify=1746948169" alt="image-20211207214311547" />
      
    </figure>
</a></p>


<h5 class="relative group">4、算法实现 
    <div id="4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">nQueen</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//n皇后问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="c1">//皇后个数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="c1">//当前解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="c1">//当前已找到可行方案数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">nQueen</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="n">n</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">backTrack</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 放置在第k行
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param k
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 是否可行
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">place</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//前面有没有可能存在某一行在斜对角上产生冲突的状况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 递归回溯
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param t
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">sum</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//[1:n]列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="o">[</span><span class="n">t</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="c1">//放在第i列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">place</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">backTrack</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>优化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nf">solveNQueens</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">queens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// 皇后放在 (r,queens[r])</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">diag1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">diag2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">queens</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">diag1</span><span class="p">,</span><span class="w"> </span><span class="n">diag2</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">queens</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">diag1</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">diag2</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">col</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// 预分配空间</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">queens</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">char</span><span class="o">[]</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Arrays</span><span class="p">.</span><span class="na">fill</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">row</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;Q&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">board</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="n">row</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">board</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 在 (r,c) 放皇后</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">col</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">diag1</span><span class="o">[</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">diag2</span><span class="o">[</span><span class="n">rc</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 判断能否放皇后</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">queens</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="c1">// 直接覆盖，无需恢复现场</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">col</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diag1</span><span class="o">[</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diag2</span><span class="o">[</span><span class="n">rc</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 皇后占用了 c 列和两条斜线</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">dfs</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">queens</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">diag1</span><span class="p">,</span><span class="w"> </span><span class="n">diag2</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">col</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diag1</span><span class="o">[</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diag2</span><span class="o">[</span><span class="n">rc</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 恢复现场</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>非递归的回溯方法：</p>
<blockquote>
<p>先暂时能看懂就行。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 非递归回溯
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param t
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack_o</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">x</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">  </span><span class="c1">//第k行的放到下一列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//x[k]不能放置，则放到下一列，直到可放置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">place</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">  </span><span class="c1">//放在n列范围内</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">  </span><span class="c1">//已放n行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">sum</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">else</span><span class="w">  </span><span class="c1">//不足n行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">k</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//放下一行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">x</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//下一行又从第0列的下列开始试放</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w">  </span><span class="c1">//第k行无法放置，则重新放置上一行（放到下一列）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">k</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h4 class="relative group">5.4 0-1背包问题(重点) 
    <div id="54-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#54-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><a href="https://camo.githubusercontent.com/7c83c9f16d0e1087317d8a3cc946af560566f4acf9fbdf0617dc2fe1cc72ba30/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031383131343531363730392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313031383131343531363730392e706e67.png?lastModify=1746948169" alt="image-20211018114516709" />
      
    </figure>
</a></p>


<h5 class="relative group">1、算法描述 
    <div id="1%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>解空间：子集树</p>
<blockquote>
<p>0-1背包问题是子集选取问题，其解空间可用子集树表示。</p></blockquote>
<p>​	可行性约束函数：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝑐1</p>
<p>​	上界约束：当右子树中有可能包含最优解时才进入右子树搜索，否则剪去右子树。</p>
<p>​	设r是当前剩余物品价值总和，cp是当前价值，bestp是当前最优价值，<strong>当cp+r≤bestp时，剪去右子树。</strong></p>
<p>​	计算右子树中<strong>解的上界</strong>更好的方法是将剩余的物品<strong>依其单位重量价值排序</strong>，然后依次装入物品，直到装不下时，再装入该物品一部分而装满背包，由此得到的价值是右子树中解的上界。——将背包问题作为0-1背包问题的上界。</p>


<h5 class="relative group">2、算法实现 
    <div id="2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Typew</span><span class="p">,</span><span class="k">typename</span> <span class="n">Typep</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Knap</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">Typep</span> <span class="n">Knapsack</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">Typep</span> <span class="o">*</span><span class="p">,</span><span class="n">Typew</span> <span class="o">*</span><span class="p">,</span><span class="n">Typew</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">     <span class="c1">//&lt;&gt;指明友员函数为模板函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    	<span class="n">Typep</span> <span class="n">Bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">//计算上界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   		<span class="kt">void</span> <span class="nf">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    	<span class="n">Typew</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">//背包容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">//物品数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="n">Typew</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>  <span class="c1">//物品重量数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="n">Typep</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">//物品价值数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="n">Typew</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">//当前重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="n">Typep</span> <span class="n">cp</span><span class="p">;</span>  <span class="c1">//当前价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="n">Typep</span> <span class="n">bestp</span><span class="p">;</span>  <span class="c1">//当前最优价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Typew</span><span class="p">,</span><span class="k">typename</span> <span class="n">Typep</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Knap</span><span class="o">&lt;</span><span class="n">Typew</span><span class="p">,</span><span class="n">Typep</span><span class="o">&gt;::</span><span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bestp</span><span class="o">=</span><span class="n">cp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cw</span><span class="o">+</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">)</span>  <span class="c1">//进入左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cw</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">cp</span><span class="o">+=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cw</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">cp</span><span class="o">-=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">Bound</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">bestp</span><span class="p">)</span> <span class="c1">//进入右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Typew</span><span class="p">,</span><span class="k">typename</span> <span class="n">Typep</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Typep</span> <span class="n">Knap</span><span class="o">&lt;</span><span class="n">Typew</span><span class="p">,</span><span class="n">Typep</span><span class="o">&gt;::</span><span class="n">Bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>  <span class="c1">//计算上界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Typew</span> <span class="n">cleft</span><span class="o">=</span><span class="n">c</span><span class="o">-</span><span class="n">cw</span><span class="p">;</span>  <span class="c1">//剩余的背包容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Typep</span> <span class="n">b</span><span class="o">=</span><span class="n">cp</span><span class="p">;</span>  <span class="c1">//b为当前价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">&amp;&amp;</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">cleft</span><span class="p">)</span>  <span class="c1">//依次装入单位重量价值高的整个物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cleft</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="o">+=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">)</span>  <span class="c1">//装入物品的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">b</span><span class="o">+=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">cleft</span><span class="o">/</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">//返回上界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Object</span>  <span class="c1">//物品类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">int</span> <span class="nf">Knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   	 <span class="kt">int</span> <span class="k">operator</span> <span class="o">&lt;</span><span class="p">(</span><span class="n">Object</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    	<span class="p">{</span>
</span></span><span class="line"><span class="cl">       	 <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="o">&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    	<span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>  <span class="c1">//物品编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="kt">float</span> <span class="n">d</span><span class="p">;</span>  <span class="c1">//单位重量价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Typew</span><span class="p">,</span><span class="k">typename</span> <span class="n">Typep</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Typep</span> <span class="n">Knapsack</span><span class="p">(</span><span class="n">Typep</span> <span class="n">p</span><span class="p">[],</span><span class="n">Typew</span> <span class="n">w</span><span class="p">[],</span><span class="n">Typew</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Typew</span> <span class="n">W</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//总重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Typep</span> <span class="n">P</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//总价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Object</span><span class="o">*</span> <span class="n">Q</span><span class="o">=</span><span class="k">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">//创建物品数组，下标从0开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//初始物品数组数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ID</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">d</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">P</span><span class="o">+=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">W</span><span class="o">+=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">W</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">)</span>  <span class="c1">//能装入所有物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">QuickSort</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//依物品单位重量价值非增排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Knap</span><span class="o">&lt;</span><span class="n">Typew</span><span class="p">,</span><span class="n">Typep</span><span class="o">&gt;</span> <span class="n">K</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">Typep</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="k">new</span> <span class="n">Typew</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ID</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span><span class="p">.</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ID</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span><span class="p">.</span><span class="n">cp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">cw</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">bestp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span><span class="p">.</span><span class="n">Backtrack</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span><span class="p">[]</span> <span class="n">Q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span><span class="p">[]</span> <span class="n">K</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span><span class="p">[]</span> <span class="n">K</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="p">.</span><span class="n">bestp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>​	计算上界需要O(n)时间，最坏情况下有𝑂(2𝑛)个右儿子结点需要计算上界，故算法所需要的时间为𝑂(𝑛2𝑛)</p>


<h4 class="relative group">5.5 图的m着色问题 
    <div id="55-%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#55-%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>比较简单，主要就写一个判定函数检查颜色是否可用。</p></blockquote>


<h5 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同颜色。</p>
<p>​	这个问题是图的m可着色判定问题。若一个图最少需要m种颜色才能使图中每条边连接的2个顶点着不同颜色，则称这个数m为该图的色数。求一个图的色数m的问题称为图的m可着色优化问题。</p>
<p><a href="https://camo.githubusercontent.com/9027f19e9f76871de7fb5323e65dee30ce0680b94f291749a0ff5c454b6e0ad5/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373232353431393934392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373232353431393934392e706e67.png?lastModify=1746948169" alt="image-20211207225419949" />
      
    </figure>
</a></p>


<h5 class="relative group">2、算法设计 
    <div id="2%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-1" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>用图的邻接矩阵a表示无向连通图G。</p>
<p>解向量：(x1, x2, … , xn)表示顶点i所着颜色x[i]</p>
<p>可行性约束函数：顶点i与已着色的相邻顶点颜色不重复。</p>
<blockquote>
<p>注意解空间树的画法。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/87da9db96798cad9c8a8c6cc5824fc5328bb4fb92b170a69f99bcb030bc187dc/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373232353435343635362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373232353435343635362e706e67.png?lastModify=1746948169" alt="image-20211207225454656" />
      
    </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Color</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">int</span> <span class="nf">mColoring</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span> <span class="o">**</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">OK</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">);</span> <span class="c1">//检查颜色是否可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">//图的顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">//可用颜色数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="o">**</span><span class="n">a</span><span class="p">;</span>  <span class="c1">//图的邻接矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>  <span class="c1">//当前解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">//当前已找到的可m着色方案数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">Color</span><span class="o">::</span><span class="n">OK</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>  <span class="c1">//检查顶点k颜色是否可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="c1">//有边相连且两顶点颜色相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Color</span><span class="o">::</span><span class="n">Backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//m种颜色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="c1">//顶点t使用颜色i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">OK</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">Backtrack</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//恢复x[t]的初值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mColoring</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="kt">int</span> <span class="o">**</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Color</span> <span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化X
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">X</span><span class="p">.</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">.</span><span class="n">Backtrack</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h5 class="relative group">3、算法效率 
    <div id="3%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>时间耗费𝑂(𝑛𝑚𝑛)</p>
<p>判断下图是否是3可着色</p>
<blockquote>
<p>尝试着画一下。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/7a6c1fa3232bac8ade62aed52024bc56421cb61a055eca8d0e24880767472f6e/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373233313531373336392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230373233313531373336392e706e67.png?lastModify=1746948169" alt="image-20211207231517369" />
      
    </figure>
</a></p>


<h4 class="relative group">5.6 TSP问题（旅行售货员问题）【一级重点】 
    <div id="56-tsp%E9%97%AE%E9%A2%98%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98%E9%97%AE%E9%A2%98%E4%B8%80%E7%BA%A7%E9%87%8D%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#56-tsp%E9%97%AE%E9%A2%98%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98%E9%97%AE%E9%A2%98%E4%B8%80%E7%BA%A7%E9%87%8D%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>本问题相当重要，务必吃透。</p></blockquote>


<h5 class="relative group">1、算法描述 
    <div id="1%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>已给一个n个点的<a href="https://baike.baidu.com/item/%e5%ae%8c%e5%85%a8%e5%9b%be" target="_blank">完全图</a>，每条边都有一个长度，求总长度最短的经过每个顶点正好一次的封闭回路</p>
<blockquote>
<p><strong>因为每两个节点之间都是可达的，那么就是一个排列树。</strong></p></blockquote>
<p>解空间：<strong>排列树</strong></p>
<p>开始时x=[1,2,&hellip;,n]，则相应的排列树由x[1:n]的所有排列构成。</p>
<p><a href="https://camo.githubusercontent.com/6b88e8473e398c29e538c0044cea08df2759220ba652090cd804aae8419c676a/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383037353934363837352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383037353934363837352e706e67.png?lastModify=1746948169" alt="image-20211208075946875" />
      
    </figure>
</a></p>


<h5 class="relative group">2、递归算法 
    <div id="2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<p>​	当i=n时，当前扩展结点是排列树的叶结点的父结点，此时检查图G是否存在一条从顶点x[n-1]到顶点x[n]的边和一条从顶点x[n]到顶点1的边，如果两条边都存在，则找到一条回路。再判断此回路的费用是否优于当前最优回路的费用，是则更新当前最优值和最优解。</p>
<p>​	当i&lt;n时，当前扩展结点位于排列树的第i-1层。图G中存在从顶点x[i-1]到x[i]的边时，检查x[1:i]的费用是否小于当前最优值，是则进入排列树的第i层，否则剪去相应子树。</p>


<h5 class="relative group">3、算法实现 
    <div id="3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TSP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 已给一个n个点的[完全图])，每条边都有一个长度，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 求总长度最短的经过每个顶点正好一次的封闭回路
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="c1">//图的顶点数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="c1">//当前解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">bestx</span><span class="p">;</span><span class="c1">//当前最优解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="c1">//邻接矩阵</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cc</span><span class="p">;</span><span class="c1">//当前费用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bestc</span><span class="p">;</span><span class="c1">//当前最优值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span><span class="c1">//无边标记</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">TSP</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">bestx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">bestc</span><span class="o">=</span><span class="n">NO_EDGE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">cc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">backTrack</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">backTrack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 什么时候收获结果？</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//当i=n时，当前扩展结点是排列树的叶结点的父结点，此时检查图G是否存在一条从</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 顶点x[n-1]到顶点x[n]的边和一条从顶点x[n]到顶点1的边，如果两条边都存在，</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 则找到一条回路。再判断此回路的费用是否优于当前最优回路的费用，是则更新当前最优值和最优解。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]][</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">(</span><span class="n">cc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]][</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bestc</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bestc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">bestx</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">bestc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">n</span><span class="o">]][</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//当i&lt;n时，当前扩展结点位于排列树的第i-1层。图G中存在从顶点x[i-1]到x[i]的边时，</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 检查x[1:i]的费用是否小于当前最优值，是则进入排列树的第i层，否则剪去相应子树。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 1.自己到自己节点在邻接矩阵中设置为无穷，肯定不会直接回去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 2.也相当于是一种限制条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">cc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bestc</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bestc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NO_EDGE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 注意这里要先交换，i之前的就是我们选择走的路径，i之后的是我们没走过的路径。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">cc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">backTrack</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">cc</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]][</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">temp</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h5 class="relative group">4、算法效率 
    <div id="4%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" aria-label="Anchor">#</a>
    </span>        
    
</h5>
<blockquote>
<p>这是排列树，就是O(n!)</p></blockquote>
<p>​	算法backtrack在最坏情况下可能需要更新当前最优解O((n-1)!)次，每次更新bestx需计算时间O(n)，从而整个算法的计算时间复杂性为O(n!)。</p>


<h4 class="relative group">5.7  最大团问题 
    <div id="57--%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#57--%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>最大团问题 给定无向图G=(V，E)。如果UV，且对任意u，vU有 (u，v)E，则称U是G的完全子图。例如{1,2}。 G的完全子图U是G的团当且仅当U不包含在G的更大的完全 子图中，例如{1,2,5}。 G的最大团是指G中所含顶点数最多的团。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250505202506221.png?lastModify=1746948169" alt="image-20250505202506221" />
      
    </figure>
</p>
<p>找出一个图的最大团： 可看做图G的顶点集V的子集选取问题。 • 解空间：子集树 • 可行性约束函数：顶点i到已选入顶点集中的每一个顶点都有边相连。 •上界函数：有足够多的可选择顶点使得算法有可能在右子树中找到更大的团。</p>
<p>代码：</p>
<p>x[]保存了团内的节点。</p>
<p>a [ i ] [ j ] 是boolean数组，表示其中的两个点有没有相连接。</p>
<p>​	<strong>每到一个新的节点，遍历检查这个节点有没有和现存的团中的每一个节点相连接，连接了我们就要了这个节点，否则不要。</strong></p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250505202633884.png?lastModify=1746948169" alt="image-20250505202633884" />
      
    </figure>
</p>


<h2 class="relative group">6.分支限界法 
    <div id="6%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#6%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<blockquote>
<p>注意这里的基本概念要点。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/9f15b8d0b31d7c34869b62615da0e8a94fa4a87c18aa8ce689e86531bd50166b/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383038353830353834372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383038353830353834372e706e67.png?lastModify=1746948169" alt="image-20211208085805847" />
      
    </figure>
</a></p>


<h3 class="relative group">6.1 分支限界法的基本思想 
    <div id="61-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#61-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group"><strong>分支限界法和回溯法</strong> 
    <div id="%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>区别是考试的重点。</p></blockquote>
<p>​	求解目标：回溯法的求解目标是找出解空间树中<strong>满足约束条件的所有解</strong>，而分支限界法的求解目标则是找<strong>出满足约束条件的一个解</strong>，或是在<strong>满足约束条件的解中找出在某种意义下的最优解</strong>。</p>
<p>​	搜索方式的不同：回溯法以<strong>深度优先</strong>的方式搜索解空间树，而分支限界法则以<strong>广度优先或以最小耗费优先</strong>的方式搜索解空间树。</p>
<blockquote>
<p>仅从方式来看，这类似于层序遍历的过程。</p></blockquote>
<p>​	<strong>在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。<strong>在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，<strong>其余儿子结点被加入活结点表中</strong>。此后，从活结点表中</strong>取下一结点</strong>成为当前<strong>扩展结点</strong>，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<p>选择下一个E结点的方法如下：</p>
<blockquote>
<p>1）先进先出(FIFO)：从活结点表中取出结点的顺序与加入结点的顺序相同。</p>
<p>​	后进先出(LIFO)：从活结点表中取出结点的顺序与加入结点的顺序相反。</p>
<p>2）优先队列式分支限界法</p>
<p>​	按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p>
<p>​	（就是Dijkstra的堆优化算法）</p></blockquote>


<h4 class="relative group">基本思想 
    <div id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>1️⃣ 在 e_结点估算沿着它的各儿子结点搜索时，目标函数可能取得的“界”，</p>
<p>2️⃣ 把儿子结点和目标函数可能取得的“界”，保存在优先队列或堆中，</p>
<p>3️⃣ 从队列或堆中选取“界”最大或最小的结点向下搜索，直到叶子结点，</p>
<p>4️⃣ 若叶子结点的目标函数的值，是结点表中的最大值或最小值，则沿叶子结点到根结点的路径所确定的解，就是问题的最优解，否则转 3 继续搜索</p>


<h3 class="relative group">示例 
    <div id="%E7%A4%BA%E4%BE%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%A4%BA%E4%BE%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>0-1背包问题</strong></p>
<p>考虑实例n=4，w=[3,5,2,1]，v=[9,10,7,4]，C=7。</p>
<p>定义问题的解空间</p>
<blockquote>
<p>该实例的解空间为（x1,x2,x3,x4），xi=0或1(i=1,2,3,4)。</p></blockquote>
<p>确定问题的解空间组织结构</p>
<blockquote>
<p>该实例的解空间是一棵子集树，深度为4。</p></blockquote>
<p>搜索解空间</p>
<blockquote>
<p>约束条件</p>
<p>限界条件  cp+rp&gt;bestp</p></blockquote>


<h4 class="relative group">队列式分支限界法 
    <div id="%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>cp初始值为0；rp初始值为所有物品的价值之和；bestp表示当前最优解，初始值为0。</p>
<p>当cp&gt;bestp时，更新bestp为cp。</p>
<blockquote>
<p>理解下面的图：这样的过程就是类似于层序遍历生成一颗树。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/c8b82b7cb9a581a23552b1532b3d6baded381380d6a286864ddc855a356c59db/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131323934393330392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131323934393330392e706e67.png?lastModify=1746948169" alt="image-20211025112949309" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/a5fe812dafed69418b1e430ba588bd695565c08773b096c78e6aaa0cc6f2b16b/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131333134313135372e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131333134313135372e706e67.png?lastModify=1746948169" alt="image-20211025113141157" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/77016bea88e681fa45e14a37d3debb8d60518da1c9b10ce1374e68b4cf597f3d/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383039313032393037352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383039313032393037352e706e67.png?lastModify=1746948169" alt="image-20211208091029075" />
      
    </figure>
</a></p>


<h4 class="relative group">优先队列式 
    <div id="%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%BC%8F" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	优先级：活结点代表的部分解所描述的装入背包的物品价值上界，该价值上界越大，优先级越高。活结点的价值上界up=cp+rp。</p>
<p>约束条件：同队列式</p>
<p>限界条件：up=cp+r‘p&gt;bestp。</p>
<p>rp 剩余物品装满背包的价值</p>
<blockquote>
<p>优先去装原来价值就更大的背包。</p></blockquote>
<p><a href="https://camo.githubusercontent.com/f2ce45b470c9e7e6390bdd1fd32103c3f0fa76e761aed08e5909eac711e90b97/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131333730343130312e706e67" target="_blank">
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://camo.githubusercontent.com/f2ce45b470c9e7e6390bdd1fd32103c3f0fa76e761aed08e5909eac711e90b97/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313032353131333730343130312e706e67" alt="image-20211025113704101" />
    
  </figure>
</a></p>


<h3 class="relative group">6.2 单源最短路径问题 
    <div id="62-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#62-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">问题描述 
    <div id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>在下图所给的有向图G中，每一边都有一个非负边权。要求图G的从源顶点s到目标顶点t之间的最短路径。</p>
<p><a href="https://camo.githubusercontent.com/b9413b1e2546b464e629f5c62f2e5b1c3828e8b2dc0ad1fdb9d9350dc3c04341/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383136333732303838342e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383136333732303838342e706e67.png?lastModify=1746948169" alt="image-20211208163720884" />
      
    </figure>
</a></p>
<p>下图是用优先队列式分支限界法解有向图G的单源最短路径问题产生的解空间树。其中，每一个结点旁边的数字表示该结点所对应的当前路长。</p>


<h4 class="relative group">算法思想 
    <div id="%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	解单源最短路径问题的<strong>优先队列式分支限界法用一极小堆来存储活结点表</strong>。其<strong>优先级是结点所对应的当前路长。</strong></p>
<p>​	算法从图G的源顶点s和空优先队列开始。结点s被扩展后，它的儿子结点被依次插入堆中。此后，算法从堆中取出具有最小当前路长的结点作为当前扩展结点，并依次检查与当前扩展结点相邻的所有顶点。</p>
<p>​	<strong>如果从当前扩展结点i到顶点j有边可达，且从源出发，途经顶点i再到顶点j的所相应的路径的长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中。这个结点的扩展过程一直继续到活结点优先队列为空时为止。</strong></p>


<h4 class="relative group">实例说明 
    <div id="%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><a href="https://camo.githubusercontent.com/12ed10908f8bb9fa07043067bf3405a06544d88cd1407426ca168d4259fa6b1c/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135343431373534302e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135343431373534302e706e67.png?lastModify=1746948169" alt="image-20211208154417540" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/ab1833e1a8896d1ab1dd0a85782c5397b55bf3268f1e6a1122acedd19649d564/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135343330333937312e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135343330333937312e706e67.png?lastModify=1746948169" alt="image-20211208154303971" />
      
    </figure>
</a></p>


<h4 class="relative group">算法设计 
    <div id="%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="w">   </span><span class="kd">static</span><span class="w"> </span><span class="kt">float</span><span class="o">[][]</span><span class="n">a</span><span class="w">  	</span><span class="c1">//图G的邻接矩阵</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kd">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">[]</span><span class="n">dist</span><span class="w">  </span><span class="c1">//源到各顶点的距离</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">[]</span><span class="n">p</span><span class="w"> 		</span><span class="c1">//源到各顶点的路径上的前驱顶点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">HeapNode</span><span class="w"> 			</span><span class="c1">//最小堆元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">{</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//顶点编号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="c1">//当前路长</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="err">……</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">//1.先进行一个while(true)的循环。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//搜索问题的解空间</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2.取堆的最上面的节点出来并且对于每个点都进行一次遍历和更新。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3.如果满足条件的话就更改值并且加入优先队列。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="o">[</span><span class="n">enode</span><span class="p">.</span><span class="na">i</span><span class="o">][</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">Float</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="p">(</span><span class="n">enode</span><span class="p">.</span><span class="na">length</span><span class="o">+</span><span class="n">a</span><span class="o">[</span><span class="n">enode</span><span class="p">.</span><span class="na">i</span><span class="o">][</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="c1">//顶点i和j间有边，且此路径长小于原先从原点到j的路径长</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="c1">// 顶点i到顶点j可达，且满足控制约束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="w"> </span><span class="n">enode</span><span class="p">.</span><span class="na">length</span><span class="o">+</span><span class="n">c</span><span class="o">[</span><span class="n">enode</span><span class="p">.</span><span class="na">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">p</span><span class="w"> </span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="w"> </span><span class="n">enode</span><span class="p">.</span><span class="na">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="c1">// 加入活结点优先队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">HeapNode</span><span class="w"> </span><span class="n">node</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="n">HeapNode</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">dist</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">heap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">// 取下一扩展结点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">(</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="n">enode</span><span class="o">=</span><span class="p">(</span><span class="n">HeapNode</span><span class="p">)</span><span class="n">heap</span><span class="p">.</span><span class="na">removeMin</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> 
</span></span></span></code></pre></div>

<h3 class="relative group">6.3 0-1背包问题[重点] 
    <div id="63-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#63-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>解答参考https://www.it610.com/article/1296236014334976000.htm</p>


<h4 class="relative group">问题描述 
    <div id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<ul>
<li>给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。</li>
<li>应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</li>
<li>在选择装入背包的物品时，对每种物品i只有2种选择，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。</li>
</ul>


<h4 class="relative group">算法的思想 
    <div id="%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<ul>
<li>首先，要对输入数据进行预处理，将各物品依其<strong>单位重量价值从大到小进行排列。</strong></li>
<li>在实现时，由<strong>Bound</strong>计算当前结点处的上界。在解空间树的当前扩展结点处，仅当要进入右子树时才计算右子树的上界<strong>Bound</strong>，以判断是否将右子树剪。进入左子树时不需要计算上界，因为其上界与其父节点上界相同。</li>
<li>在优先队列分支限界法中，结点的优先级定义为：<strong>以结点的价值上界作为优先级</strong>（由bound函数计算出）</li>
</ul>


<h4 class="relative group">步骤 
    <div id="%E6%AD%A5%E9%AA%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%AD%A5%E9%AA%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>就是使用队列的同时还加上了附加条件。</p></blockquote>
<ol>
<li>算法首先根据基于可行结点相应的子树<strong>最大价值上界优先级，从堆中选择一个节点（根节点）作为当前可扩展结点</strong>。</li>
<li>检查当前扩展结点的左儿子结点的可行性。</li>
<li>如果左儿子结点是可行结点，则将它加入到子集树和活结点优先队列中。</li>
<li>当前扩展结点的右儿子结点一定是可行结点，<code>仅当右儿子结点满足上界函数约束时,才将它加入子集树和活结点优先队列。</code></li>
<li>当扩展到叶节点时，算法结束，叶子节点对应的解即为问题的最优值。</li>
</ol>


<h4 class="relative group">样例 
    <div id="%E6%A0%B7%E4%BE%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A0%B7%E4%BE%8B" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p> 假设有4个物品，其重量分别为(4, 7, 5, 3)，价值分别为(40, 42, 25, 12)，背包容量W=10。将给定物品按单位重量价值从大到小排序，结果如下：</p>
<table>
  <thead>
      <tr>
          <th>物品</th>
          <th>重量(w)</th>
          <th>价值(v)</th>
          <th>价值/重量(v/w)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>4</td>
          <td>40</td>
          <td>10</td>
      </tr>
      <tr>
          <td>2</td>
          <td>7</td>
          <td>42</td>
          <td>6</td>
      </tr>
      <tr>
          <td>3</td>
          <td>5</td>
          <td>25</td>
          <td>5</td>
      </tr>
      <tr>
          <td>4</td>
          <td>3</td>
          <td>12</td>
          <td>4</td>
      </tr>
  </tbody>
</table>
<p><strong>上界计算</strong>   先装入物品1，剩余的背包容量为6，只能装入物品2的6/7(即<code>42*(6/7)=36</code>)。 即上界为<code>40+6*6=76</code></p>
<blockquote>
<p>已第一个up为例:40+6*(10-4)=76 打x的部分因为up值已经小于等于bestp了，所以没必要继续递归了。</p></blockquote>


<h4 class="relative group">核心代码 
    <div id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<ul>
<li>Typew c： 背包容量</li>
<li>C： 背包容量</li>
<li>Typew *w： 物品重量数组</li>
<li>Typew *p： 物品价值数组</li>
<li>Typew cw：当前重量</li>
<li>Typew cp：当前价值</li>
<li>Typep bestcp：当前最优价值</li>
</ul>


<h4 class="relative group">上界函数 
    <div id="%E4%B8%8A%E7%95%8C%E5%87%BD%E6%95%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%8A%E7%95%8C%E5%87%BD%E6%95%B0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<blockquote>
<p>这和贪心算法有什么区别？</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Typew</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Typep</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Typep</span> <span class="n">Knap</span><span class="o">&lt;</span><span class="n">Typew</span><span class="p">,</span> <span class="n">Typep</span><span class="o">&gt;::</span><span class="n">Bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="c1">// 计算上界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Typew</span> <span class="n">cleft</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">// 剩余容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Typep</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 以剩余物品单位重量价值递减序装入物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cleft</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cleft</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">b</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 装满背包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cleft</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">结点定义 
    <div id="%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">class</span>  <span class="nc">Bbnode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BBnode</span>  <span class="n">parent</span><span class="p">;</span>  <span class="c1">//父结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">boolean</span>  <span class="n">leftChild</span><span class="p">;</span> <span class="c1">//左儿子结点标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">class</span> <span class="nc">HeapNode</span> <span class="n">implements</span> <span class="n">Comparable</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BBnode</span>  <span class="n">liveNode</span><span class="p">;</span>  <span class="c1">//活结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span>  <span class="n">upperProfit</span><span class="p">;</span> <span class="c1">//结点的价值上界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span>  <span class="n">profit</span><span class="p">;</span>         <span class="c1">//结点所相应的价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span>  <span class="n">weight</span><span class="p">;</span>       <span class="c1">//结点所相应的重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span>   <span class="n">level</span><span class="p">;</span>                <span class="c1">//活结点在子集树中所处的层序号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div>

<h4 class="relative group">0-1背包问题优先队列分支限界搜索算法 
    <div id="0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><a href="https://camo.githubusercontent.com/0682d3dec50a20695860c28d10e0ea33964a204f35fef02c9fd21eddb22926d0/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135303730323734392e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383135303730323734392e706e67.png?lastModify=1746948169" alt="image-20211208150702749" />
      
    </figure>
</a></p>


<h2 class="relative group">6.4 作业分配问题【重点,没看懂】 
    <div id="64-%E4%BD%9C%E4%B8%9A%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9%E6%B2%A1%E7%9C%8B%E6%87%82" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#64-%E4%BD%9C%E4%B8%9A%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9%E6%B2%A1%E7%9C%8B%E6%87%82" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>详情参考https://blog.csdn.net/qq_40801709/article/details/90439784</p>


<h4 class="relative group">1、问题描述 
    <div id="1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>​	n 个操作员以 n 种不同时间完成 n 种不同作业。要求分配每位操作员完成一项工作，使完成 n 项工作的总时间最少操作员编号为  0,1,…n-1，作业也编号为 0,1,…n-1， 矩阵 c 描述每位操作员完成每个作业时所需的时间，元素 ci,j 表示第 i 位操作员完成第 j 号作业所需的时间 向量 x 描述分配给操作员的作业编号，分量 xi 表示分配给第 i 位操作员的作业编号。</p>


<h4 class="relative group">2、思想方法 
    <div id="2%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>1）从根结点开始，每遇到一个<strong>扩展结点</strong>，就对它的所有儿子结点计算其下界，把它们登记在结点表中。</p>
<p>2）从表中选取下界最小的结点，重复上述过程。</p>
<p>3）当搜索到一个叶子结点时，如果该结点的下界是结点表中最小的，那么，该结点就是问题的最优解。</p>
<p>4）否则，对下界最小的结点继续进行扩展</p>


<h4 class="relative group">3、下界的确认 
    <div id="3%E4%B8%8B%E7%95%8C%E7%9A%84%E7%A1%AE%E8%AE%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#3%E4%B8%8B%E7%95%8C%E7%9A%84%E7%A1%AE%E8%AE%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>搜索深度为 0 时，把第 0 号作业分配给第 i 位操作员所需时间至少<strong>为第 i 位操作员完成第 0 号作业所需时间，加上其余 n-1个作业分别由其余 n-1 位操作员单独完成时所需最短时间之和</strong>，有：<a href="https://camo.githubusercontent.com/1b53cf82c5708deae1f98d998da9f6bcf107c7304e164ce2f87833e262e542b2/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137323532393033362e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137323532393033362e706e67.png?lastModify=1746948169" alt="image-20211208172529036" />
      
    </figure>
</a></p>
<p>例：4个操作员完成4个作业所需的时间表如下：</p>
<p><a href="https://camo.githubusercontent.com/2ce994a1738314d364853540645d70c4985613e119cf5b57dd0acf3fd693a1ba/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137323633323833352e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137323633323833352e706e67.png?lastModify=1746948169" alt="image-20211208172632835" />
      
    </figure>
</a></p>
<p>​	把第 0 号作业分配给第 0 位操作员时，所需时间至少不小于 3 + 7 + 6 + 3 = 19 ，把0号作业1 位操作员时，所需 时间至少不会小于9+7+4+3…</p>
<p>​	搜索深度为 k 时，前面第0,1,&hellip;&hellip;,k-1号作业已分别分配 给编号为i0,i1,&hellip;&hellip;,ik-1的操作员。 S={0,1,&hellip;&hellip;,n-1}表示所有操作员的编号集合；</p>
<p>mk-1={i0,i1,&hellip;&hellip;ik-1}表示作业已分配的操作员编号集合。当把第k号作业分配给编号为ik的操作员时，𝑖𝑘∈𝑆−𝑚𝑘−1， 所需时间至少为：</p>
<p><a href="https://camo.githubusercontent.com/6421197e7bc32bad2d84155e6fcea38c0b9672c541ca19194fa4b4172976e7be/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137333330343538332e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137333330343538332e706e67.png?lastModify=1746948169" alt="image-20211208173304583" />
      
    </figure>
</a></p>
<p>​     则上式为把第k号作业分配给编号为ik的操作员时的下界</p>


<h4 class="relative group">4、算法实现步骤 
    <div id="4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><a href="https://camo.githubusercontent.com/bf02f90c0bac1f60e8c5e3e2fe1195b989bf016cc1c7c7acab7e20840724b618/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137333835383831382e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383137333835383831382e706e67.png?lastModify=1746948169" alt="image-20211208173858818" />
      
    </figure>
</a></p>
<p><a href="https://camo.githubusercontent.com/bc3713e62607ae2bbedbd41a851690019c2e66f3cec17511e6e7c9b3f39e6e37/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383138333435383038382e706e67" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/68747470733a2f2f6e6f74652d696d6167652d313330373738363933382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f7479706f72612f717368656c6c2f696d6167652d32303231313230383138333435383038382e706e67.png?lastModify=1746948169" alt="image-20211208183458088" />
      
    </figure>
</a></p>


<h4 class="relative group">5、实现代码 
    <div id="5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_NUM 99999
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">];</span><span class="c1">//n个操作员分别完成n项作业所需时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span><span class="c1">//当前已搜索可行解的最优时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ass_node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="c1">//分配给操作员的作业
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span><span class="c1">//搜索深度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span> <span class="n">t</span><span class="p">;</span><span class="c1">//当前搜索深度下，已分配作业所需时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span> <span class="n">b</span><span class="p">;</span><span class="c1">//本节点所需的时间下界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">struct</span> <span class="nc">ass_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span><span class="c1">//优先队列链指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">ass_node</span><span class="o">*</span> <span class="n">ASS_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1">//把xnode所指向的节点按所需时间下界插入优先队列qbase中，下界越小，优先性越高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Q_insert</span><span class="p">(</span><span class="n">ASS_NODE</span> <span class="n">qbase</span><span class="p">,</span> <span class="n">ASS_NODE</span> <span class="n">xnode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ASS_NODE</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ASS_NODE</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">qbase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">xnode</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">temp2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">xnode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">temp2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">xnode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//取下并返回优先队列qbase的首元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ASS_NODE</span> <span class="nf">Q_delete</span><span class="p">(</span><span class="n">ASS_NODE</span> <span class="n">qbase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//ASS_NODE temp = qbase;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ASS_NODE</span> <span class="n">rt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ass_node</span><span class="p">;</span><span class="c1">//只是一个node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="o">*</span><span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="n">rt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">rt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//分支限界法实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="nf">job_assigned</span><span class="p">(</span><span class="kt">float</span> <span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)[</span><span class="n">n</span><span class="p">],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">job</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ASS_NODE</span> <span class="n">xnode</span><span class="p">,</span><span class="n">ynode</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ASS_NODE</span> <span class="n">qbase</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ass_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">qbase</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//空头节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">xnode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ass_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">xnode</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//-1表示尚未分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">xnode</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">=</span> <span class="n">xnode</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">xnode</span><span class="o">-&gt;</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//非叶子节点，继续向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">xnode</span><span class="o">-&gt;</span><span class="n">k</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//对n个操作员分别判断处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">xnode</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">//i操作员未分配工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">ynode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ass_node</span><span class="p">;</span><span class="c1">//为i操作员建立一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="o">*</span><span class="n">ynode</span> <span class="o">=</span> <span class="o">*</span><span class="n">xnode</span><span class="p">;</span><span class="c1">//把父节点数据复制给它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ynode</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span><span class="c1">//作业k分配给操作员i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ynode</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">];</span><span class="c1">//已分配作业累计时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">ynode</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">k</span><span class="o">++</span><span class="p">;</span><span class="c1">//该节点下一次搜索深度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">ynode</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//未分配作业最小时间估计
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">min</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="k">if</span> <span class="p">((</span><span class="n">ynode</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">							<span class="n">min</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="n">ynode</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">+=</span> <span class="n">min</span><span class="p">;</span><span class="c1">//本节点所需时间下界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="n">ynode</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">Q_insert</span><span class="p">(</span><span class="n">qbase</span><span class="p">,</span> <span class="n">ynode</span><span class="p">);</span><span class="c1">//把节点插入优先队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="k">if</span> <span class="p">(</span><span class="n">ynode</span><span class="o">-&gt;</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span><span class="c1">//得到一个可行解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="n">bound</span> <span class="o">=</span> <span class="n">ynode</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span><span class="c1">//更新可行解的最优下界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">else</span> <span class="k">delete</span> <span class="n">ynode</span><span class="p">;</span><span class="c1">//大于可行解最优下界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">xnode</span><span class="p">;</span><span class="c1">//释放节点xnode的缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">xnode</span> <span class="o">=</span> <span class="n">Q_delete</span><span class="p">(</span><span class="n">qbase</span><span class="p">);</span><span class="c1">//取下队列首元素xnode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">min</span> <span class="o">=</span> <span class="n">xnode</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//保存最优方案
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">job</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnode</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">qbase</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">xnode</span> <span class="o">=</span> <span class="n">Q_delete</span><span class="p">(</span><span class="n">qbase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">xnode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">job</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">job</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="n">job_assigned</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">job</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">job</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">system</span><span class="p">(</span><span class="s">&#34;pause&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

<h2 class="relative group">近似算法 
    <div id="%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250508185155454.png?lastModify=1746948169" alt="image-20250508185155454" />
      
    </figure>
</p>


<h3 class="relative group">顶点覆盖问题的近似算法 
    <div id="%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">VertexSet</span><span class="w"> </span><span class="nf">approxVertexCover</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cset</span><span class="o">=</span><span class="w"> </span><span class="n">空集</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">e1</span><span class="o">=</span><span class="n">g</span><span class="p">.</span><span class="na">e</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">从e1中任取一条边</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cset</span><span class="o">=</span><span class="n">cset</span><span class="err">∪</span><span class="p">{</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">}</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">从e1中删去与u和v相关联的所有边</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">return</span><span class="w"> </span><span class="n">cset</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>过程：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250508184806368.png?lastModify=1746948169" alt="image-20250508184806368" />
      
    </figure>
</p>
<p>到C的位置的时候，e1中已经没有边了，循环结束。</p>
<blockquote>
<p>比较简单的证明，性能比&lt;=2。</p></blockquote>
<p>◼每条边扫描一次，时间复杂度为O(|E|) ◼Ratio Bound为2。证明如下： ❑令E’为选中的边集，若(u,v)∈ E’，则与其相邻的边都被删除，因此E’中无相邻边; ❑每次选一条边，则每次有两个顶点加入解集A，<strong>|A|=2|E’|</strong>; ❑设OPT为最优解，由于E’中无邻接边，<strong>OPT至少包含E’中每条边的一个顶点，故|E’|≤|OPT|</strong>; ❑故|A|=2|E’|≤2|OPT|，从而得性能比 <strong>|A|/|OPT|≤2</strong>。</p>


<h2 class="relative group">一些题目解答 
    <div id="%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E7%AD%94" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E7%AD%94" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1.什么是复杂性和渐进复杂性？ 计算资源的量 n趋近于无穷的渐进函数</p>
<p>2.回溯法的约束函数和限界函数是干什么的？ 不满足约束条件 不满足最优解</p>
<p>3.最优子结构？</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250506170338749.png?lastModify=1746948169" alt="image-20250506170338749" />
      
    </figure>
</p>
<p>4.什么是算法？</p>
<blockquote>
<p>注意16和17的证明。</p></blockquote>
<p><strong>解决问题的方法或者过程，满足有限性，确定性，可行性。</strong></p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250507125206821.png?lastModify=1746948169" alt="image-20250507125206821" />
      
    </figure>
</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250507125313133.png?lastModify=1746948169" alt="image-20250507125313133" />
      
    </figure>
</p>


<h2 class="relative group">递归分治1 
    <div id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB1" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220144221946.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220144221946.png?lastModify=1746948169" alt="image-20250220144221946" />
      
    </figure>
</a></p>
<p>1️⃣第一问</p>
<ol>
<li>第一次：将全体分成9/9/9分别称重，找出较轻的一份</li>
<li>第二次：将较轻的一份成3/3/3，找出较轻的一份</li>
<li>第三次：将较轻的一份成1/1/1，就此找出轻硬币</li>
</ol>
<p>2️⃣第二问</p>
<ol>
<li>算法设计：将3𝑘分为3×3𝑘−1后找出较轻者，再将3𝑘−1分为3×3𝑘−2后找出较轻者，递归至最终只有一个硬币</li>
<li>递归表达式：𝑇(𝑛)=𝑇(𝑛3)+𝑂(1)
<ul>
<li>T  (  n  ) ：原问题的规模</li>
<li>O  (  1  ) ：找出三者中哪个最轻</li>
<li>T (n3)   ：分组后需要处理的那1/3份问题的规模</li>
</ul>
</li>
<li>复杂度：由主定理直接得𝑛log𝑏⁡𝑎=1与𝑂(1)增长速度一样，所以𝑇(𝑛)=Θ(𝑛log𝑏⁡𝑎log⁡𝑛)=log⁡𝑛</li>
</ol>
<p>⚠️主定理：𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)，则𝑇(𝑛)有如下渐进界</p>
<table>
  <thead>
      <tr>
          <th>条件</th>
          <th>结论</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>f  (  n  ) 的增长慢于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (      n                  log                  b                    ⁡      a        )</td>
      </tr>
      <tr>
          <td>f  (  n  ) 的增长等于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (      n                  log                  b                    ⁡      a        log  ⁡  n  )</td>
      </tr>
      <tr>
          <td>f  (  n  ) 的增长快于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (  f  (  n  )  )</td>
      </tr>
  </tbody>
</table>


<h2 class="relative group">递归分治2 
    <div id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB2" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220151117268.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220151117268.png?lastModify=1746948169" alt="image-20250220151117268" />
      
    </figure>
</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220151209015.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220151209015.png?lastModify=1746948169" alt="image-20250220151209015" />
      
    </figure>
</a></p>
<p>1️⃣第一问：设𝑓(𝑛)问题中调用了𝑎(𝑛)次𝑓(0)，调用了𝑏(𝑛)次𝑓(1)</p>
<ol>
<li>递归条件：
<ul>
<li>f  (  n  ) 本质上就是一堆𝑓(0)/𝑓(1)的相加</li>
<li>在𝑓(𝑛)中调用𝑓(0)/𝑓(1)的次数，就是在𝑓(𝑛–1)和𝑓(𝑛–2)中调用𝑓(0)/𝑓(1)的次数的总和</li>
<li>a  (  n  )  =  a  (  n      –    1  )  +  a  (  n      –    2  ) 以及𝑏(𝑛)=𝑏(𝑛–1)+𝑏(𝑛–2)，二者就是一个斐波那契数列</li>
</ul>
</li>
<li>尝试前面几个值：
<ul>
<li>f  (  0  )  =  1 直接返回自身的值，算是调用了𝑓(0)一次，所以𝑎(0)=1/𝑏(0)=0</li>
<li>f  (  1  )  =  1 直接返回自身的值，算是调用了𝑓(1)一次，所以𝑎(1)=0/𝑏(1)=1</li>
<li>前两项相加𝑓(2)=2/𝑎(2)=1/𝑏(2)=1</li>
<li>前两项相加𝑓(3)=3/𝑎(3)=1/𝑏(3)=2</li>
<li>前两项相加𝑓(4)=5/𝑎(4)=2/𝑏(4)=3</li>
<li>前两项相加𝑓(5)=8/𝑎(5)=3/𝑏(5)=5</li>
</ul>
</li>
<li>可知𝑎(𝑛)比𝑓(𝑛)慢了两步所以𝑎(𝑛)=𝑓(𝑛–2)，𝑏(𝑛)比𝑓(𝑛)慢了一步所以𝑏(𝑛)=𝑓(𝑛–1)</li>
</ol>
<p>2️⃣第二问</p>
<ol>
<li>将规模为𝑛的wenti分解为：规模为𝑛–1的问题+规模为𝑛–2的问题+常数时间合并
<ul>
<li>所以𝑇(𝑛)=𝑇(𝑛–1)+𝑇(𝑛–2)+𝑂(1)</li>
</ul>
</li>
<li>这个递归式很难解也不用解，因为题目已经告诉你了𝑓(n)=15((1+52)𝑛+1–(1–52)𝑛+1)
<ul>
<li>所以复杂度为𝑂(𝑓(𝑛))=𝑂(15((1+52)𝑛+1–(1–52)𝑛+1))=𝑂((1+52)𝑛+1)</li>
</ul>
</li>
</ol>


<h2 class="relative group">递归分治3 
    <div id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB3" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220161759101.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220161759101.png?lastModify=1746948169" alt="image-20250220161759101" />
      
    </figure>
</a></p>
<p>1️⃣算法设计：将𝐴分为两部分，如果<code>A[mid]&gt;mid</code>则查找左半边，如果<code>A[mid]&lt;mid</code>则查找右半边，如此递归</p>
<p>2️⃣复杂度：递归表达式𝑇(𝑛)=𝑇(𝑛2)+𝑂(1)，其中𝑂(1)为比较中值大小耗时</p>
<ol>
<li>由此𝑛log𝑏⁡𝑎=1，所以属于主定理的情况二，复杂度为Θ(log⁡𝑛)</li>
</ol>
<p>1️⃣是什么：给定𝑛种物品和容量为𝐶的背包，物品𝑖的重量为𝑤𝑖价格为𝑣𝑖，如何装物品进去使得背包中物品最贵</p>
<ol>
<li>要求：max∑𝑖=1𝑛𝑣𝑖𝑥𝑖</li>
<li>限制：∑𝑖=1𝑛𝑤𝑖𝑥𝑖≤𝐶，其中𝑥𝑖∈0,1用于表示物品𝑖装还是不装，并且1≤𝑖≤𝑛</li>
</ol>
<p>3️⃣递归结构：𝑚(𝑖,𝑗)=max𝑚(𝑖+1,𝑗–𝑤𝑖)+𝑣𝑖,𝑚(𝑖+1,𝑗)</p>
<ol>
<li>j 为当前剩余容量，𝑖表示当前当前正在处理物品𝑖，𝑚是背包已放入物体1→𝑖的价值</li>
<li>放入物品𝑖则变为𝑚(𝑖+1,𝑗–𝑤𝑖)+𝑣𝑖，不放入物品𝑖则变为𝑚(𝑖+1,𝑗)</li>
</ol>


<h2 class="relative group">动态规划1 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220175905664.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220175905664.png?lastModify=1746948169" alt="image-20250220175905664" />
      
    </figure>
</a></p>
<p>1️⃣令(𝑤,𝑣)表示当前背包的<code>&lt;重量,价值&gt;</code></p>
<ol>
<li>放或不放物品1：
<ul>
<li>(  0  ,  0  )  (  5  ,  3  )</li>
</ul>
</li>
<li>放或不放物品2：
<ul>
<li>(  0  ,  0  )  (  5  ,  3  )      /    (  12  ,  4  )  (  17  ,  7  )</li>
</ul>
</li>
<li>放或不放物品3：
<ul>
<li>(  0  ,  0  )  (  5  ,  3  )  (  12  ,  4  )      (    17    ,    7    )        /    (  6  ,  7  )  (  11  ,  10  )      (    18    ,    11    )        (    23    ,    14    )</li>
</ul>
</li>
<li>放或不放物品4：
<ul>
<li>(  0  ,  0  )  (  5  ,  3  )      (    12    ,    4    )    (  6  ,  7  )  (  11  ,  10  )      /    (  7  ,  9  )  (  12  ,  12  )      (    19    ,    13    )    (  13  ,  16  )  (  18  ,  19  )</li>
</ul>
</li>
<li>放或不放物品5：新增结点全部被支配，所以无任何变化
<ul>
<li>(  0  ,  0  )  (  5  ,  3  )  (  6  ,  7  )  (  11  ,  10  )  (  7  ,  9  )  (  12  ,  12  )  (  13  ,  16  )  (  18  ,  19  )</li>
</ul>
</li>
</ol>
<p>2️⃣价值最大着(18,19)即为解，对应选择的物品是1/3/4</p>
<p>⚠️注意每一轮需要删掉两种结点</p>
<ol>
<li>一个是总重量大于20的结点</li>
<li>另一个是被支配结点，比如结点𝐴的重量比别人大+价值还比别人小，则将其删掉</li>
</ol>


<h2 class="relative group">动态规划2 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220203206260.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220203206260.png?lastModify=1746948169" alt="image-20250220203206260" />
      
    </figure>
</a></p>
<p>1️⃣第一问</p>
<blockquote>
<p>分放或者不放来更新会更加显然一些。</p></blockquote>
<ol>
<li>放或不放物品1：(2,6)
<ul>
<li>不放：(0,0)</li>
<li>放入：(2,6)</li>
</ul>
</li>
<li>放或不放物品2：(2,3)
<ul>
<li>不放：(0,0)(2,6)</li>
<li>放入：(2,3)(4,9)其中(2,3)被支配</li>
</ul>
</li>
<li>放或不放物品3：(6,5)
<ul>
<li>不放：(0,0)(2,6)(4,9)</li>
<li>放入：(6,5)(8,11)(10,14)其中(6,5)被支配</li>
</ul>
</li>
<li>放或不放物品4：(5,4)
<ul>
<li>不放：(0,0)(2,6)(4,9)(8,11)(10,14)</li>
<li>放入：(5,4)(7,10)(9,13)(13,15)(15,18)其中(5,4)被支配</li>
</ul>
</li>
<li>放或不放物品5：(4,6)
<ul>
<li>不放：(0,0)(2,6)(4,9)(8,11)(10,14)(7,10)(9,13)(13,15)(15,18)其中(7,10)被支配</li>
<li>放入：(4,6)(6,12)(8,15)(12,17)(14,20)(11,16)(13,19)其中(4,6)被支配</li>
</ul>
</li>
</ol>
<p>2️⃣最优解源于(14,20)，选择的是1/2/3/5</p>


<h2 class="relative group">动态规划3 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220205409251.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220205409251.png?lastModify=1746948169" alt="image-20250220205409251" />
      
    </figure>
</a></p>
<p>1️⃣对于数组𝐴，假设以𝐴[𝑖]结尾的子序列长度为𝐿[𝑖]</p>
<ol>
<li>对于介于0→𝑖之间的𝑗，如果𝐴[𝑖]&gt;𝐴[𝑗]，则完全可以将𝐴[𝑖]加到以𝑗结尾的子序列当中
<ul>
<li>再与原有的𝐿[𝑖]值比较那个更大，也就是𝐿[𝑖]=max∀𝑗&lt;𝑖𝐿[𝑗]+1,𝐿[𝑖]</li>
</ul>
</li>
<li>如果𝐴[𝑖]&lt;𝐴[𝑗]对所有的𝑗成立，则截至到𝐴[𝑗]的升序被打断，𝑖处最大升序只能为1即𝐿[𝑖]=1</li>
</ol>
<p>2️⃣算法设计</p>
<ol>
<li>设长度𝐿[]=[1]</li>
<li>用𝑖遍历𝐴中每个元素
<ul>
<li>用𝑗遍历𝐴[0]到𝐴[𝑖]每个元素
<ul>
<li>如果𝐴[𝑖]&gt;𝐴[𝑗]则𝐿[𝑖]=max𝐿[𝑗]+1,𝐿[𝑖]</li>
</ul>
</li>
</ul>
</li>
<li>输出𝐿[]中的最大值</li>
</ol>


<h2 class="relative group">动态规划4 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%924" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%924" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://leetcode.cn/problems/maximum-product-subarray/" target="_blank">https://leetcode.cn/problems/maximum-product-subarray/</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220211810784.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220211810784.png?lastModify=1746948169" alt="image-20250220211810784" />
      
    </figure>
</a></p>
<p>1️⃣可能的连续子序列有𝐶𝑛22=𝑂(𝑛2)，计算乘的平均长度为𝑛2，所以复杂度为𝑂(𝑛3)或𝑂(𝑛2)(并行优化后)</p>
<p>2️⃣分治法：</p>
<ol>
<li>将𝐴从𝐴[mid]处拆开
<ul>
<li>从𝐴[mid]往最右累乘，计算这一过程中的最大正数𝑅𝑃和最小负数𝑅𝑁</li>
<li>从𝐴[mid]往最左累乘，计算这一过程中的最大正数𝐿𝑃和最小负数𝐿𝑁</li>
<li>分别计算𝑅𝑃𝐿𝑃/𝑅𝑃𝐿𝑁/𝑅𝑁𝐿𝑃/𝑅𝑁𝐿𝑁，取其中最大值为𝑀</li>
<li>将左右两半边按照同样的方式递归处理</li>
</ul>
</li>
<li>合并操作：假设每个结点的左/右半边最大乘积为max𝑙/max𝑟，则取maxmax𝑙,max𝑟,𝑀</li>
<li>复杂度：假设不论多少位的乘法都可以在𝑂(1)内并行完成，则𝑇(𝑛)=2𝑇(𝑛2)+𝑂(1)
<ul>
<li>说过很多遍了，由主方法可得复杂度为𝑂(𝑛)</li>
</ul>
</li>
</ol>
<p>3️⃣动态规划：</p>
<ol>
<li>
<p>M  (  k  )的递推：以下分析再加上𝐴[𝑘]自己，𝑀(𝑘)=max𝐴[𝑘],𝑀(𝑘–1)𝐴[𝑘],𝑚(𝑘–1)𝐴[𝑘]</p>
<ul>
<li>M  (  k  ) 潜在的最大：𝐴[𝑘]为负数时，𝑀(𝑘)=𝑚(𝑘–1)𝐴[𝑘]</li>
<li>M  (  k  ) 潜在的最大：𝐴[𝑘]为正数时，𝑀(𝑘)=𝑀(𝑘–1)𝐴[𝑘]</li>
</ul>
</li>
<li>
<p>m  (  k  )的递推：以下分析再加上𝐴[𝑘]自己，𝑚(𝑘)=min𝐴[𝑘],𝑀(𝑘–1)𝐴[𝑘],𝑚(𝑘–1)𝐴[𝑘]</p>
<ul>
<li>m  (  k  ) 潜在的最小：𝐴[𝑘]为负数时，𝑚(𝑘)=𝑀(𝑘–1)𝐴[𝑘]</li>
<li>m  (  k  ) 潜在的最小：𝐴[𝑘]为正数时，𝑚(𝑘)=𝑚(𝑘–1)𝐴[𝑘]</li>
</ul>
</li>
<li>
<p>算法实现：复杂度为𝑂(𝑛)</p>
<ul>
<li>
<p>初始化𝑚[1]=𝐴[0]以及𝑀[1]=𝐴[0]</p>
</li>
<li>
<p>用𝑖遍历整个𝐴数组</p>
<ul>
<li>按照递归式填补𝑚[𝑖]和𝑀[𝑖]</li>
</ul>
</li>
<li>
<p>输出𝑀[𝑖]最大值</p>
</li>
<li>
<blockquote>
<p>代码如下，直接遍历以这个位置结尾的最大值和最小值。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">maxProduct</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">dpmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">dpmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dpmin</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dpmax</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">index</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dpmax</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">dpmax</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">dpmin</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dpmin</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">dpmax</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">dpmin</span><span class="o">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="w"> </span><span class="n">dpmax</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>


<h2 class="relative group">动态规划5 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%925" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%925" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221165417843.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221165417843.png?lastModify=1746948169" alt="image-20250221165417843" />
      
    </figure>
</a></p>
<p>1️⃣递推式：对𝑥[𝑖]有两种处理，即使用邮票𝑖或者不使用邮票𝑖</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagWeight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>如果不使用：也就是前𝑖–1张以最优结构凑出𝑗，所以𝑐[𝑖][𝑗]=𝑐[𝑖–1][𝑗]</li>
<li>如果使用：使用邮票𝑖后构成总邮资𝑗
<ul>
<li>01 背包问题：第𝑖张票不能再用了，也就是要前𝑖–1张邮票再构成总邮资𝑗–𝑥[𝑖]</li>
<li>完全背包问题：第𝑖张票有无限个还能再用，也就是要前𝑖张邮票再构成总邮资𝑗–𝑥[𝑖]</li>
<li>这里式完全背包问题，所以递归式为𝑐[𝑖][𝑗]=𝑐[𝑖][𝑗–𝑥[𝑖]]+1</li>
</ul>
</li>
<li>合起来就是：𝑐[𝑖][𝑗]=min𝑐[𝑖–1][𝑗],𝑐[𝑖][𝑗–𝑥[𝑖]]+1</li>
</ol>
<p>2️⃣初始条件：</p>
<ol>
<li>c  [  1  ]  [  j  ] ：要用第一种邮票构成邮资𝑗，由于𝑥[1]=1，所以𝑐[1][𝑗]=𝑗</li>
<li>c  [  i  ]  [  0  ] ：要用前𝑖种邮票构成邮资0，什么都不选就行了，所以𝑐[𝑖][0]=0</li>
<li>c  [  i  ]  [  1  ] ：要用前𝑖种邮票构成邮资1，显然就是选一个𝑥[1]就行了，所以𝑐[𝑖][1]=1</li>
</ol>
<p>3️⃣四张邮票所以𝑖≤4，最大邮资为8所以𝑗≤8，不断代入递归式就行了</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221185755022.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221185755022.png?lastModify=1746948169" alt="image-20250221185755022" />
      
    </figure>
</a></p>


<h2 class="relative group">动态规划6 
    <div id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%926" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%926" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221191101181.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221191101181.png?lastModify=1746948169" alt="image-20250221191101181" />
      
    </figure>
</a></p>
<p>1️⃣令𝑠𝑢𝑚[𝑖]为0→𝑖中子段最大和</p>
<ol>
<li>
<p>s  u  m  [  i      –    1  ]</p>
<p>要么是正数/0</p>
<ul>
<li>为正：为𝑠𝑢𝑚[𝑖]做出正向的贡献，即𝑠𝑢𝑚[𝑖]=𝑠𝑢𝑚[𝑖–1]+𝑎[𝑖]</li>
<li>为负：为𝑠𝑢𝑚[𝑖]无贡献，即𝑠𝑢𝑚[𝑖]=𝑎[𝑖]</li>
</ul>
</li>
<li>
<p>合起来就是：𝑠𝑢𝑚[𝑖]=max𝑠𝑢𝑚[𝑖–1]+𝑎[𝑖],𝑎[𝑖]</p>
</li>
</ol>
<p>3️⃣算法：加上负数抹成0的机制</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">def</span> <span class="n">max_subarray_sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">not</span> <span class="nl">a</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_sum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nl">max_sum</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">max_sum</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div>

<h2 class="relative group">贪心算法1 
    <div id="%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<blockquote>
<p>很奇妙呢，就是直接分成很多的3。</p></blockquote>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220231110398.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220231110398.png?lastModify=1746948169" alt="image-20250220231110398" />
      
    </figure>
</a></p>
<p>1️⃣这是一个严格的结论：令∀𝑛=3𝑚+r，其中𝑟=𝑛 mod 3</p>
<ol>
<li>r  =0 是分解为3𝑚</li>
<li>r  =1 是分解为3(𝑚–1)+2+2</li>
<li>r  =2 是分解为3𝑚+2</li>
</ol>
<p>2️⃣贪心选择性质：算法每一步的局部最优，会带来最终的全局最优</p>
<ol>
<li>首先证明分解数不超过4：假设某一个数分解出现了𝑘≥4，则乘积为𝑘×Rest
<ul>
<li>可以再将𝑘变成𝑘=2+(𝑘–2)，则乘积变为了2(𝑘–2)×Rest</li>
<li>2  (  k      –    2  )  ×  Rest      –    k  ×  Rest  =  (  k      –    4  )  ×  Rest  ≥  0 ，所以消除𝑘能使得乘积更大</li>
</ul>
</li>
<li>其次如果选择1也是不行的，比如𝑘×Rest≥1𝑘×Rest</li>
<li>所以最优情况必须是划为2或3的总和，接下来需要做的就是判断是以2为主还是以3为主
<ul>
<li>假设选择更多的2为最优，以6为例，＜23＜32所以不成立</li>
<li>所以应该分解为更多的3</li>
</ul>
</li>
<li>余数的处理
<ul>
<li>余数为0，不处理</li>
<li>余数为1，出现了1就不是最优了，最优的做法是借一个3将其分为2+2</li>
<li>余数为2，不处理</li>
</ul>
</li>
</ol>


<h2 class="relative group">贪心算法2 
    <div id="%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%952" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%952" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221161430253.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221161430253.png?lastModify=1746948169" alt=" " />
      
    </figure>
</a></p>
<p>0️⃣概念理解</p>
<ol>
<li>
<p>X 被𝑌覆盖：也就是𝑋的每个子区间都必须被𝑌的某个子区间覆盖</p>
</li>
<li>
<p>覆盖数：就是𝑌能覆盖𝑋后𝑌有多少子区间</p>
</li>
<li>
<blockquote>
<p>也就是中间可以有空的地方，这里要注意一下。</p></blockquote>
</li>
<li>
<p><strong>注意有一个误区，就是𝑌必须是𝑋的子集，不然一个从头到尾的大区间就覆盖掉了，不论中间有没有空隙</strong></p>
</li>
</ol>
<p>1️⃣贪心策略</p>
<ol>
<li>初始化：将𝑋中第一个区间放入𝑌，作为当前区间</li>
<li>更新：重复以下过程
<ul>
<li>如果当前区间与其他区间有交集
<ul>
<li>将选取右边界最大的有交集区间</li>
<li>将当前区间与右边界最大的区间进行合并加入到𝑌，形成新的当前区间</li>
</ul>
</li>
<li>如果当前区间与其他区间没有交集
<ul>
<li>选取离当前区间距离最小的区间</li>
<li>将该区间加入到𝑌中，更新当前区间为该区间</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>2️⃣最优性证明：</p>
<ol>
<li>假设存在某个更优解，其必定在某一部需要选择一个右端点更小的区间</li>
<li>从而导致相比原有做法，后续需要更多区间覆盖，不是最优</li>
<li>所以矛盾，本方法最优</li>
</ol>
<p>3️⃣复杂度：<strong>只需遍历一次，每个区间在每次遍历时只被处理一次</strong>，所以复杂度为𝑂(𝑛)</p>


<h2 class="relative group">贪心算法3 
    <div id="%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%953" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%953" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://leetcode.cn/problems/assign-cookies/description/" target="_blank">https://leetcode.cn/problems/assign-cookies/description/</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221194300049.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221194300049.png?lastModify=1746948169" alt="image-20250221194300049" />
      
    </figure>
</a></p>
<p>1️⃣首先讲所有小孩/饼干按照饥饿度/饼干大小排序</p>
<p>2️⃣用𝑖指针遍历小孩数组，用𝑗指针遍历饼干数组</p>
<ol>
<li>如果𝐶𝑖&gt;𝐵𝑗，则执行𝑗++</li>
<li>如果𝐶𝑖≤𝐵𝑗，则执行𝑗++/𝑖++/Count++</li>
</ol>
<p>3️⃣最终输出Count</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">findContentChildren</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">g</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">kidsNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cookiesNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="na">length</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">g</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

<h2 class="relative group">回溯法1 
    <div id="%E5%9B%9E%E6%BA%AF%E6%B3%951" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E6%B3%951" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220223720751.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220223720751.png?lastModify=1746948169" alt="image-20250220223720751" />
      
    </figure>
</a></p>
<p>1️⃣解向量为𝑥1,𝑥2,&hellip;,𝑥𝑛其中𝑥𝑖=0/1表示货物𝑖放/不放在船上，约束条件为𝑥𝑖∈0,1和∑𝑖=1𝑤𝑖𝑥𝑖≤𝑐</p>
<p>2️⃣如下图，结点表示当前总重量，<strong>遇到结点&gt;120的就剪枝</strong></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220223653303.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220223653303.png?lastModify=1746948169" alt="image-20250220223653303" />
      
    </figure>
</a></p>


<h2 class="relative group">回溯法2 
    <div id="%E5%9B%9E%E6%BA%AF%E6%B3%952" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E6%B3%952" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220224211083.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250220224211083.png?lastModify=1746948169" alt="image-20250220224211083" />
      
    </figure>
</a></p>
<p>0️⃣𝑛皇后问题：在𝑛×𝑛的棋盘上防止𝑛个皇后，所有的皇后不同行/不同列/不同对角线</p>
<ol>
<li>解向量：𝑥1,𝑥2,&hellip;,𝑥𝑛其中𝑥𝑖表示棋子位于第𝑖行第𝑥𝑖列</li>
<li>显约束：𝑥𝑖∈1,2,&hellip;,𝑛</li>
<li>隐约束：𝑥𝑖之间互不相等，不在同一对角线上|𝑥𝑖–𝑥𝑗|≠|𝑖–𝑗|，注意这个是<strong>所有对角线</strong></li>
</ol>
<p>1️⃣解空间树</p>
<blockquote>
<p>画个图来直接做剪枝的处理。</p></blockquote>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221005415328.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221005415328.png?lastModify=1746948169" alt="image-20250221005415328" />
      
    </figure>
</a></p>


<h2 class="relative group">回溯法3 
    <div id="%E5%9B%9E%E6%BA%AF%E6%B3%953" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E6%B3%953" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221142353446.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221142353446.png?lastModify=1746948169" alt="image-20250221142353446" />
      
    </figure>
</a></p>
<p>1️⃣解向量为𝑥1,𝑥2,&hellip;,𝑥𝑛，显性约束为𝑥𝑖=0,1，隐约束为∑𝑖=1𝑛𝑥𝑖𝑤𝑖=𝑚</p>
<p>2️⃣解为：8+3</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221144745248.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221144745248.png?lastModify=1746948169" alt="image-20250221144745248" />
      
    </figure>
</a></p>


<h2 class="relative group">回溯法4 
    <div id="%E5%9B%9E%E6%BA%AF%E6%B3%954" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E6%B3%954" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221145235986.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221145235986.png?lastModify=1746948169" alt="image-20250221145235986" />
      
    </figure>
</a></p>
<p>1️⃣解向量为𝑥1,𝑥2,&hellip;,𝑥𝑛</p>
<ol>
<li>
<p>显约束为𝑥𝑛=1,2,&hellip;,𝑛且互相间不相同</p>
</li>
<li>
<p>隐约束为在解向量中，当前在栈中的元素，必定排在已出栈元素的后面</p>
</li>
<li>
<blockquote>
<p>开始输出之后，就要一次性全部都输出出去。</p></blockquote>
</li>
</ol>
<p>2️⃣123进栈后能输出的只有：123/132/213/321，完全倒推出解空间树</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221151440975.png" target="_blank">
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221151440975.png" alt="image-20250221151440975" />
    
  </figure>
</a></p>


<h2 class="relative group">回溯法5(递归回溯) 
    <div id="%E5%9B%9E%E6%BA%AF%E6%B3%955%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E6%B3%955%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221151602627.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221151602627.png?lastModify=1746948169" alt="image-20250221151602627" />
      
    </figure>
</a></p>
<p>0️⃣注意这个问题进行的是<strong>深度优先搜索</strong>，即<strong>递归回溯</strong>，具体的图我就不画了</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231212002904408.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20231212002904408.png?lastModify=1746948169" alt="image-20231212002904408" />
      
    </figure>
</a></p>
<p>1️⃣算法思路：假设有𝑛个结点时</p>
<ol>
<li>初始化当前最优为1→2→3→4→5→1的距离，以便<strong>快速收敛</strong></li>
<li>回溯函数：用𝑖遍历树的每层：
<ul>
<li>当𝑖&lt;𝑛时，尝试将其与除结点𝑖外的下一层结点进行连接，如果从根到下一节点路径长于最优，则剪枝</li>
<li>当𝑖=𝑛时，尝试与起始点进行连接，如果能与起始点连接则计算哈密顿路径，更小则更新最优值</li>
</ul>
</li>
<li>输出最终的最优值 0</li>
</ol>


<h2 class="relative group">NP1 
    <div id="np1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np1" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>​	**(稠密子图问题DEN-SG)**给定无向图G，判定G中是否存在一个子图H，它有k个顶点，且至少有y条边。已知k团问题CLIQUE是NP完全问题，请证明稠密子图问题DEN-SG是NP完全问题。</p>
<p>1️⃣两个问题分别是什么</p>
<ol>
<li>稠密子图问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图边数大于等于𝑦</li>
<li>团问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图结点互相两两连接</li>
</ol>
<p>2️⃣先证明稠密子图NP，即它可在多项式时间内验证</p>
<ol>
<li>遍历子图所有顶点，并计算其边数，即可判断其总边数是否大于𝑦</li>
<li>耗𝑂(𝑘2)，所以是NP问题</li>
</ol>
<p>3️⃣证明团问题可以线性时间内规约到稠密子图问题</p>
<blockquote>
<p>很显然的直接推理就可以。</p></blockquote>
<ol>
<li>构建团问题的实例(𝐺,𝑘)：图𝐺中存在𝑘个结点两两连接的子图，则子图中边数为𝑘(𝑘−1)2</li>
<li>构建稠密子图问题的实例(𝐺,𝑘,𝑘(𝑘−1)2)</li>
<li>当团实例成立时，该稠密子图实例也成立，故团问题在多项式时间内规约到了稠密子图问题，证毕</li>
</ol>


<h2 class="relative group">NP2 
    <div id="np2" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np2" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>证明顶点覆盖问题（Vertex Cover Problem）属于NPC类</p>
<p>1️⃣两个问题分别是什么</p>
<ol>
<li>顶点覆盖问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，子图所有点能连接到图中所有边</li>
<li>团问题：给定无向图𝐺，要寻找它的一个包含𝑘个顶点的子图，并且该子图结点互相两两连接</li>
</ol>
<p>2️⃣证明顶点覆盖问题是NP：也就是可在所想是时间内验证</p>
<ol>
<li><strong>遍历子图中每一个点，记录每一点所连接的边，最后看这些边是否覆盖了所有边</strong></li>
<li>时间复杂度𝑂(𝑘2)</li>
</ol>
<p>3️⃣证明团问题可以线性时间内规约到顶点覆盖问题</p>
<ol>
<li>构建一个团问题的实例(𝐺,𝑘)：图𝐺中存在𝑘个结点两两连接的子图</li>
<li>构建覆盖问题实例(𝐺,|𝐺|−𝑘)</li>
<li>由于定理可知，当团问题实例成立时，覆盖问题实例也一定成立，证毕</li>
</ol>


<h2 class="relative group">NP3 
    <div id="np3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np3" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222030951252.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222030951252.png?lastModify=1746948169" alt="image-20250222030951252" />
      
    </figure>
</a></p>
<p>1️⃣证明子集覆盖时NP的：遍历𝐶中每一子集，从左到右依次合并，将最终结果与𝑋对比，即可在𝑂(𝑛)内验证</p>
<p>2️⃣证明顶点覆盖问题可在多项式时间内规约到子集覆盖问题</p>
<p>核心的思路就是，全集为所有边，一个点关联的所有边为一个子集</p>
<p>子图中点的边全覆盖了所有边，变成了子图中点对应的边的子集覆盖了全集</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222031558228.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222031558228.png?lastModify=1746948169" alt="image-20250222031558228" />
      
    </figure>
</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222031605987.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222031605987.png?lastModify=1746948169" alt="image-20250222031605987" />
      
    </figure>
</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222031613323.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222031613323.png?lastModify=1746948169" alt="image-20250222031613323" />
      
    </figure>
</a></p>


<h2 class="relative group">NP4 
    <div id="np4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#np4" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>👉𝑃问题：可在多项式时间内求解</p>
<p>👉𝑁𝑃问题：可在多项式时间内验证，但无法求解</p>
<p>👉𝑁𝑃𝐶问题：最难的𝑁𝑃问题</p>
<p>👉𝑁𝑃难问题：难度比𝑁𝑃𝐶还要难的问题，但不一定是𝑁𝑃问题</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221205533463.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221205533463.png?lastModify=1746948169" alt="image-20250221205533463" />
      
    </figure>
</a></p>
<p>1️⃣分别对/错/错，见上图</p>
<p>(判断)若问题A是一个P类问题，则A也是一个NP类问题  (判断)所有NP难问题都是NP问题 (判断)若问题A是一个NP问题，则A也是一P类问题</p>
<p>​</p>
<p>➡️由上图可知，选D</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222004928258.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222004928258.png?lastModify=1746948169" alt="image-20250222004928258" />
      
    </figure>
</a></p>
<p>2️⃣不对，不是上界是下界</p>
<blockquote>
<p>注意：在A归约B的情况下，到<strong>A的下界推出B的下界（相减），B的上界推出A的上界（相加）</strong>。</p></blockquote>
<p>(判断)若问题A的计算时间上界为O(𝑛2)，且问题A可在O(n)时间内变换为问题B，则问题B的计算时间上界也O(𝑛2)</p>
<ul>
<li>记住NP问题规约的一些结论：若𝐴可在𝑂(𝜏(𝑛))时间内变换到𝐵，即𝐴∝𝜏(𝑛)𝐵
<ul>
<li>显然凭直觉有𝑇𝐴=𝑂(𝜏(𝑛))+𝑇𝐵</li>
<li>则𝑇𝐴−𝑂(𝜏(𝑛))为𝐵的下界</li>
<li>则𝑇𝐵+𝑂(𝜏(𝑛))为𝐴的上界</li>
</ul>
</li>
</ul>
<p>➡️由以上结论可得选𝐷</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222002128084.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222002128084.png?lastModify=1746948169" alt="image-20250222002128084" />
      
    </figure>
</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222002135966.png" target="_blank">
  <figure>
    <img class="my-0 rounded-md" loading="lazy" src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222002135966.png" alt="image-20250222002135966" />
    
  </figure>
</a></p>
<p>3️⃣选𝐵要记住，如果𝐴是𝑁𝑃𝐶+𝐵是𝑁𝑃+𝐴线性时间可转化为𝐵，则𝐵是𝑁𝑃𝐶</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221224922056.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221224922056.png?lastModify=1746948169" alt="image-20250221224922056" />
      
    </figure>
</a></p>


<h2 class="relative group">算法导论 
    <div id="%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣不对，程序可以无限执行，比如系统进程</p>
<pre tabindex="0"><code>(判断)算法和程序都必须满足有限性，即在执行有限时间后结束
</code></pre><p>2️⃣两个都对</p>
<pre tabindex="0"><code>(判断)若f(n)=O(g(n))，且f(n)=Ω(g(n))，则f(n)=Θ(g(n))
(判断)若f(n)=Θ(g(n))，则f(n)=Ω(g(n))
</code></pre><ol>
<li>f  (  n  )  =  O  (  g  (  n  )  ) 即𝑓(𝑛)≤𝑐1𝑔(𝑛)，𝑓(𝑛)=Ω(𝑔(𝑛))即𝑓(𝑛)≥𝑐2𝑔(𝑛)，于是𝑐2𝑔(𝑛)≤𝑓(𝑛)≤𝑐1𝑔(𝑛)这就是𝛩(𝑔(𝑛))的定义</li>
<li>Θ  (  g  (  n  )  ) 即𝑐2𝑔(𝑛)≤𝑓(𝑛)≤𝑐1𝑔(𝑛)，于是𝑐2𝑔(𝑛)≤𝑓(𝑛)这就是Ω(𝑔(𝑛))的定义</li>
</ol>
<p>3️⃣就是说𝑓的增长要快于𝑔，所以是大于等于，也就是不小于，选𝐵</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221214920669.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221214920669.png?lastModify=1746948169" alt="image-20250221214920669" />
      
    </figure>
</a></p>
<p>➡️即𝑓(𝑛)≤𝑐𝑔(𝑛)，说明𝑔(𝑛)增长更快，所以𝑓(𝑛)阶更小(小于等于)，选𝐴</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221234610835.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221234610835.png?lastModify=1746948169" alt="image-20250221234610835" />
      
    </figure>
</a></p>
<p>➡️最好情况是紧的𝑐𝑓(𝑛)，所以平均情况肯定要高于𝑐𝑓(𝑛)，也就是以𝑐𝑓(𝑛)为下界，也就是Ω(𝑓(𝑛))选B</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222004036572.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222004036572.png?lastModify=1746948169" alt="image-20250222004036572" />
      
    </figure>
</a></p>
<p>4️⃣(7×2𝑛)×2=7×2𝑛′所以𝑛′=𝑛+1选𝐴</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221215150902.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221215150902.png?lastModify=1746948169" alt="image-20250221215150902" />
      
    </figure>
</a></p>
<p>➡️错误，归并排序又不是𝑂(𝑛)的</p>
<pre tabindex="0"><code>如果一个归并排序算法在某台机器上用1秒钟排序5000个记录，则用2秒钟可以排序10000个记录
</code></pre>

<h2 class="relative group">递归分治 
    <div id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣不对，直接间接调用，一个不能少</p>
<pre tabindex="0"><code>(判断)递归算法就是指一个直接调用自身的算法。
</code></pre><p>​</p>
<p>2️⃣对的，不断将问题分治为更小的规模</p>
<pre tabindex="0"><code>(判断)二分法搜索算法是运用了分治策略设计的。
</code></pre><p>​</p>
<p>3️⃣不对，也可以分治后，循环遍历处理每个子问题</p>
<pre tabindex="0"><code>分治必须用递归实现
</code></pre><p>​</p>
<p>4️⃣由主定理可知𝑛log𝑏⁡𝑎=𝑛，属于情况1，所以为Θ(𝑛log𝑏⁡𝑎)=Θ(𝑛)，选𝐵</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222001456312.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222001456312.png?lastModify=1746948169" alt="image-20250222001456312" />
      
    </figure>
</a></p>
<p>主定理：𝑇(𝑛)=𝑎𝑇(𝑛𝑏)+𝑓(𝑛)，则𝑇(𝑛)有如下渐进界</p>
<table>
  <thead>
      <tr>
          <th>条件</th>
          <th>结论</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>f  (  n  ) 的增长慢于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (      n                  log                  b                    ⁡      a        )</td>
      </tr>
      <tr>
          <td>f  (  n  ) 的增长等于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (      n                  log                  b                    ⁡      a        log  ⁡  n  )</td>
      </tr>
      <tr>
          <td>f  (  n  ) 的增长快于𝑛log𝑏⁡𝑎</td>
          <td>T  (  n  )  =  Θ  (  f  (  n  )  )</td>
      </tr>
  </tbody>
</table>
<p>➡️采用的分治法，一分为二，左右两边都要处理，所以𝑇(𝑛)=2𝑇(𝑛2)+𝑐，所以是Θ(𝑛)</p>
<p>5️⃣分别是：分治，贪心(  Dijkstra )，动态规划，贪心。所以选A</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222002804021.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222002804021.png?lastModify=1746948169" alt="image-20250222002804021" />
      
    </figure>
</a></p>


<h2 class="relative group">贪心 
    <div id="%E8%B4%AA%E5%BF%83" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%B4%AA%E5%BF%83" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣非01背包就是要价值/背包中总重最大，所以也一定是贪心地做出最有利于增大这一比例的选择</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221220037205.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221220037205.png?lastModify=1746948169" alt="image-20250221220037205" />
      
    </figure>
</a></p>
<ul>
<li>但是注意这里的非01背包问题，区别于01背包问题，可以将每个物品分割后放入</li>
</ul>
<p>2️⃣选𝐶，每次贪心地选择一行内总和最小的两个数</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221221624824.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221221624824.png?lastModify=1746948169" alt="image-20250221221624824" />
      
    </figure>
</a></p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221235923265.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221235923265.png?lastModify=1746948169" alt="image-20250221235923265" />
      
    </figure>
</a></p>
<p>3️⃣贪心(  Dijkstra )，因为每次都选离当前结点最近的点</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221234806590.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221234806590.png?lastModify=1746948169" alt="image-20250221234806590" />
      
    </figure>
</a></p>
<p>4️⃣都对，详见下</p>
<pre tabindex="0"><code>(判断)在求最小生成树的算法中， Kruskal算法使用的是贪心策略
(判断)求最小生成树的Prim算法使用的设计策略是贪心策略
</code></pre><p>​</p>
<ol>
<li>Kruskal ：边扩展，操作对象为所有边，选择权重最小的边加入生成树中</li>
<li>Prim ：点扩展，操作对象为与当前生成树连接的边，选择权重最小边的点加入生成树中</li>
</ol>


<h2 class="relative group">DP 
    <div id="dp" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#dp" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣不对，动态规划适用于解决<strong>最优子结构+重叠子问题</strong>的确定性问题</p>
<pre tabindex="0"><code>(判断)动态规划适合求解动态不确定性问题。
</code></pre><p>​</p>
<p>2️⃣对的，这是定义</p>
<pre tabindex="0"><code>(判断)最优子结构性质是指问题的最优解包含了子问题的最优解。
</code></pre><p>​</p>
<p>3️⃣选𝐵，这是定义</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221224231571.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221224231571.png?lastModify=1746948169" alt="image-20250221224231571" />
      
    </figure>
</a></p>
<p>4️⃣不对，详见下表</p>
<pre tabindex="0"><code>(判断)动态规划算法与分治法都采用自底向上的计算方式
</code></pre><p>​</p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>动态规划</th>
          <th>分治法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>分解方式</strong></td>
          <td>子问题可能重叠</td>
          <td>子问题相互独立</td>
      </tr>
      <tr>
          <td><strong>计算方向</strong></td>
          <td>自底向上</td>
          <td>自顶向下</td>
      </tr>
      <tr>
          <td><strong>是否存储子问题解</strong></td>
          <td>需要存储子问题解以避免重复计算</td>
          <td>不需要存储子问题解</td>
      </tr>
  </tbody>
</table>


<h2 class="relative group">回溯算法 
    <div id="%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣正确：区别见下</p>
<pre tabindex="0"><code>(判断)回溯法和分支限界法都是在问题解空间树上搜索问题解的算法
</code></pre><p>​</p>
<ul>
<li>搜索策略不同：回溯法通常采用深度优先搜索，而分支限界法通常采用广度优先或最小耗费优先搜索</li>
<li>剪枝方式不同：回溯法主要依赖约束条件，而分支限界法依赖限界函数</li>
</ul>
<p>2️⃣选𝐴，基本概念</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221221226165.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221221226165.png?lastModify=1746948169" alt="image-20250221221226165" />
      
    </figure>
</a></p>
<p>3️⃣选𝐶，回溯法是用约束条件剪去不满足约束的点及其子树，分支界限使用限界函数减去得不到最优解的子树</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221224559202.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221224559202.png?lastModify=1746948169" alt="image-20250221224559202" />
      
    </figure>
</a></p>
<p>4️⃣最坏情况要遍历所有的叶节点，有多少种排列就有几个叶节点，排列数为𝑛!，所以复杂度为𝑂(𝑛!)</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222013745652.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222013745652.png?lastModify=1746948169" alt="image-20250222013745652" />
      
    </figure>
</a></p>


<h2 class="relative group">分支限界 
    <div id="%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣选𝐷，我们上面之前讲得比较清楚了</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221225941630.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250221225941630.png?lastModify=1746948169" alt="image-20250221225941630" />
      
    </figure>
</a></p>
<p>2️⃣选𝐵，分析见下</p>
<p><a href="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250222011037122.png" target="_blank">
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="/img/image-20250222011037122.png?lastModify=1746948169" alt="image-20250222011037122" />
      
    </figure>
</a></p>
<ol>
<li>首先了解这三个概念
<ul>
<li>活结点：本身已生成，子节点还未全部生成</li>
<li>扩展结点：正在生成子节点</li>
<li>死结点：子节点全部生成完毕</li>
</ul>
</li>
<li>回溯法：深度优先
<ul>
<li>比如当前结点有多个子节点，当前生成了一个结点后，先往深处搜索</li>
<li>搜索到底部了之后，再回溯过来生成下一个子节点</li>
<li>所有有多次机会</li>
</ul>
</li>
<li>分支界限法：广度优先，一次性一股脑生成所有子节点，所以只有一次机会</li>
</ol>
<p>3️⃣对的，结点选择方法，比如栈式分支/队列式分支/优先对列分支，会影响搜索的路径和效率</p>
<pre tabindex="0"><code>(判断)扩展节点的选择影响分支限界法
</code></pre><p>​</p>
<p>4️⃣不对，二者的根本差别不在用不用栈，而在深度优先和广度优先搜索，还有剪枝规则</p>
<pre tabindex="0"><code>(判断)在分支限界法中，如果将活结点用栈来存储，则这种分支界限法就是回溯法
</code></pre>

<h2 class="relative group">概念题目 
    <div id="%E6%A6%82%E5%BF%B5%E9%A2%98%E7%9B%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%A6%82%E5%BF%B5%E9%A2%98%E7%9B%AE" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>1️⃣写出分治、动态规划、贪心、回溯算法的策略</p>
<ol>
<li>分治：自上而下地将一个复杂问题分为若干简单可直接求解的子问题，通过子问题的解得到原有问题的解</li>
<li>动态规划：将原问题分为互相重叠的子问题，分别解决子问题最终自下而上地合并为原问题的解</li>
<li>贪心：每一步都采取当前状态下最好的选择，从而导致全局都是最优的</li>
<li>回溯：在问题的解空间树上深度优先搜索问题的解，并在不满足约束条件时进行剪枝回退</li>
</ol>
<p>2️⃣什么是算法的复杂性？ 什么是算法的渐进复杂性？</p>
<ol>
<li>复杂性：算法运行所需要的所有计算资源</li>
<li>渐进复杂度：算法规模趋近于穷时，算法的复杂性所趋近的值</li>
</ol>
<p>3️⃣在回溯法中， 什么是约束函数和界限函数？ 它们在搜索过程中的作用是什么？</p>
<ol>
<li>约束函数：用于检测是否满足约束条件，用于在回溯法中剪去不满足约束条件的结点及其子树</li>
<li>界限函数：用于计算当前结点是否能达到最优，用于剪去不能达到最优的结点及其子树</li>
</ol>
<p>4️⃣什么是最优子结构？ 请举例说明。</p>
<ol>
<li>最优子结构：当一个问题的最优解包含其所有子问题的最优解时，称之为具有最优子结构</li>
<li>比如：Dijkstra问题中最短路径就具有最优子结构</li>
</ol>
<p>5️⃣线性时间选择算法：找到第𝑘小的数</p>
<ol>
<li>将输入数组按5个一组划分，每组内元素进行排序，选出每组中位数组成一个新的数组</li>
<li>对新数组再进行相同操作，得到中位数的中位数，作为数组的Pivot划分数组</li>
<li>确定第𝑘小的数在数组那一部分，然后递归地处理呢一部分</li>
</ol>
<p>6️⃣什么是算法？算法应满足的标准是什么？</p>
<ol>
<li>算法：解决问题的方法和过程，有穷操作和指令的集合</li>
<li>标准：确定性，有穷性，可行性，健壮性</li>
</ol>

          
          
          
        </div>
        
        

          
            
            
<div class="flex author">
  
    
    
      
    
    
      
        
      
      <img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width="96" height="96"
      alt="mio" src="/img/blowfish_logo_hu_2d15729eafedea4d.png" />
    
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      Author
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      mio
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">I&rsquo;m Just A Student&hellip;</div>
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

          

          

          
          <div class="mb-10"></div>
          

        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_Notes\/AlgorithmDesign\/index.md"
        var oid_likes = "likes_Notes\/AlgorithmDesign\/index.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/notes/80x86assembly/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >80X86:Assembly</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2025-05-11T15:06:35&#43;08:00">11 May 2025</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top" title="Scroll to top">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
    <nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400">
      <ul class="flex flex-col list-none sm:flex-row">
        
        <li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0">
          <a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href="/reading/"
            title="">
            
            Reading
          </a>
        </li>
        
      </ul>
    </nav>
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2025
      mio
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="http://localhost:1313/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
